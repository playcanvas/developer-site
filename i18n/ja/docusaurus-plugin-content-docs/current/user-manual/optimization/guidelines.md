---
title: General Guidelines
sidebar_position: 1
---

PlayCanvasアプリで最適なパフォーマンスを得るためのヒントをいくつか紹介します。

## JavaScript

* JavaScript オブジェクトを割り当てるために 'new' を呼び出すことは（特にベクトル、行列、四元数など）動的割り当てを表し、コストがかかる場合があります。そのため、可能であれば、スクリプトのinitialize関数で事前にオブジェクトを割り当て、update関数で再利用することが推奨されます。また、これは、ガベージコレクションを引き起こすため、定期的なフリーズを引き起こすことがあります。

## グラフィックス - CPU

* PlayCanvas において、メッシュインスタンスはドローコール（グラフィックプリミティブを描画するためのコマンド）です。各ドローコールは CPU 上で WebGL にディスパッチするためのコストが必要です。したがって、特にモバイルにおいてドローコールの数を低く保つことが望ましいです。モデルを選択し、インスペクターで表示することで、モデルに対するドローコールのリストが表示されます。100～200のドローコールは、ローエンドのモバイルデバイスにとって目安となります。一方、ハイエンドのデスクトップマシンは、フレームごとに数千個の描画呼び出しを処理しても、60fps を維持することができます。
* [バッチング][1]を使用してドローコールを減らします。Project でBatch Groupを作成し、それらを Render、Model、Element コンポーネントに割り当てることで、エンジンは可能な限り少数のメッシュインスタンスにマージし、ドローコールを減らしてパフォーマンスを向上させます。
* アプリで生成されるシェーダーの数をできるだけ少なくするようにしてください。シェーダーは必要に応じてコンパイルおよびリンクされる必要があり、これは高コストであり、アプリの起動に遅延を引き起こし、フレームレートに欠陥を引き起こします。もし、マテリアルのAがEmissiveマップを持つのに対し、マテリアルBが持たない場合に2つのシェーダーが生成されます。マテリアルBに黒いEmissiveマップを設定すると、マテリアルは同じシェーダーを共有できます。シーン内のマテリアルの数を減らすことで、生成されるシェーダーの数も減らすことができます。
* スキニングされたメッシュの場合、カメラのフラスタムカリングで必要な正確なバウンディングボックスがエンジンによって毎フレーム生成されます。この操作にはある程度のコストがかかり、キャラクターがビューフラスタムから完全に外れている場合でも実行されます。このコストを避けるためには、[`Render`][5]または[`Model`][6] コンポーネントのプロパティであるカスタム AABB をキャラクターに設定することを検討してください。
* Cameraコンポーネントでフラスタムカリングを有効にする場合は、計算するコストを上回る可能性がある場合に限り、パフォーマンスを節約できる場合にのみ有効にしてください。すべてのメッシュインスタンスが常に表示される場面をレンダリングしている場合、このオプションを無効にしてください。

## グラフィックス - GPU

* プロジェクト設定で「Use Device Pixel Ratio」を有効にする際に注意してください。これにより、PlayCanvas アプリはデバイスのネイティブ解像度を利用してピクセル化を減らしますが、多くのピクセルが塗りつぶされることになり、フレームレートが著しく低下する可能性があります。これは、ユーザーのデバイスの性能を評価した後にランタイムで調整できます。詳しくは[こちら][2]を参照してください。
* シーン内のダイナミックライトの数に注意してください。可能な限り最小限に抑えてください。
* テクスチャの異方性 (Anisotropy) の値が増加するほど、視覚的な品質は向上しますが、パフォーマンスが低下します。視覚的品質とパフォーマンスのバランスに注意してください。
* 1つの画像に複数のテクスチャをパックする機会があるかどうかを探してください。たとえば、グレースケールのOpacityマップは、Diffuseマップのアルファチャンネルに保存できます。また、グレースケールのGlossマップは、Specularマップのアルファチャンネルに保存できます。これにより、VRAMの使用量を低減できます。
* ポストエフェクトは高コストなため、有効にする前によく考えてください。ピクセルフィルに関しても多くのコストを伴います。
* マテリアルで裏面カリングを有効にする方が、無効にするよりも安価になります。一般的に、裏面カリングは、GPU が塗りつぶすピクセルの数を減らすことができます。これは、新しく作成されたマテリアルのデフォルト設定です。

## グラフィックス - CPUとGPU

* コンフィギュレーターなどビジュアルにあまり変化がないアプリケーションでは、CPU および GPU の使用を削減する特別なプロパティがあります。[`pc.Application#autoRender`][3]を `false` に設定することで、ユーザーがカメラを移動したり製品にパーツを追加するなど、視覚的に変化があった場合にのみ[`pc.Application#renderNextFrame`][4]を介してフレームをレンダリングします。
* ダイナミックライトでシャドウキャストを有効にすることは高価です。オムニライトのシャドウは特に高価です。各オムニライトが影を投影する場合、シーンをシャドウマップに6回レンダリングする必要があります。
* シーン内のブレンドされたメッシュインスタンスの数を最小限に抑えてください。ブレンドされたメッシュは、不透明なメッシュインスタンスがすべてディスパッチされた後に、後方から前方のカメラ深度順に提出されます。これにより、ピクセルが複数回塗りつぶされるため、多数のレンダーステート変更が必要になります。ブレンドされたメッシュはマテリアルによってソートできないためです。

## 物理 (Physics)

* Collisionメッシュはレンダリング用メッシュと同じ詳細度である必要はありません。 衝突用に解像度が低いメッシュを設定することをお勧めします。
* 特にモバイルにおいて、シーン内の動的なRigidBodyの数を最小限に保つようにしてください。

[1]: /user-manual/graphics/advanced-rendering/batching
[2]: /user-manual/optimization/runtime-devicepixelratio
[3]: https://api.playcanvas.com/classes/Engine.Application.html#autoRender
[4]: https://api.playcanvas.com/classes/Engine.Application.html#renderNextFrame
[5]: https://api.playcanvas.com/classes/Engine.RenderComponent.html#customAabb
[6]: https://api.playcanvas.com/classes/Engine.ModelComponent.html#customAabb
