---
title: Столкновения и Триггеры
layout: tutorial-page.hbs
tags: collision, physics
thumb: https://s3-eu-west-1.amazonaws.com/images.playcanvas.com/projects/12/405871/0D7E2F-image-75.jpg
---

<iframe loading="lazy" src="https://playcanv.as/p/1Hj5fX2I/" title="Collision and Triggers"></iframe>

*Твердые тела сталкиваются друг с другом, звук воспроизводится при столкновении, а объем триггера сбрасывает формы.*

В этом уроке представлены основы физики твердых тел, обнаружение столкновений и объемы триггеров. Посмотрите [проект урока][1].

## Компонент Collision

Компонент *collision* определяет форму, которая может использоваться либо для вызова событий, если другая Entity входит или выходит из нее - мы называем это объемом триггера - либо он может использоваться вместе с компонентом *rigidbody* для придания Entity физических свойств в вашей игре - например, отскакивающий мяч или тяжелый ящик.

Самое важное свойство компонента *collision* - это его **Type**, оно определяет форму используемого объема. Есть четыре варианта:

* **Box** Простой параллелепипед
* **Sphere** Простая сфера
* **Capsule** Капсула в форме таблетки. Подходит для персонажей, так как может быть высокой и тонкой, но имеет хорошую округлую основу с одной точкой контакта.
* **Mesh** Используйте любую произвольную форму сетки для объема. **Примечание** Существуют некоторые ограничения для столкновений сетки, в частности, при использовании с компонентом *rigidbody*, они должны быть **Static**.

### Объемы триггеров

Чтобы создать объем триггера, достаточно добавить компонент *collision* к Entity. В этом уроке мы добавляем большой объем триггера в форме параллелепипеда под склоном, чтобы сбросить падающие тела и сбросить их положение.

![Столкновения и Триггеры][3]

Вы можете увидеть объем триггера под рампой, отображаемый синим контуром.

### Твердые тела

Твердое тело - это физическое присутствие в вашем игровом мире. Вы можете настроить его с реальными физическими свойствами, такими как масса и трение; оно будет сталкиваться с другими твердыми телами и реагировать реалистичным образом.

Чтобы создать твердое тело в вашей сцене, выберите Entity и добавьте компонент *rigidbody* и компонент *collision*. По умолчанию вы создадите **static box**. Компонент *rigidbody* имеет множество параметров, которые вы можете использовать для настройки свойств вашего объекта.

![компонент rigidbody][4]

Для получения информации о каждом свойстве ознакомьтесь с [документацией по *rigidbody*][5].

Для этой демонстрации важным свойством является **Type**. Вы можете выбрать один из трех вариантов:

* **Static** это Entity никогда не будет двигаться.
* **Dynamic** это Entity будет двигаться под действием гравитации и любых других сил, которые вы на него примените.
* **Kinematic** это Entity не будет реагировать на силы, но будет двигаться, если вы напрямую установите его положение или скорость.

## Настройка земли

Первой Entity, которую нам нужно в этом уроке, является зеленый блок, который образует землю.

<img loading="lazy" src="/images/tutorials/collision/ground_setup.png" width="300">

Вы можете видеть в панели атрибутов, что у него есть компоненты *render*, *collision* и *rigidbody*. Мы увеличили Entity и свойства *collision* box, чтобы оно было хорошо и большим. И мы также немного увеличили свойства трения и восстановления. Это означает, что поверхность немного шероховатее и немного упругее, чем значения по умолчанию.

## Настройка триггера

Следующей Entity, которую нам понадобится, является триггер.

![Триггер Entity][7]

У этой Entity есть компонент *collision*, но нет *rigidbody*, поэтому он действует как триггер. Триггер Entity также имеет компонент *script* с прикрепленным кодом. Триггеры полезны только в том случае, если что-то происходит, когда они активированы, поэтому нам нужно добавить некоторый код для вызова и прослушивания событий, когда триггер активирован.

```javascript
var Trigger = pc.createScript('trigger');

// инициализация кода, вызываемого один раз для каждой сущности
Trigger.prototype.initialize = function() {
    this.entity.collision.on('triggerenter', this.onTriggerEnter, this);
};

Trigger.prototype.onTriggerEnter = function(entity) {
    entity.rigidbody.linearVelocity = pc.Vec3.ZERO;
    entity.rigidbody.angularVelocity = pc.Vec3.ZERO;
    // Возврат к примерной начальной позиции сущности.
    var position = entity.getPosition();
    entity.rigidbody.teleport(position.x, 10, 0);
};
```

Есть две значительные части кода выше.

Во-первых, в```initialize```метод мы начинаем прослушивать событие **triggerenter**. Это событие срабатывает один раз, когда твердое тело входит в объем триггера (где объем триггера - это сущность, имеющая компонент столкновения, но не имеющая компонента твердого тела). Сопутствующее событие - **triggerleave**, которое срабатывает один раз, когда проникающее твердое тело покидает триггер.

```javascript
this.entity.collision.on('triggerenter', this.onTriggerEnter, this);
```

Обратите внимание, на третий аргумент,```this```в слушателе событий является тем же объектом Script.

Вторая часть этого кода - функция, которая обрабатывает событие,```onTriggerEnter```Когда триггер активируется, эта функция вызывается и передает [Entity](Entity.md) объект, который вошел в триггер. 

Пример:

```lua
function Script:Start()
  self.entity:Connect("OnTriggerEnter", self, "OnTriggerEnter")
end

function Script:OnTriggerEnter(entity)
  Log:Write("Entity " .. entity:GetKeyValue("name") .. " entered the trigger")
end
```

![Tutorial Thumbnail](Images/TutorialThumbnail.png)

Смотрите также:

- [Entity.OnTriggerExit](Entity.OnTriggerExit.md)
- [Entity.OnTriggerStay](Entity.OnTriggerStay.md)
- [Issue Tracker](https://github.com/Leadwerks/Documentation/issues)```Entity```][8] объект, входящий в объем триггера.

В этом случае, когда триггер срабатывает, мы сбрасываем проникающий Entity обратно в начальное положение и сбрасываем его скорости.

## Твердые тела

Мы установили землю на **Static**, теперь создадим падающие объекты и убедимся, что они **Dynamic**.

<img loading="lazy" src="/images/tutorials/collision/box_setup.png" width="300">

Это настройка *rigidbody* и *collision* для компонента коробки, сфера и капсула настроены таким же образом.

## События контакта

В компоненте *collision* доступно три события:

* **contact** - срабатывает для каждой точки контакта, когда два твердых тела касаются друг друга.
* **collisionstart** - срабатывает в начале столкновения, когда два твердых тела касаются друг друга.
* **collisionend** - срабатывает, когда два твердых тела разделяются.

Разница между **contact** и **collisionstart** тонкая, но важная. Представьте куб, приземляющийся под углом на плоскую поверхность. Когда край куба ударяется о поверхность, два угла куба ударятся одновременно. Сработают три события: два события **contact** для каждого угла куба и одно событие **collisionstart**. Затем куб будет вращаться и продолжать падать, пока не ляжет плоско, все это время оставаясь в контакте с поверхностью. Когда он приземлится плоско, еще два события **contact** сработают, когда край куба ударится о поверхность. Поскольку куб все это время оставался в контакте с поверхностью, больше событий **collisionstart** не срабатывает.

Оба события полезны, но в этой демонстрации мы будем использовать событие **collisionstart** для запуска звукового эффекта, который воспроизводится, когда объекты ударяются о землю. Вот код:

```javascript
var Collider = pc.createScript('collider');

// инициализация кода, вызываемая один раз для каждой сущности
Collider.prototype.initialize = function () {
    this.entity.collision.on('collisionstart', this.onCollisionStart, this);
};

Collider.prototype.onCollisionStart = function (result) {
    if (result.other.rigidbody) {
        this.entity.sound.play("hit");
    }
};
```

В этом выпуске Issue Tracker:

- Добавлен новый учебник: "Tutorial Thumbnail"
- Исправлены ошибки в Entity и Material Asset
- Улучшен интерфейс Material Inspector
- Обновлен Shader Editor
- Добавлены новые функции в Node Inspector
- Улучшен Texture Inspector
- Исправлены ошибки в Graph Inspector

В следующем выпуске:

- Новые функции для Graph Editor
- Улучшенный интерфейс для Assets
- Дополнительные опции для Asset```initialize```В этом методе мы настраиваем прослушиватель событий, а затем в обработчике событий проверяем, есть ли у другой сущности компонент **rigidbody** (это нужно, чтобы избежать воспроизведения звука при входе в объем триггера), и затем воспроизводим звуковой эффект "удар". Теперь каждый раз, когда Entity с прикрепленным скриптом коллайдера сталкивается с другим твердым телом, будет воспроизводиться звук удара.

И это все, что нужно знать о работе с коллизиями и триггерами в PlayCanvas.

[1]: https://playcanvas.com/project/405871
[3]: /images/tutorials/collision/collision_and_triggers.jpg
[4]: /images/user-manual/scenes/components/component-rigid-body-dynamic.png
[5]: /user-manual/packs/components/rigidbody/
[6]: /images/tutorials/collision/ground_setup.png
[7]: /images/tutorials/collision/trigger_setup.jpg
[8]: /api/pc.Entity.html
[9]: /images/tutorials/collision/box_setup.png
