"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[7705],{28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>l});var t=r(96540);const a={},s=t.createContext(a);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:n},e.children)}},37442:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"user-manual/graphics/shaders/wgsl-specifics","title":"WGSL Specifics","description":"WGSL shaders used by the PlayCanvas engine must satisfy certain requirements. These requirements allow the engine to correctly integrate shaders, ensuring they receive the necessary resources such as attributes, uniforms, and varyings.","source":"@site/docs/user-manual/graphics/shaders/wgsl-specifics.md","sourceDirName":"user-manual/graphics/shaders","slug":"/user-manual/graphics/shaders/wgsl-specifics","permalink":"/user-manual/graphics/shaders/wgsl-specifics","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/graphics/shaders/wgsl-specifics.md","tags":[],"version":"current","frontMatter":{"title":"WGSL Specifics"},"sidebar":"userManualSidebar","previous":{"title":"GLSL Specifics","permalink":"/user-manual/graphics/shaders/glsl-specifics"},"next":{"title":"Shader Chunk Migrations","permalink":"/user-manual/graphics/shaders/migrations"}}');var a=r(74848),s=r(28453);const i={title:"WGSL Specifics"},l=void 0,c={},o=[{value:"Simplified Shader Interface Syntax",id:"simplified-shader-interface-syntax",level:3},{value:"Example Comparison",id:"example-comparison",level:4},{value:"Attributes",id:"attributes",level:3},{value:"Uniforms",id:"uniforms",level:3},{value:"Texture Resources",id:"texture-resources",level:3},{value:"Sampling Textures",id:"sampling-textures",level:4},{value:"Fetching Textures",id:"fetching-textures",level:4},{value:"Unfilterable Textures",id:"unfilterable-textures",level:4},{value:"Storage Buffers",id:"storage-buffers",level:3},{value:"Varyings",id:"varyings",level:3},{value:"Vertex Shader",id:"vertex-shader",level:4},{value:"Fragment Shader",id:"fragment-shader",level:4},{value:"Fragment Shader Outputs",id:"fragment-shader-outputs",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"WGSL shaders used by the PlayCanvas engine must satisfy certain requirements. These requirements allow the engine to correctly integrate shaders, ensuring they receive the necessary resources such as attributes, uniforms, and varyings."}),"\n",(0,a.jsx)(n.p,{children:"The following sections outline key aspects of writing WGSL shaders for PlayCanvas."}),"\n",(0,a.jsx)(n.h3,{id:"simplified-shader-interface-syntax",children:"Simplified Shader Interface Syntax"}),"\n",(0,a.jsxs)(n.p,{children:["In standard WGSL (WebGPU Shading Language), declaring uniforms, attributes, and varyings requires explicitly specifying a ",(0,a.jsx)(n.code,{children:"@group"})," and ",(0,a.jsx)(n.code,{children:"@binding"})," index for each resource. This can be verbose and error-prone, especially for common patterns."]}),"\n",(0,a.jsxs)(n.p,{children:["To improve usability and streamline shader development, we adopt a simplified syntax similar to GLSL. In this model, you do not need to specify ",(0,a.jsx)(n.code,{children:"@group"})," or ",(0,a.jsx)(n.code,{children:"@binding"})," attributes manually\u2014these are automatically assigned and managed by the engine based on a predefined layout."]}),"\n",(0,a.jsx)(n.h4,{id:"example-comparison",children:"Example Comparison"}),"\n",(0,a.jsx)(n.p,{children:"Standard WGSL:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"struct Uniforms {\n    uTime: f32,\n};\n\nstruct FragmentInput {\n    @location(0) uv0: vec2f,\n    @builtin(position) position: vec4f\n};\n\n@group(0) @binding(0) var<uniform> ub: Uniforms;\n\n@fragment fn fragmentMain(FragmentInput) -> @location(0) vec4f {\n    // body\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"In contrast, the simplified syntax avoids a lot of the boilerplate."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"uniform uTime: f32;\nvarying uv0: vec2f;\n\n@fragment fn fragmentMain(input: FragmentInput) -> FragmentOutput {\n    // body\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"attributes",children:"Attributes"}),"\n",(0,a.jsx)(n.p,{children:"Attributes define per-vertex input data, and can only be used in the vertex shader. They must be declared using the following syntax:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"attribute aUv0: vec2f;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Internally, a ",(0,a.jsx)(n.code,{children:"VertexInput"})," struct is automatically created and populated with all the attributes. Attributes can be accessed from the structure passed to the main function, but also in the global scope."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"attribute aUv0: vec2f;\n\n@vertex fn vertexMain(input: VertexInput) -> VertexOutput {\n\n    // access it using input passed to the main function\n    var myUv1 = input.aUv0;\n\n    // but also as a global variable (particularly useful inside other functions)\n    var myUv2 = aUv0;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As part of the ",(0,a.jsx)(n.code,{children:"VertexInput"})," structure, and also in the global scope, these built-in attributes are automatically available:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"vertexIndex: @builtin(vertex_index)\ninstanceIndex: @builtin(instance_index)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The attribute names must match the names specified in the ",(0,a.jsx)(n.code,{children:"attributes"})," property when creating the ",(0,a.jsx)(n.a,{href:"/user-manual/graphics/shaders/",children:"ShaderMaterial"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"uniforms",children:"Uniforms"}),"\n",(0,a.jsxs)(n.p,{children:["Uniforms are used to pass ",(0,a.jsx)(n.em,{children:"numerical resources"})," from the engine to the shader."]}),"\n",(0,a.jsx)(n.p,{children:"Uniforms are declared using this simplified syntax:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"uniform view_position: vec3f;\nuniform tints: array<vec3f, 4>;\nuniform weights: array<f32, 8>;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Internally, uniforms are automatically placed in uniform buffers, and in the shader code are accessed using a ",(0,a.jsx)(n.code,{children:"uniform."})," prefix:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"var pos = uniform.view_position;\nvar color = uniform.tints[2];\n\n// f32 and vec2<> types used in an array are due to alignment requirements wrapped\n// in an aligned structure, and the value is available as its `element` property.\n// struct WrappedF32 { @size(16) element: f32 }\nvar weight = uniform.weights[3].element;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The engine automatically sets appropriate uniform values when rendering."}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["Currently, our uniform system supports only simple types, including ",(0,a.jsx)(n.code,{children:"f32"}),", ",(0,a.jsx)(n.code,{children:"i32"}),", ",(0,a.jsx)(n.code,{children:"u32"}),", as well as vectors and matrices (e.g., ",(0,a.jsx)(n.code,{children:"vec4f"}),", ",(0,a.jsx)(n.code,{children:"mat4x4f"}),"). Structs are not supported at this time, so all uniform values must be declared as individual variables of basic types."]})}),"\n",(0,a.jsx)(n.h3,{id:"texture-resources",children:"Texture Resources"}),"\n",(0,a.jsxs)(n.p,{children:["Texture resources are using simplified WGSL syntax, where specifying a ",(0,a.jsx)(n.code,{children:"@group"})," and ",(0,a.jsx)(n.code,{children:"@binding"})," index for each resource has to be omitted."]}),"\n",(0,a.jsx)(n.h4,{id:"sampling-textures",children:"Sampling Textures"}),"\n",(0,a.jsx)(n.p,{children:"In WGSL, textures and samplers are treated as separate objects, unlike in GLSL, where those are combined."}),"\n",(0,a.jsxs)(n.p,{children:["When you want to sample a texture (i.e. retrieve filtered texel values), you must provide a texture object ",(0,a.jsx)(n.em,{children:"directly followed"})," by a sampler."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"// 2d texture with a sampler declaration\nvar diffuseMap: texture_2d<f32>;\nvar diffuseMapSampler: sampler;\n\n// texture sampling\nvar texel = textureSample(diffuseMap, diffuseMapSampler, coords);\n"})}),"\n",(0,a.jsx)(n.h4,{id:"fetching-textures",children:"Fetching Textures"}),"\n",(0,a.jsxs)(n.p,{children:["If you only need to read raw texel data (i.e., without filtering, mipmapping, or addressing modes), you can use ",(0,a.jsx)(n.code,{children:"textureLoad"})," instead of ",(0,a.jsx)(n.code,{children:"textureSample"}),". This is called non-filtered access, or simply texel fetching."]}),"\n",(0,a.jsx)(n.p,{children:"In such cases, no sampler is required or allowed. For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"// cubemap texture without a sampler\nvar noSamplerMap: texture_cube<f32>;\n\n// fetching the texel\nlet texel = textureLoad(noSamplerMap, coords, mipLevel);\n"})}),"\n",(0,a.jsx)(n.h4,{id:"unfilterable-textures",children:"Unfilterable Textures"}),"\n",(0,a.jsxs)(n.p,{children:["WebGPU supports unfilterable float textures, which are typically used for specialized purposes such as sampling from depth textures, where filtering is not allowed. However, WGSL does not provide a distinct sample type in the syntax for declaring these unfilterable float textures. To address this limitation and enable proper bind group auto-generation based on shader declarations, we introduce a new sample type called ",(0,a.jsx)(n.code,{children:"uff"})," (unfilterable-float)."]}),"\n",(0,a.jsxs)(n.p,{children:["Using ",(0,a.jsx)(n.code,{children:"uff"}),", you can explicitly declare an unfilterable-float texture in the shader like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"// declaration\nvar colorMap: texture_2d<uff>;\n\n// sampling\nlet data: vec4f = textureLoad(colorMap, uv, 0);\n"})}),"\n",(0,a.jsx)(n.p,{children:"This extension allows the engine to correctly interpret the texture\u2019s sampling capabilities and bind it accordingly."}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["Support for ",(0,a.jsx)(n.code,{children:"texture_external"})," is not available yet, and will be added in the future."]})}),"\n",(0,a.jsx)(n.h3,{id:"storage-buffers",children:"Storage Buffers"}),"\n",(0,a.jsxs)(n.p,{children:["Storage buffers are GPU-accessible memory resources that allow shaders to read and write arbitrary data with random access. In WGSL, they are declared using ",(0,a.jsx)(n.code,{children:"var<storage>"})," and are ideal for working with large or structured datasets such as particle systems, compute data, or dynamic geometry. Unlike uniforms, storage buffers support both read and write access (with appropriate access control)."]}),"\n",(0,a.jsx)(n.p,{children:"Example of using storage buffer in Vertex Shader:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"struct Particle {\n    position: vec3f,\n    velocity: vec3f,\n}\n\n// particle storage buffer in read-only mode\nvar<storage, read> particles: array<Particle>;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"varyings",children:"Varyings"}),"\n",(0,a.jsx)(n.p,{children:"Varyings are used to pass values from the vertex shader to the fragment shader. Declare them in both vertex and fragment shader using this simplified syntax:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"varying texCoord: vec2f;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Internally, those are parsed, and stored in ",(0,a.jsx)(n.code,{children:"VertexOutput"})," structure in the vertex shader, as well as in ",(0,a.jsx)(n.code,{children:"FragmentInput"})," structure in the fragment shader."]}),"\n",(0,a.jsx)(n.h4,{id:"vertex-shader",children:"Vertex Shader"}),"\n",(0,a.jsxs)(n.p,{children:["As part of the ",(0,a.jsx)(n.code,{children:"VertexOutput"})," structure these built-in variables are automatically available:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"position: @builtin(position)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"varying texCoord: vec2f;\n\n@vertex fn vertexMain(input: VertexInput) -> VertexOutput {\n    var output: VertexOutput;\n    output.position = uniform.matrix_viewProjection * pos;\n    output.texCoord = vec2f(0.0, 1.0);\n    return output;\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"fragment-shader",children:"Fragment Shader"}),"\n",(0,a.jsxs)(n.p,{children:["As part of the ",(0,a.jsx)(n.code,{children:"FragmentInput"})," structure these built-in variables are automatically available:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"position: @builtin(position)            // interpolated fragment position\nfrontFacing: @builtin(front_facing)     // front-facing\nsampleIndex: builtin(sample_index)      // sample index for MSAA\n"})}),"\n",(0,a.jsx)(n.p,{children:"These built-ins are also available in the global scope using these names:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"pcPosition\npcFrontFacing\npcSampleIndex\n"})}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"varying texCoord: vec2f;\n\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n    var output: FragmentOutput;\n    output.color = vec4f(1.0);\n    return output;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"fragment-shader-outputs",children:"Fragment Shader Outputs"}),"\n",(0,a.jsx)(n.p,{children:"The fragment shader is responsible for producing one or more color outputs, which are written to the render targets (color attachments) of the framebuffer."}),"\n",(0,a.jsxs)(n.p,{children:["The engine automatically provides a ",(0,a.jsx)(n.code,{children:"FragmentOutput"})," structure, which includes a predefined set of vec4f fields: ",(0,a.jsx)(n.code,{children:"color"}),", ",(0,a.jsx)(n.code,{children:"color1"}),", ",(0,a.jsx)(n.code,{children:"color2"})," and so on, covering all possible color attachments, up to the limit defined by ",(0,a.jsx)(n.code,{children:"GraphicsDevice.maxColorAttachments"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["As part of the ",(0,a.jsx)(n.code,{children:"FragmentOutput"})," structure these built-in variables are automatically available:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"fragDepth: @builtin(frag_depth)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"@fragment fn fragmentMain(input: FragmentInput) -> FragmentOutput {\n    var output: FragmentOutput;\n    output.color = vec4f(1.0);\n    output.color1 = vec4f(0.5);\n    output.fragDepth = 0.2;\n    return output;\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["Support for rendering to integer textures (output format other than ",(0,a.jsx)(n.code,{children:"vec4f"}),") is not available yet, and will be added in the future."]})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);