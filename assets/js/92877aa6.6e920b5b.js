"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[3788],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var a=t(96540);const o={},i=a.createContext(o);function s(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(i.Provider,{value:n},e.children)}},75166:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"user-manual/gaussian-splatting/building/draw-order","title":"Draw Order and Sorting","description":"How Gaussians Are Sorted","source":"@site/docs/user-manual/gaussian-splatting/building/draw-order.md","sourceDirName":"user-manual/gaussian-splatting/building","slug":"/user-manual/gaussian-splatting/building/draw-order","permalink":"/user-manual/gaussian-splatting/building/draw-order","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/gaussian-splatting/building/draw-order.md","tags":[],"version":"current","frontMatter":{"title":"Draw Order and Sorting"},"sidebar":"userManualSidebar","previous":{"title":"Using Web Components","permalink":"/user-manual/gaussian-splatting/building/your-first-app/web-components"},"next":{"title":"Global Sorting","permalink":"/user-manual/gaussian-splatting/building/global-sorting"}}');var o=t(74848),i=t(28453);const s={title:"Draw Order and Sorting"},r=void 0,l={},d=[{value:"How Gaussians Are Sorted",id:"how-gaussians-are-sorted",level:2},{value:"Multiple GSplatComponents",id:"multiple-gsplatcomponents",level:2},{value:"Depth Buffer Considerations",id:"depth-buffer-considerations",level:2}];function u(e){const n={a:"a",admonition:"admonition",h2:"h2",p:"p",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"how-gaussians-are-sorted",children:"How Gaussians Are Sorted"}),"\n",(0,o.jsx)(n.p,{children:"Individual Gaussians within a GSplatComponent are sorted back to front based on camera depth. This sorting happens asynchronously in a Web Worker to avoid blocking the main thread. The calculated sort order is then passed back to the main thread and uploaded to the GPU for rendering."}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsx)(n.p,{children:"Because the sorting occurs asynchronously, you may notice some visual lag if the camera transform changes significantly over a very short time period, as the Web Worker needs time to recalculate the new sort order."})}),"\n",(0,o.jsx)(n.h2,{id:"multiple-gsplatcomponents",children:"Multiple GSplatComponents"}),"\n",(0,o.jsx)(n.p,{children:"GSplatComponents are rendered back to front based on their bounding boxes, and each component's Gaussians are sorted independently within that component."}),"\n",(0,o.jsx)(n.admonition,{title:"Global sorting",type:"info",children:(0,o.jsxs)(n.p,{children:['By default, the PlayCanvas Engine does not support "global sorting" across multiple GSplatComponents (where all Gaussians from all components would be sorted together). However, you can enable ',(0,o.jsx)(n.a,{href:"/user-manual/gaussian-splatting/building/global-sorting",children:"Global Sorting"}),", a beta feature that allows all Gaussians from multiple components to be sorted together, eliminating visibility and popping artifacts."]})}),"\n",(0,o.jsx)(n.h2,{id:"depth-buffer-considerations",children:"Depth Buffer Considerations"}),"\n",(0,o.jsx)(n.p,{children:"GSplatComponents do not write to the depth buffer during rendering. This limitation means you cannot use functionality that relies on reading back or leveraging depth buffer data in your application. For example, a Depth of Field post effect, which typically requires the depth buffer, would not generally be compatible with splat rendering."}),"\n",(0,o.jsx)(n.p,{children:"As a workaround, you can generate a mesh-based approximation of your splat and render it to the depth buffer in a separate layer (without writing to the framebuffer). This technique allows depth-dependent effects while maintaining the visual quality of the Gaussian splat rendering."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);