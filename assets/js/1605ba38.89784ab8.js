"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[68917],{7124:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/kinematic-box-eb7d67e6a3c618cc8655e0af9748d6d6.gif"},11470:(e,t,i)=>{i.d(t,{A:()=>k});var n=i(96540),s=i(34164),a=i(17559),o=i(23104),r=i(56347),l=i(205),c=i(57485),d=i(31682),u=i(70679);function h(e){return n.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:t,children:i}=e;return(0,n.useMemo)(()=>{const e=t??function(e){return h(e).map(({props:{value:e,label:t,attributes:i,default:n}})=>({value:e,label:t,attributes:i,default:n}))}(i);return function(e){const t=(0,d.XI)(e,(e,t)=>e.value===t.value);if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[t,i])}function m({value:e,tabValues:t}){return t.some(t=>t.value===e)}function y({queryString:e=!1,groupId:t}){const i=(0,r.W6)(),s=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,c.aZ)(s),(0,n.useCallback)(e=>{if(!s)return;const t=new URLSearchParams(i.location.search);t.set(s,e),i.replace({...i.location,search:t.toString()})},[s,i])]}function b(e){const{defaultValue:t,queryString:i=!1,groupId:s}=e,a=p(e),[o,r]=(0,n.useState)(()=>function({defaultValue:e,tabValues:t}){if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const i=t.find(e=>e.default)??t[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:t,tabValues:a})),[c,d]=y({queryString:i,groupId:s}),[h,b]=function({groupId:e}){const t=function(e){return e?`docusaurus.tab.${e}`:null}(e),[i,s]=(0,u.Dv)(t);return[i,(0,n.useCallback)(e=>{t&&s.set(e)},[t,s])]}({groupId:s}),f=(()=>{const e=c??h;return m({value:e,tabValues:a})?e:null})();(0,l.A)(()=>{f&&r(f)},[f]);return{selectedValue:o,selectValue:(0,n.useCallback)(e=>{if(!m({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);r(e),d(e),b(e)},[d,b,a]),tabValues:a}}var f=i(92303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=i(74848);function x({className:e,block:t,selectedValue:i,selectValue:n,tabValues:a}){const r=[],{blockElementScrollPositionUntilNextRender:l}=(0,o.a_)(),c=e=>{const t=e.currentTarget,s=r.indexOf(t),o=a[s].value;o!==i&&(l(t),n(o))},d=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const i=r.indexOf(e.currentTarget)+1;t=r[i]??r[0];break}case"ArrowLeft":{const i=r.indexOf(e.currentTarget)-1;t=r[i]??r[r.length-1];break}}t?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},e),children:a.map(({value:e,label:t,attributes:n})=>(0,v.jsx)("li",{role:"tab",tabIndex:i===e?0:-1,"aria-selected":i===e,ref:e=>{r.push(e)},onKeyDown:d,onClick:c,...n,className:(0,s.A)("tabs__item",g.tabItem,n?.className,{"tabs__item--active":i===e}),children:t??e},e))})}function j({lazy:e,children:t,selectedValue:i}){const a=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){const e=a.find(e=>e.props.value===i);return e?(0,n.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:a.map((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==i}))})}function w(e){const t=b(e);return(0,v.jsxs)("div",{className:(0,s.A)(a.G.tabs.container,"tabs-container",g.tabList),children:[(0,v.jsx)(x,{...t,...e}),(0,v.jsx)(j,{...t,...e})]})}function k(e){const t=(0,f.A)();return(0,v.jsx)(w,{...e,children:h(e.children)},String(t))}},19365:(e,t,i)=>{i.d(t,{A:()=>o});i(96540);var n=i(34164);const s={tabItem:"tabItem_Ymn6"};var a=i(74848);function o({children:e,hidden:t,className:i}){return(0,a.jsx)("div",{role:"tabpanel",className:(0,n.A)(s.tabItem,i),hidden:t,children:e})}},28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var n=i(96540);const s={},a=n.createContext(s);function o(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(a.Provider,{value:t},e.children)}},57238:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/falling-box-bba02e73b92882b76fd0c781174738e9.gif"},64590:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/static-ground-99b663666fc27f7fab1bc038d81e4f2f.png"},71417:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>n,toc:()=>u});const n=JSON.parse('{"id":"user-manual/physics/physics-basics","title":"Physics Basics","description":"PlayCanvas incorporates a very powerful physics engine called ammo.js. This is a browser port of the open source C++ Bullet physics engine.","source":"@site/docs/user-manual/physics/physics-basics.md","sourceDirName":"user-manual/physics","slug":"/user-manual/physics/physics-basics","permalink":"/user-manual/physics/physics-basics","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/physics/physics-basics.md","tags":[],"version":"current","frontMatter":{"title":"Physics Basics"},"sidebar":"userManualSidebar","previous":{"title":"Physics","permalink":"/user-manual/physics/"},"next":{"title":"Forces and Impulses","permalink":"/user-manual/physics/forces-and-impulses"}}');var s=i(74848),a=i(28453),o=i(11470),r=i(19365);const l={title:"Physics Basics"},c=void 0,d={},u=[{value:"Enabling Physics",id:"enabling-physics",level:2},{value:"Gravity",id:"gravity",level:2},{value:"Units of Measurement",id:"units-of-measurement",level:2},{value:"Rigid Bodies",id:"rigid-bodies",level:2},{value:"Creating a Static Ground",id:"creating-a-static-ground",level:2},{value:"Creating Dynamic Bodies",id:"creating-dynamic-bodies",level:2},{value:"Creating Kinematic Bodies",id:"creating-kinematic-bodies",level:2},{value:"Teleporting Dynamic Bodies",id:"teleporting-dynamic-bodies",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["PlayCanvas incorporates a very powerful physics engine called ",(0,s.jsx)(t.a,{href:"https://github.com/kripken/ammo.js",children:"ammo.js"}),". This is a browser port of the open source C++ Bullet physics engine."]}),"\n",(0,s.jsxs)(t.p,{children:["PlayCanvas provides the ",(0,s.jsx)(t.a,{href:"/user-manual/editor/scenes/components/rigidbody/",children:"rigidbody"})," and ",(0,s.jsx)(t.a,{href:"/user-manual/editor/scenes/components/collision/",children:"collision"})," components to set up physics simulations."]}),"\n",(0,s.jsx)(t.h2,{id:"enabling-physics",children:"Enabling Physics"}),"\n",(0,s.jsx)(t.p,{children:"By default, a new PlayCanvas project does not include ammo.js modules. This is because ammo.js weighs in at several hundred kilobytes and your app should not have to load this library if it is not needed."}),"\n",(0,s.jsx)(t.p,{children:"You can import ammo.js modules into your project using the import button on the Scene Settings panel:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Physics Settings",src:i(80189).A+"",width:"632",height:"234"})}),"\n",(0,s.jsxs)(t.p,{children:["This will import the default build of ammo.js provided by PlayCanvas. However please note it is possible to compile your own version of ammo.js and add it to your project instead. For more information see ",(0,s.jsx)(t.a,{href:"/user-manual/assets/types/wasm/",children:"this page"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["For details on migrating legacy projects to the latest ammo.js see ",(0,s.jsx)(t.a,{href:"/user-manual/physics/physics-migration/",children:"this page"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"gravity",children:"Gravity"}),"\n",(0,s.jsx)(t.p,{children:"In the same Settings panel, you can set global gravity of the physics simulation. Gravity is a constant force applied to all rigid bodies in your scene. By default, this is set to -9.81 in the world's negative Y axis (straight down, in other words). This default approximates Earth gravity. But you may want to increase or decrease this value. For example, for a game set in space, you will probably want to set gravity to zero."}),"\n",(0,s.jsx)(t.h2,{id:"units-of-measurement",children:"Units of Measurement"}),"\n",(0,s.jsx)(t.p,{children:"By default, the PlayCanvas physics engine interprets 1 unit as 1 meter. Therefore, for objects to fall at a rate that appears to be physically accurate, you should ensure that your scenes size objects appropriately."}),"\n",(0,s.jsx)(t.p,{children:"For example, if your game features a character that is 1.8m tall, he should be 1.8 units high in the Editor's 3D view."}),"\n",(0,s.jsx)(t.h2,{id:"rigid-bodies",children:"Rigid Bodies"}),"\n",(0,s.jsx)(t.p,{children:"You can make any entity in your scene participate in the physics simulation. Just add a rigidbody component and a collision component. The rigidbody component specifies a type:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Static - A physical object that never moves"}),"\n",(0,s.jsx)(t.li,{children:"Dynamic - A physical object that will move in response to an applied force"}),"\n",(0,s.jsx)(t.li,{children:"Kinematic - A physical object that can only be positioned explicitly via the API"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"It also specifies physical properties like mass, friction and restitution (essentially a measure of 'bounciness')."}),"\n",(0,s.jsx)(t.p,{children:"The collision component specifies the physical shape of the body. Note that a rigid body's physical shape does not have to match its graphical shape. It is typical for physical representations of objects to be much simpler than the graphical. The available collision component types are:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Box"}),"\n",(0,s.jsx)(t.li,{children:"Sphere"}),"\n",(0,s.jsx)(t.li,{children:"Capsule"}),"\n",(0,s.jsx)(t.li,{children:"Cylinder"}),"\n",(0,s.jsx)(t.li,{children:"Mesh"}),"\n",(0,s.jsx)(t.li,{children:"Cone"}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/user-manual/physics/compound-shapes/",children:"Compound"})}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"creating-a-static-ground",children:"Creating a Static Ground"}),"\n",(0,s.jsx)(t.p,{children:"Most of the time, you will want to create some kind of static physical environment. For example, a race track or a football pitch. The simplest example is a flat plane. PlayCanvas doesn't expose a plane-type collision primitive but it does provide a box primitive. Here is how to configure a 1 unit high 10x10 box that is a static rigid body:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Static Ground",src:i(64590).A+"",width:"2657",height:"1470"})}),"\n",(0,s.jsx)(t.p,{children:"You could also set the collision component type to Mesh and assign a model asset if you want something more complex."}),"\n",(0,s.jsx)(t.h2,{id:"creating-dynamic-bodies",children:"Creating Dynamic Bodies"}),"\n",(0,s.jsx)(t.p,{children:"Physics is all about movement so things get interesting when we create dynamic rigid bodies. Let's create a dynamic 1x1x1 box:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Dynamic Box",src:i(79251).A+"",width:"2657",height:"1470"})}),"\n",(0,s.jsx)(t.p,{children:"The box has been rotated so that when it collides with the static ground, it will bounce in an interesting way:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Falling Box",src:i(57238).A+"",width:"1024",height:"768"})}),"\n",(0,s.jsx)(t.h2,{id:"creating-kinematic-bodies",children:"Creating Kinematic Bodies"}),"\n",(0,s.jsx)(t.p,{children:"Sometimes, it can be useful to be able to explicitly control the motion of physical objects in your scene and have these objects exert an irresistible force on other physical objects. For example, imagine a moving platform that can carry the player across a level. To achieve this, you can set a rigid body's type to Kinematic. Let's create a kinematic box:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Kinematic Box",src:i(98519).A+"",width:"2657",height:"1470"})}),"\n",(0,s.jsx)(t.p,{children:"The responsibility for animating kinematic bodies is on you, the developer. You will notice that the kinematic box shown above also has a script component with a script called movement.js assigned:"}),"\n","\n",(0,s.jsxs)(o.A,{defaultValue:"classic",groupId:"script-code",children:[(0,s.jsx)(r.A,{value:"esm",label:"ESM",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"import { Script } from 'playcanvas';\n\nexport class Movement extends Script {\n    static scriptName = \"movement\";\n\n    initialize() {\n\n    }\n\n    update(dt) {\n        this.entity.setPosition(Math.sin(Date.now() / 1000), 0.5, 0);\n    }\n}\n"})})}),(0,s.jsx)(r.A,{value:"classic",label:"Classic",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"var Movement = pc.createScript('movement');\n\n// initialize code called once per entity\nMovement.prototype.initialize = function() {\n\n};\n\n// update code called every frame\nMovement.prototype.update = function(dt) {\n    this.entity.setPosition(Math.sin(Date.now() / 1000), 0.5, 0);\n};\n"})})})]}),"\n",(0,s.jsxs)(t.p,{children:["This script simply animates the box along the world x-axis using a sine function. You move kinematic bodies using the standard transformation functions on the entity like ",(0,s.jsx)(t.code,{children:"setPosition"}),", ",(0,s.jsx)(t.code,{children:"setRotation"})," and ",(0,s.jsx)(t.code,{children:"setEulerAngles"}),". Now when we run the scene, the dynamic box falls on the kinematic box and is carried along on top of it:"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Kinematic Box",src:i(7124).A+"",width:"1024",height:"768"})}),"\n",(0,s.jsx)(t.h2,{id:"teleporting-dynamic-bodies",children:"Teleporting Dynamic Bodies"}),"\n",(0,s.jsx)(t.p,{children:"Although you can use the standard entity transformation function with kinematic bodies, this is not allowed for dynamic bodies. When creating a dynamic rigid body, you pass the responsibility for setting the position and orientation of that entity to the physics engine. This means that if you try to update the position or orientation of an entity in a script using the pc.Entity API, the functions will not have an effect. Instead, you must call the teleport function on the rigid body component which explicitly notifies the physics engine you want to momentarily update a rigid body's position and/or orientation."})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},79251:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/dynamic-box-b7d07cf86063a73876d6e99893f403cb.png"},80189:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/physics-settings-a5c7a9a251c36536c6201285e4061890.png"},98519:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/kinematic-box-3b34f7f32c06fca8f92e9716f557fa85.png"}}]);