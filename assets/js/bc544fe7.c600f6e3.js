"use strict";(self.webpackChunkdeveloper_playcanvas_com=self.webpackChunkdeveloper_playcanvas_com||[]).push([[7099],{28453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>t});var r=a(96540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},45487:(e,n,a)=>{a.d(n,{A:()=>r});const r=a.p+"assets/images/shader-log-053ecb9a80520f6fc5ac7e26afd4d485.png"},79622:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"user-manual/graphics/shaders/index","title":"Shaders","description":"When you import your 3D models into PlayCanvas, by default, they will use our Physical Material. This is a versatile material type that can cover a lot of your rendering needs.","source":"@site/docs/user-manual/graphics/shaders/index.md","sourceDirName":"user-manual/graphics/shaders","slug":"/user-manual/graphics/shaders/","permalink":"/user-manual/graphics/shaders/","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/graphics/shaders/index.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Shaders","sidebar_position":6},"sidebar":"userManualSidebar","previous":{"title":"Shader Chunk Migrations","permalink":"/user-manual/graphics/shader-chunk-migrations"},"next":{"title":"GLSL Specifics","permalink":"/user-manual/graphics/shaders/glsl-specifics"}}');var s=a(74848),i=a(28453);const o={title:"Shaders",sidebar_position:6},t=void 0,d={},l=[{value:"Preprocessor",id:"preprocessor",level:2},{value:"Material Shader Defines",id:"material-shader-defines",level:3},{value:"RenderPass Defines",id:"renderpass-defines",level:3},{value:"Shader Includes",id:"shader-includes",level:3},{value:"Vertex Shader",id:"vertex-shader",level:4},{value:"Fragment Shader",id:"fragment-shader",level:4},{value:"Generated Shaders",id:"generated-shaders",level:4}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["When you import your 3D models into PlayCanvas, by default, they will use our ",(0,s.jsx)(n.a,{href:"/user-manual/graphics/physical-rendering/physical-materials/",children:"Physical Material"}),". This is a versatile material type that can cover a lot of your rendering needs."]}),"\n",(0,s.jsxs)(n.p,{children:["However, you will often want to perform special effects or special cases for your materials. To do this you will need to write a custom shader. In this case, you need to use ",(0,s.jsx)(n.code,{children:"ShaderMaterial"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To create an instance of ",(0,s.jsx)(n.code,{children:"ShaderMaterial"}),", these are the steps:"]}),"\n",(0,s.jsx)(n.p,{children:"Create a description of your shader:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const shaderDesc = {\n        uniqueName: 'MyShader',\n        shaderLanguage: pc.SHADERLANGUAGE_GLSL,\n        vertexCode: `\n            // write your vertex shader source code\n        `,\n        fragmentCode: `\n            // write your fragment shader source code\n        `,\n        attributes: {\n            aPosition: pc.SEMANTIC_POSITION,\n            aUv0: pc.SEMANTIC_TEXCOORD0\n        }\n    };\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"Then create instances of your material, which you can use for rendering:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const material = new pc.ShaderMaterial(shaderDesc);\n"})}),"\n",(0,s.jsx)(n.p,{children:"The shader source code can be written in GLSL if you're targeting the WebGL2 or WebGPU platforms, or in WGSL if you're targeting WebGPU only."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"If you write a GLSL shader, it is directly supported by the WebGL2 platform. However, on the WebGPU platform, GLSL shaders require transpilation to WGSL using a WASM transpiler. To avoid this transpilation step and achieve native performance related to shader compilation, and avoid additional download of WASM files, you might want to consider writing an equivalent shader in WGSL for the WebGPU platform, which is supported directly."})}),"\n",(0,s.jsx)(n.h2,{id:"preprocessor",children:"Preprocessor"}),"\n",(0,s.jsx)(n.p,{children:"Before the shader is used, a preprocessing step is applied, allowing you to manage shader variations effectively."}),"\n",(0,s.jsxs)(n.p,{children:["This preprocessing step follows a typical C-like preprocessor structure, handling directives such as ",(0,s.jsx)(n.code,{children:"#define"}),", ",(0,s.jsx)(n.code,{children:"#if"}),", ",(0,s.jsx)(n.code,{children:"#else"}),", ",(0,s.jsx)(n.code,{children:"#endif"}),", and similar. This gives you fine-grained control over how the shader code is compiled and customized for different use cases."]}),"\n",(0,s.jsx)(n.h3,{id:"material-shader-defines",children:"Material Shader Defines"}),"\n",(0,s.jsx)(n.p,{children:"Shader defines can be set on a per-material basis, allowing dynamic customization of shader behavior. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"material.setDefine('USE_TEXTURE', true);\nmaterial.setDefine('FIRETYPE', 'RED');\n"})}),"\n",(0,s.jsx)(n.p,{children:"This results in the following lines being added to the shader source:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-glsl",children:"#define USE_TEXTURE\n#define FIRETYPE RED\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can then use these defines within the shader for conditional logic:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-glsl",children:"#if defined(USE_TEXTURE)\n// Apply texture-based rendering\n#endif\n\n#if FIRETYPE == RED\n// Apply red fire effect\n#endif\n"})}),"\n",(0,s.jsx)(n.p,{children:"This system enables flexible shader variation without requiring multiple shader files, making it easier to customize rendering for different materials."}),"\n",(0,s.jsx)(n.h3,{id:"renderpass-defines",children:"RenderPass Defines"}),"\n",(0,s.jsx)(n.p,{children:"The engine provides some defines automatically, allowing integration with render passes. By default, one of these three defines is provided to allow you to write code specific to different render passes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-glsl",children:"// Defined for normal forward passes rendering colors\n#define FORWARD_PASS\n\n// Defined for shadow rendering passes\n// Shader output specifics may depend on the shadow type used\n#define SHADOW_PASS\n\n// Defined for the render pass used by the `Picker` class to render mesh instance IDs\n#define SHADOW_PICK \n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you use a custom render pass, created using ",(0,s.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/CameraComponent.html#setshaderpass",children:(0,s.jsx)(n.code,{children:"CameraComponent.setShaderPass"})}),", a matching define is automatically generated. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"camera.setRenderPass('custom');\n"})}),"\n",(0,s.jsx)(n.p,{children:"This results in the following define being added to the shader:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-glsl",children:"#define CUSTOM_PASS\n"})}),"\n",(0,s.jsx)(n.h3,{id:"shader-includes",children:"Shader Includes"}),"\n",(0,s.jsxs)(n.p,{children:["The engine builds internal shaders out of chunks; small shader functions that are combined to form a final shader. These chunks are also available for use in custom shaders with ",(0,s.jsx)(n.code,{children:"ShaderMaterial"}),", making it easy to integrate engine functionality."]}),"\n",(0,s.jsx)(n.h4,{id:"vertex-shader",children:"Vertex Shader"}),"\n",(0,s.jsx)(n.p,{children:"The engine provides predefined shader includes that handle common transformations, normal calculations, and other essential operations. This allows your custom shader to automatically support skinning, morphing and instancing."}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-glsl",children:'// Includes transformation-related functionality provided by the engine.\n// - Automatically declares the `vertex_position` attribute.\n// - Handles skinning and morphing if necessary.\n// - Adds the following uniforms:\n//   - `matrix_viewProjection`\n//   - `matrix_model`\n//   - `matrix_normal`\n// - Provides utility functions:\n//   - `getModelMatrix()`\n//   - `getLocalPosition()`\n#include "transformCoreVS"\n\n// Includes normal-related functionality provided by the engine.\n// - Automatically declares the `vertex_normal` attribute.\n// - Handles skinning and morphing if necessary.\n// - Provides utility functions:\n//   - `getNormalMatrix()`\n//   - `getLocalNormal()`\n#include "normalCoreVS"\n\nvoid main(void)\n{\n    // Retrieve the model matrix, accounting for skinning, morphing, or instancing.\n    mat4 modelMatrix = getModelMatrix();\n    vec3 localPos = getLocalPosition(vertex_position.xyz);\n    vec4 worldPos = modelMatrix * vec4(localPos, 1.0);\n\n    // Retrieve the normal matrix and compute the world normal.\n    mat3 normalMatrix = getNormalMatrix(modelMatrix);\n    vec3 localNormal = getLocalNormal(vertex_normal);\n    vec3 worldNormal = normalize(normalMatrix * localNormal);\n\n    // Example: Apply simple wrap-around diffuse lighting using the world normal.\n    brightness = (dot(worldNormal, uLightDir) + 1.0) * 0.5;\n\n    // Transform the geometry.\n    gl_Position = matrix_viewProjection * worldPos;\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"fragment-shader",children:"Fragment Shader"}),"\n",(0,s.jsx)(n.p,{children:"The engine provides predefined shader chunks you can include for common color processing effects such as gamma correction, tone mapping and fog. These includes ensure that colors are processed correctly according to the rendering settings."}),"\n",(0,s.jsx)(n.p,{children:"Example Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-glsl",children:'#include "gammaPS"       // Adds support for gamma correction of inputs and outputs\n#include "tonemappingPS" // Adds support for tone mapping\n#include "fogPS"         // Adds support for fog effects\n\nvoid main(void)\n{\n    // Evaluate color in linear color space\n    vec3 colorLinear = ...;\n\n    // Apply fog if enabled\n    vec3 fogged = addFog(colorLinear);\n\n    // Apply tone mapping if enabled\n    vec3 toneMapped = toneMap(fogged);\n\n    // Apply gamma correction and output the final color\n    gl_FragColor.rgb = gammaCorrectOutput(toneMapped);\n    gl_FragColor.a = alpha;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"These functions are automatically configured based on the engine's settings, ensuring that color processing is consistent across different rendering conditions."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"For more complete examples, and also for details on how to implement instancing, refer to the engine examples."})}),"\n",(0,s.jsx)(n.h4,{id:"generated-shaders",children:"Generated Shaders"}),"\n",(0,s.jsx)(n.p,{children:"If you have a need to inspect the generated shaders, you can add this to your script"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"pc.Tracing.set(pc.TRACEID_SHADER_ALLOC, true);\n"})}),"\n",(0,s.jsx)(n.p,{children:"And Each created shader will be logged in the browser console, where you can inspect its source code, for example:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"sRGB",src:a(45487).A+"",width:"1125",height:"353"})}),"\n",(0,s.jsxs)(n.p,{children:["For further information, refer to the ",(0,s.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/ShaderMaterial.html",children:"ShaderMaterial API documentation"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);