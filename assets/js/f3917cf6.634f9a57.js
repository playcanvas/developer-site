"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[2438],{28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>r});var a=s(96540);const i={},t=a.createContext(i);function l(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),a.createElement(t.Provider,{value:n},e.children)}},68990:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"user-manual/gaussian-splatting/building/engine-features/custom-shaders","title":"Custom Shaders","description":"The PlayCanvas Engine supports custom shaders for Gaussian Splats, allowing you to create advanced visual effects and customize the rendering behavior beyond the standard implementation.","source":"@site/docs/user-manual/gaussian-splatting/building/engine-features/custom-shaders.md","sourceDirName":"user-manual/gaussian-splatting/building/engine-features","slug":"/user-manual/gaussian-splatting/building/engine-features/custom-shaders","permalink":"/user-manual/gaussian-splatting/building/engine-features/custom-shaders","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/gaussian-splatting/building/engine-features/custom-shaders.md","tags":[],"version":"current","frontMatter":{"title":"Custom Shaders"},"sidebar":"userManualSidebar","previous":{"title":"Shadows","permalink":"/user-manual/gaussian-splatting/building/engine-features/shadows"},"next":{"title":"Performance","permalink":"/user-manual/gaussian-splatting/building/engine-features/performance"}}');var i=s(74848),t=s(28453);const l={title:"Custom Shaders"},r=void 0,o={},c=[{value:"Introduction",id:"introduction",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"modifyCenter",id:"modifycenter",level:3},{value:"modifyCovariance",id:"modifycovariance",level:3},{value:"modifyColor",id:"modifycolor",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Setup",id:"basic-setup",level:3},{value:"GLSL Example: Position and Color Animation",id:"glsl-example-position-and-color-animation",level:3},{value:"WGSL Example: Position and Color Animation",id:"wgsl-example-position-and-color-animation",level:3},{value:"Removing Custom Shaders",id:"removing-custom-shaders",level:3},{value:"Helper Functions",id:"helper-functions",level:2},{value:"gsplatApplyUniformScale",id:"gsplatapplyuniformscale",level:3},{value:"gsplatExtractSize",id:"gsplatextractsize",level:3},{value:"gsplatMakeRound",id:"gsplatmakeround",level:3},{value:"Examples",id:"examples",level:2},{value:"Animation Effects",id:"animation-effects",level:3},{value:"Transition Effects",id:"transition-effects",level:3},{value:"Lighting and Relighting",id:"lighting-and-relighting",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"The PlayCanvas Engine supports custom shaders for Gaussian Splats, allowing you to create advanced visual effects and customize the rendering behavior beyond the standard implementation."}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"There are two ways to customize Gaussian Splat rendering with shaders:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Shader Chunk Customization (Recommended)"})," - Override the ",(0,i.jsx)(n.code,{children:"gsplatCustomizeVS"})," shader chunk to customize splat position, size, and color. This allows you to override only the relevant parts of the shader while leaving the core shader functionality intact."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Full Shader Replacement"})," - Replace the entire vertex and fragment shaders for complete control. This provides maximum flexibility but requires understanding the full shader implementation."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Most use cases can be accomplished with shader chunk customization, which is covered in detail below."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://playcanvas.vercel.app/#/gaussian-splatting/multi-splat",children:"View Live Example"})})," - See shader chunk customization in action with animated splats."]}),"\n",(0,i.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"gsplatCustomizeVS"})," shader chunk allows you to override three functions that customize how splats are rendered:"]}),"\n",(0,i.jsx)(n.h3,{id:"modifycenter",children:"modifyCenter"}),"\n",(0,i.jsx)(n.p,{children:"Transform the position of splat centers in model space."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"GLSL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"void modifyCenter(inout vec3 center)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"WGSL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-wgsl",children:"fn modifyCenter(center: ptr<function, vec3f>)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"center"})," - The splat center position in model space"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"// Offset all splats up by 1 unit\nvoid modifyCenter(inout vec3 center) {\n    center.y += 1.0;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"modifycovariance",children:"modifyCovariance"}),"\n",(0,i.jsx)(n.p,{children:"Modify the splat size and shape by adjusting covariance values."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"GLSL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"void modifyCovariance(vec3 originalCenter, vec3 modifiedCenter, inout vec3 covA, inout vec3 covB)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"WGSL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-wgsl",children:"fn modifyCovariance(originalCenter: vec3f, modifiedCenter: vec3f, covA: ptr<function, vec3f>, covB: ptr<function, vec3f>)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"originalCenter"})," - The original splat center position before modification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"modifiedCenter"})," - The splat center position after ",(0,i.jsx)(n.code,{children:"modifyCenter()"})," was applied"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"covA"}),", ",(0,i.jsx)(n.code,{children:"covB"})," - Covariance values that define splat size and orientation"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"// Scale all splats by 2x\nvoid modifyCovariance(vec3 originalCenter, vec3 modifiedCenter, inout vec3 covA, inout vec3 covB) {\n    gsplatApplyUniformScale(covA, covB, 2.0);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"modifycolor",children:"modifyColor"}),"\n",(0,i.jsx)(n.p,{children:"Transform splat colors and opacity."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"GLSL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"void modifyColor(vec3 center, inout vec4 color)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"WGSL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-wgsl",children:"fn modifyColor(center: vec3f, color: ptr<function, vec4f>)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"center"})," - The splat center position (after ",(0,i.jsx)(n.code,{children:"modifyCenter()"})," was applied)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"color"})," - The splat color (RGBA)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"// Darken all splats by 50%\nvoid modifyColor(vec3 center, inout vec4 color) {\n    color.rgb *= 0.5;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(n.h3,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,i.jsx)(n.p,{children:"To apply a custom shader chunk to a Gaussian Splat material:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Get the shader language for the current device\nconst shaderLanguage = device.isWebGPU ? 'wgsl' : 'glsl';\n\n// Define your custom shader code\nconst customShader = `\n    // Your shader functions here\n`;\n\n// Set the custom shader chunk override on the gsplat material\ngsplatMaterial.getShaderChunks(shaderLanguage).set('gsplatCustomizeVS', customShader);\n\n// Update the material to recompile with the new shader\ngsplatMaterial.update();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"glsl-example-position-and-color-animation",children:"GLSL Example: Position and Color Animation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const customShader = `\nuniform float uTime;\n\nvoid modifyCenter(inout vec3 center) {\n    // Create a wave effect based on height\n    float heightIntensity = center.y * 0.2;\n    center.x += sin(uTime * 5.0 + center.y) * 0.3 * heightIntensity;\n}\n\nvoid modifyCovariance(vec3 originalCenter, vec3 modifiedCenter, inout vec3 covA, inout vec3 covB) {\n    // No modification to size\n}\n\nvoid modifyColor(vec3 center, inout vec4 color) {\n    // Add a golden tint to the wave peaks\n    float sineValue = abs(sin(uTime * 5.0 + center.y));\n    vec3 gold = vec3(1.0, 0.85, 0.0);\n    float blend = smoothstep(0.9, 1.0, sineValue);\n    color.rgb = mix(color.rgb, gold, blend);\n}\n`;\n\n// Set the custom shader chunk override on the gsplat material\nconst shaderLanguage = app.graphicsDevice.isWebGPU ? 'wgsl' : 'glsl';\ngsplatMaterial.getShaderChunks(shaderLanguage).set('gsplatCustomizeVS', customShader);\ngsplatMaterial.update();\n\n// Update the uniform each frame\nconst uTime = app.graphicsDevice.scope.resolve('uTime');\nlet time = 0;\napp.on('update', (dt) => {\n    time += dt;\n    uTime.setValue(time);\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"wgsl-example-position-and-color-animation",children:"WGSL Example: Position and Color Animation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const customShader = `\nuniform uTime: f32;\n\nfn modifyCenter(center: ptr<function, vec3f>) {\n    // Create a wave effect based on height\n    let heightIntensity = (*center).y * 0.2;\n    (*center).x += sin(uniform.uTime * 5.0 + (*center).y) * 0.3 * heightIntensity;\n}\n\nfn modifyCovariance(originalCenter: vec3f, modifiedCenter: vec3f, covA: ptr<function, vec3f>, covB: ptr<function, vec3f>) {\n    // No modification to size\n}\n\nfn modifyColor(center: vec3f, color: ptr<function, vec4f>) {\n    // Add a golden tint to the wave peaks\n    let sineValue = abs(sin(uniform.uTime * 5.0 + center.y));\n    let gold = vec3f(1.0, 0.85, 0.0);\n    let blend = smoothstep(0.9, 1.0, sineValue);\n    (*color) = vec4f(mix((*color).rgb, gold, blend), (*color).a);\n}\n`;\n\n// Set the custom shader chunk override on the gsplat material\nconst shaderLanguage = app.graphicsDevice.isWebGPU ? 'wgsl' : 'glsl';\ngsplatMaterial.getShaderChunks(shaderLanguage).set('gsplatCustomizeVS', customShader);\ngsplatMaterial.update();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"removing-custom-shaders",children:"Removing Custom Shaders"}),"\n",(0,i.jsx)(n.p,{children:"To remove a custom shader and revert to default rendering:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Remove the custom shader chunk override from the gsplat material\nconst shaderLanguage = app.graphicsDevice.isWebGPU ? 'wgsl' : 'glsl';\ngsplatMaterial.getShaderChunks(shaderLanguage).delete('gsplatCustomizeVS');\ngsplatMaterial.update();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"helper-functions",children:"Helper Functions"}),"\n",(0,i.jsxs)(n.p,{children:["The following helper functions are available in ",(0,i.jsx)(n.code,{children:"modifyCovariance()"})," for manipulating splat size and shape:"]}),"\n",(0,i.jsx)(n.h3,{id:"gsplatapplyuniformscale",children:"gsplatApplyUniformScale"}),"\n",(0,i.jsx)(n.p,{children:"Scale splats uniformly by a factor."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"GLSL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"void gsplatApplyUniformScale(inout vec3 covA, inout vec3 covB, float scale)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"WGSL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-wgsl",children:"fn gsplatApplyUniformScale(covA: ptr<function, vec3f>, covB: ptr<function, vec3f>, scale: f32)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"// Double the size of all splats\ngsplatApplyUniformScale(covA, covB, 2.0);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"gsplatextractsize",children:"gsplatExtractSize"}),"\n",(0,i.jsx)(n.p,{children:"Extract the current size of a splat."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"GLSL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"float gsplatExtractSize(vec3 covA, vec3 covB)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"WGSL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-wgsl",children:"fn gsplatExtractSize(covA: vec3f, covB: vec3f) -> f32\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"// Clamp splat size to a specific range\nfloat size = gsplatExtractSize(covA, covB);\nfloat newSize = clamp(size, 0.01, 0.5);\ngsplatApplyUniformScale(covA, covB, newSize / size);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"gsplatmakeround",children:"gsplatMakeRound"}),"\n",(0,i.jsx)(n.p,{children:"Make splats round/spherical with a specific radius."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"GLSL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"void gsplatMakeRound(inout vec3 covA, inout vec3 covB, float radius)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"WGSL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-wgsl",children:"fn gsplatMakeRound(covA: ptr<function, vec3f>, covB: ptr<function, vec3f>, radius: f32)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"// Make all splats perfectly round with uniform size\nfloat size = gsplatExtractSize(covA, covB);\ngsplatMakeRound(covA, covB, size * 0.5);\n\n// Or hide a splat by setting radius to 0\ngsplatMakeRound(covA, covB, 0.0);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(n.p,{children:"Here are some examples demonstrating different custom shader techniques:"}),"\n",(0,i.jsx)(n.h3,{id:"animation-effects",children:"Animation Effects"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://playcanvas.github.io/#/gaussian-splatting/multi-splat",children:(0,i.jsx)(n.strong,{children:"Simple Sinusoidal Animation"})})," - ",(0,i.jsx)(n.strong,{children:"Uses Shader Chunk Customization"})," - Applies a simple shader to animate Gaussian color and position using a sine wave. This example demonstrates how to create dynamic, procedural motion effects by modifying splat properties in real-time."]}),"\n",(0,i.jsx)(n.h3,{id:"transition-effects",children:"Transition Effects"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://playcanvas.com/project/1224723/overview/3d-gaussian-splat-statues",children:(0,i.jsx)(n.strong,{children:"3D Gaussian Splat Statues"})})," - ",(0,i.jsx)(n.strong,{children:"Uses Full Shader Replacement"})," - Uses custom shaders to transition splats on and off screen via a hot, plasma-type effect. This showcases how custom shaders can create dramatic visual transitions and material effects."]}),"\n",(0,i.jsx)(n.h3,{id:"lighting-and-relighting",children:"Lighting and Relighting"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://playcanvas.com/project/1358087/overview/3dgs-with-physics-and-relighting",children:(0,i.jsx)(n.strong,{children:"3DGS with Physics and Relighting"})})," - ",(0,i.jsx)(n.strong,{children:"Uses Full Shader Replacement"})," - Uses custom shaders to relight a splat to implement a night mode with multiple moving point light sources. This example demonstrates advanced lighting techniques and how to dynamically modify splat appearance based on scene lighting conditions."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);