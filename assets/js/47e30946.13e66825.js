"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[26971],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var t=s(96540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}},41997:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"user-manual/graphics/advanced-rendering/multi-draw","title":"Multi-Draw","description":"Multi-draw is a rendering technique that lets the engine submit multiple sub-draws with a single API call. Multiple geometries are combined into a single Mesh and rendered through a single MeshInstance, with each sub-draw targeting a different portion of the combined geometry. This reduces CPU overhead and improves performance when rendering many sub-meshes that share the same material and render state.","source":"@site/docs/user-manual/graphics/advanced-rendering/multi-draw.md","sourceDirName":"user-manual/graphics/advanced-rendering","slug":"/user-manual/graphics/advanced-rendering/multi-draw","permalink":"/user-manual/graphics/advanced-rendering/multi-draw","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/graphics/advanced-rendering/multi-draw.md","tags":[],"version":"current","frontMatter":{"title":"Multi-Draw"},"sidebar":"userManualSidebar","previous":{"title":"Hardware Instancing","permalink":"/user-manual/graphics/advanced-rendering/hardware-instancing"},"next":{"title":"Multiple Render Targets","permalink":"/user-manual/graphics/advanced-rendering/multiple-render-targets"}}');var a=s(74848),i=s(28453);const r={title:"Multi-Draw"},c=void 0,d={},l=[{value:"Use Cases",id:"use-cases",level:2},{value:"Platform Support",id:"platform-support",level:2},{value:"Live Examples",id:"live-examples",level:2},{value:"Basic Multi-Draw",id:"basic-multi-draw",level:2},{value:"Step 1: Create a Combined Mesh",id:"step-1-create-a-combined-mesh",level:3},{value:"Step 2: Set Up Multi-Draw",id:"step-2-set-up-multi-draw",level:3},{value:"Step 3: Dynamic Updates",id:"step-3-dynamic-updates",level:3},{value:"Multi-Draw with Instancing",id:"multi-draw-with-instancing",level:2},{value:"WebGPU Approach",id:"webgpu-approach",level:3},{value:"Cross-Platform Approach",id:"cross-platform-approach",level:3},{value:"DrawCommands API Reference",id:"drawcommands-api-reference",level:2},{value:"setMultiDraw",id:"setmultidraw",level:3},{value:"add",id:"add",level:3},{value:"update",id:"update",level:3}];function o(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Multi-draw is a rendering technique that lets the engine submit multiple sub-draws with a single API call. Multiple geometries are combined into a single Mesh and rendered through a single MeshInstance, with each sub-draw targeting a different portion of the combined geometry. This reduces CPU overhead and improves performance when rendering many sub-meshes that share the same material and render state."}),"\n",(0,a.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,a.jsx)(n.p,{children:"Multi-draw is particularly useful for:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Terrain rendering"})," - Divide terrain into patches, render all visible patches in one call, and dynamically cull hidden patches"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Merged geometry"})," - Combine multiple geometries into a single mesh and render different portions with different instance counts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"LOD systems"})," - Switch between sub-meshes without changing draw calls"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Culling systems"})," - Hide/show portions of geometry without material changes"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"platform-support",children:"Platform Support"}),"\n",(0,a.jsxs)(n.p,{children:["Check multi-draw support using ",(0,a.jsx)(n.code,{children:"GraphicsDevice.supportsMultiDraw"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"if (app.graphicsDevice.supportsMultiDraw) {\n    // Use multi-draw\n} else {\n    // Fallback to standard rendering\n}\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"WebGPU"}),": Always supported (uses indirect draw commands)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"WebGL2"}),": Supported on most devices via the ",(0,a.jsx)(n.code,{children:"WEBGL_multi_draw"})," extension"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["When ",(0,a.jsx)(n.code,{children:"supportsMultiDraw"})," is false, the engine automatically falls back to an internal loop of single draw calls using the multi-draw data. While this doesn't provide the full multi-draw performance benefit, it is still significantly faster than rendering separate geometries with individual MeshInstances, as the material and render state are set up only once."]}),"\n",(0,a.jsx)(n.h2,{id:"live-examples",children:"Live Examples"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://playcanvas.vercel.app/#/graphics/multi-draw",children:"Multi-Draw"})," - Terrain rendering with dynamic patch culling"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://playcanvas.vercel.app/#/graphics/multi-draw-instanced",children:"Multi-Draw Instanced"})," - Different geometries with instancing (WebGPU only)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://playcanvas.vercel.app/#/graphics/multi-draw-instanced-multi-platform",children:"Multi-Draw Instanced Multi-Platform"})," - Cross-platform instanced multi-draw"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"basic-multi-draw",children:"Basic Multi-Draw"}),"\n",(0,a.jsx)(n.p,{children:"The simplest use of multi-draw is rendering sub-meshes from a combined mesh."}),"\n",(0,a.jsx)(n.h3,{id:"step-1-create-a-combined-mesh",children:"Step 1: Create a Combined Mesh"}),"\n",(0,a.jsx)(n.p,{children:"Combine multiple geometries into a single mesh, tracking the index offset and count for each sub-mesh:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Track sub-draw info\nconst subDraws = [];\nlet indexOffset = 0;\n\n// Combine geometries\nconst positions = [];\nconst indices = [];\nlet vertexBase = 0;\n\nfor (const geometry of geometries) {\n    // Store sub-draw info\n    subDraws.push({\n        firstIndex: indexOffset,\n        indexCount: geometry.indices.length\n    });\n\n    // Append positions\n    positions.push(...geometry.positions);\n\n    // Append indices with offset\n    for (const idx of geometry.indices) {\n        indices.push(vertexBase + idx);\n    }\n\n    vertexBase += geometry.positions.length / 3;\n    indexOffset += geometry.indices.length;\n}\n\n// Create the combined mesh\nconst mesh = new pc.Mesh(app.graphicsDevice);\nmesh.setPositions(positions);\nmesh.setIndices(indices);\nmesh.update();\n"})}),"\n",(0,a.jsx)(n.h3,{id:"step-2-set-up-multi-draw",children:"Step 2: Set Up Multi-Draw"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"MeshInstance.setMultiDraw()"})," to allocate draw commands and populate them:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const meshInst = new pc.MeshInstance(mesh, material);\n\n// Allocate multi-draw with max number of sub-draws\nconst cmd = meshInst.setMultiDraw(null, subDraws.length);\n\n// Add each sub-draw\nfor (let i = 0; i < subDraws.length; i++) {\n    const sub = subDraws[i];\n    // add(index, indexCount, instanceCount, firstIndex, baseVertex, firstInstance)\n    cmd.add(i, sub.indexCount, 1, sub.firstIndex, 0, 0);\n}\n\n// Finalize with the number of active draws\ncmd.update(subDraws.length);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"step-3-dynamic-updates",children:"Step 3: Dynamic Updates"}),"\n",(0,a.jsx)(n.p,{children:"You can update the draw commands each frame to show/hide sub-draws:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"app.on('update', (dt) => {\n    let activeCount = 0;\n\n    for (let i = 0; i < subDraws.length; i++) {\n        // Check if this sub-draw should be visible (e.g., frustum culling)\n        if (isVisible(subDraws[i])) {\n            cmd.add(activeCount, subDraws[i].indexCount, 1, subDraws[i].firstIndex, 0, 0);\n            activeCount++;\n        }\n    }\n\n    // Update with actual number of visible draws\n    cmd.update(activeCount);\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"multi-draw-with-instancing",children:"Multi-Draw with Instancing"}),"\n",(0,a.jsx)(n.p,{children:"Multi-draw can be combined with hardware instancing to render different geometries with different instance counts in a single call."}),"\n",(0,a.jsx)(n.h3,{id:"webgpu-approach",children:"WebGPU Approach"}),"\n",(0,a.jsxs)(n.p,{children:["On WebGPU, you can use the ",(0,a.jsx)(n.code,{children:"firstInstance"})," parameter to specify where each sub-draw reads its instance data from:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Three geometries with different instance counts\nconst instanceCounts = [8, 15, 25];\nconst totalInstances = instanceCounts.reduce((a, b) => a + b, 0);\n\n// Create instance data for all instances\nconst matrices = new Float32Array(totalInstances * 16);\n// ... populate matrices ...\n\n// Create instancing vertex buffer\nconst vbFormat = pc.VertexFormat.getDefaultInstancingFormat(app.graphicsDevice);\nconst vb = new pc.VertexBuffer(app.graphicsDevice, vbFormat, totalInstances, {\n    data: matrices\n});\nmeshInst.setInstancing(vb);\n\n// Set up multi-draw with firstInstance offsets\nconst firstInstance = [0, instanceCounts[0], instanceCounts[0] + instanceCounts[1]];\nconst cmd = meshInst.setMultiDraw(null, 3);\n\ncmd.add(0, indexCounts[0], instanceCounts[0], firstIndex[0], 0, firstInstance[0]);\ncmd.add(1, indexCounts[1], instanceCounts[1], firstIndex[1], 0, firstInstance[1]);\ncmd.add(2, indexCounts[2], instanceCounts[2], firstIndex[2], 0, firstInstance[2]);\ncmd.update(3);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"cross-platform-approach",children:"Cross-Platform Approach"}),"\n",(0,a.jsxs)(n.p,{children:["WebGL2 does not support ",(0,a.jsx)(n.code,{children:"firstInstance"}),". To achieve the same result on both platforms, you can store instance data in a texture and use ",(0,a.jsx)(n.code,{children:"gl_DrawID"})," with a custom shader chunk:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"if (app.graphicsDevice.isWebGL2 && app.graphicsDevice.supportsMultiDraw) {\n    // Store matrices in a texture\n    const matricesTexture = new pc.Texture(app.graphicsDevice, {\n        width: totalInstances * 4,  // 4 vec4s per matrix\n        height: 1,\n        format: pc.PIXELFORMAT_RGBA32F,\n        minFilter: pc.FILTER_NEAREST,\n        magFilter: pc.FILTER_NEAREST,\n        mipmaps: false,\n        levels: [matrices]\n    });\n\n    // Use custom vertex format with instance ID\n    const vbFormat = new pc.VertexFormat(app.graphicsDevice, [{\n        semantic: pc.SEMANTIC_ATTR11,\n        components: 1,\n        type: pc.TYPE_INT32,\n        asInt: true\n    }]);\n\n    // Override the instancing shader chunk\n    material.setAttribute('aInstanceId', pc.SEMANTIC_ATTR11);\n    material.setParameter('uDrawOffsets[0]', drawOffsets);\n    material.setParameter('uInstanceMatrices', matricesTexture);\n    material.shaderChunks.glsl.set('transformInstancingVS', customShaderCode);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The custom shader fetches the matrix from the texture using ",(0,a.jsx)(n.code,{children:"gl_DrawID"})," to determine the base offset:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-glsl",children:"#ifdef CAPS_MULTI_DRAW\n    attribute int aInstanceId;\n    uniform float uDrawOffsets[10];\n    uniform sampler2D uInstanceMatrices;\n\n    mat4 getInstancedMatrix(int index) {\n        int size = textureSize(uInstanceMatrices, 0).x;\n        int j = index * 4;\n        int x = j % size;\n        int y = j / size;\n        vec4 v1 = texelFetch(uInstanceMatrices, ivec2(x, y), 0);\n        vec4 v2 = texelFetch(uInstanceMatrices, ivec2(x + 1, y), 0);\n        vec4 v3 = texelFetch(uInstanceMatrices, ivec2(x + 2, y), 0);\n        vec4 v4 = texelFetch(uInstanceMatrices, ivec2(x + 3, y), 0);\n        return mat4(v1, v2, v3, v4);\n    }\n\n    mat4 getModelMatrix() {\n        int drawOffset = int(uDrawOffsets[gl_DrawID]);\n        int instanceIndex = drawOffset + aInstanceId;\n        return matrix_model * getInstancedMatrix(instanceIndex);\n    }\n#endif\n"})}),"\n",(0,a.jsx)(n.h2,{id:"drawcommands-api-reference",children:"DrawCommands API Reference"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"DrawCommands"})," class is returned by ",(0,a.jsx)(n.code,{children:"MeshInstance.setMultiDraw()"}),":"]}),"\n",(0,a.jsx)(n.h3,{id:"setmultidraw",children:"setMultiDraw"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const cmd = meshInstance.setMultiDraw(camera, maxCount);\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"camera"})," - CameraComponent to bind commands to, or ",(0,a.jsx)(n.code,{children:"null"})," for all cameras"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"maxCount"})," - Maximum number of sub-draws to allocate. Pass ",(0,a.jsx)(n.code,{children:"0"})," to disable multi-draw."]}),"\n",(0,a.jsxs)(n.li,{children:["Returns: ",(0,a.jsx)(n.code,{children:"DrawCommands"})," instance"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"add",children:"add"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"cmd.add(i, indexOrVertexCount, instanceCount, firstIndexOrVertex, baseVertex, firstInstance);\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"i"})," - Draw index (0 to maxCount-1)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"indexOrVertexCount"})," - Number of indices or vertices to draw"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"instanceCount"})," - Number of instances (use 1 if not instanced)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"firstIndexOrVertex"})," - Starting index or vertex offset"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"baseVertex"})," - Base vertex offset (WebGPU only, default 0)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"firstInstance"})," - First instance offset (WebGPU only, default 0)"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"update",children:"update"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"cmd.update(count);\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"count"})," - Actual number of draws to execute (can be less than maxCount)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Call ",(0,a.jsx)(n.code,{children:"update()"})," after all ",(0,a.jsx)(n.code,{children:"add()"})," calls to finalize the draw commands."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);