"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[84476],{8939:(e,t,n)=>{n.d(t,{X:()=>u});var r=n(93953),s=n(27351),i=n(53801),o=n(71586),a=n(85169);class u extends a.e{static scriptName="shadowCatcher";scale=new r.e(1,1,1);geometry;_geometryCreated=!1;initialize(){const e=new i.F;e.blendType=s.$M5,e.shadowCatcher=!0,e.useSkybox=!1,e.depthWrite=!1,e.diffuse.set(0,0,0),e.specular.set(0,0,0),e.update(),this.geometry||(this._geometryCreated=!0,this.geometry=new o.w("ShadowCatcherGeometry"),this.geometry.addComponent("render",{type:"plane",castShadows:!1,material:e})),this.entity.addChild(this.geometry),this.geometry?.render?.meshInstances.forEach(t=>{t.drawOrder=-1,this._geometryCreated||(t.material=e)}),this.on("destroy",()=>{this._geometryCreated&&this.geometry?.destroy(),e.destroy()})}update(){this.geometry?.setLocalScale(this.scale)}}},15817:(e,t,n)=>{n.d(t,{P:()=>ne});var r=n(48355),s=n(85169),i=n(59752),o=n(91622);const a="none";var u=n(27351),l=n(67248),c=n(55485),f=n(27173),d=n(63138),h=n(58333),v=n(84140),p=n(23160),m=n(47422);class x extends c.A{set shader(e){this.quadRender?.destroy(),this.quadRender=null,this._shader=e,e&&(this.quadRender=new p.o(e))}get shader(){return this._shader}execute(){const e=this.device;e.setBlendState(this.blendState),e.setCullMode(this.cullMode),e.setDepthState(this.depthState),e.setStencilState(this.stencilFront,this.stencilBack),this.quadRender.render()}constructor(...e){super(...e),this._shader=null,this.quadRender=null,this.cullMode=o.pLF,this.blendState=v.t.NOBLEND,this.depthState=m.H.NODEPTH,this.stencilFront=null,this.stencilBack=null}}var g=n(46659),y=n(80290);class T extends x{constructor(e,t,n={}){super(e),this.sourceTexture=t,this.premultiplyTexture=n.premultiplyTexture,y.W.get(e,o.BzK).set("downsamplePS","\nuniform sampler2D sourceTexture;\nuniform vec2 sourceInvResolution;\nvarying vec2 uv0;\n#ifdef PREMULTIPLY\n\tuniform sampler2D premultiplyTexture;\n#endif\nvoid main()\n{\n\tvec3 e = texture2D (sourceTexture, uv0).rgb;\n\t#ifdef BOXFILTER\n\t\tvec3 value = e;\n\t\t#ifdef PREMULTIPLY\n\t\t\tfloat premultiply = texture2D(premultiplyTexture, uv0).{PREMULTIPLY_SRC_CHANNEL};\n\t\t\tvalue *= vec3(premultiply);\n\t\t#endif\n\t#else\n\t\tfloat x = sourceInvResolution.x;\n\t\tfloat y = sourceInvResolution.y;\n\t\tvec3 a = texture2D(sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y + 2.0 * y)).rgb;\n\t\tvec3 b = texture2D(sourceTexture, vec2 (uv0.x,\t\t   uv0.y + 2.0 * y)).rgb;\n\t\tvec3 c = texture2D(sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y + 2.0 * y)).rgb;\n\t\tvec3 d = texture2D(sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y)).rgb;\n\t\tvec3 f = texture2D(sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y)).rgb;\n\t\tvec3 g = texture2D(sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y - 2.0 * y)).rgb;\n\t\tvec3 h = texture2D(sourceTexture, vec2 (uv0.x,\t\t   uv0.y - 2.0 * y)).rgb;\n\t\tvec3 i = texture2D(sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y - 2.0 * y)).rgb;\n\t\tvec3 j = texture2D(sourceTexture, vec2 (uv0.x - x, uv0.y + y)).rgb;\n\t\tvec3 k = texture2D(sourceTexture, vec2 (uv0.x + x, uv0.y + y)).rgb;\n\t\tvec3 l = texture2D(sourceTexture, vec2 (uv0.x - x, uv0.y - y)).rgb;\n\t\tvec3 m = texture2D(sourceTexture, vec2 (uv0.x + x, uv0.y - y)).rgb;\n\t\tvec3 value = e * 0.125;\n\t\tvalue += (a + c + g + i) * 0.03125;\n\t\tvalue += (b + d + f + h) * 0.0625;\n\t\tvalue += (j + k + l + m) * 0.125;\n\t#endif\n\t#ifdef REMOVE_INVALID\n\t\tvalue = max(value, vec3(0.0));\n\t#endif\n\tgl_FragColor = vec4(value, 1.0);\n}\n"),y.W.get(e,o.g80).set("downsamplePS","\nvar sourceTexture: texture_2d<f32>;\nvar sourceTextureSampler: sampler;\nuniform sourceInvResolution: vec2f;\nvarying uv0: vec2f;\n#ifdef PREMULTIPLY\n\tvar premultiplyTexture: texture_2d<f32>;\n\tvar premultiplyTextureSampler: sampler;\n#endif\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n\tvar output: FragmentOutput;\n\tlet e: vec3f = textureSample(sourceTexture, sourceTextureSampler, input.uv0).rgb;\n\t#ifdef BOXFILTER\n\t\tvar value: vec3f = e;\n\t\t#ifdef PREMULTIPLY\n\t\t\tlet premultiply: f32 = textureSample(premultiplyTexture, premultiplyTextureSampler, input.uv0).{PREMULTIPLY_SRC_CHANNEL};\n\t\t\tvalue = value * vec3f(premultiply);\n\t\t#endif\n\t#else\n\t\tlet x: f32 = uniform.sourceInvResolution.x;\n\t\tlet y: f32 = uniform.sourceInvResolution.y;\n\t\tlet a: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x - 2.0 * x, input.uv0.y + 2.0 * y)).rgb;\n\t\tlet b: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x,\t\t   input.uv0.y + 2.0 * y)).rgb;\n\t\tlet c: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x + 2.0 * x, input.uv0.y + 2.0 * y)).rgb;\n\t\tlet d: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x - 2.0 * x, input.uv0.y)).rgb;\n\t\tlet f: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x + 2.0 * x, input.uv0.y)).rgb;\n\t\tlet g: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x - 2.0 * x, input.uv0.y - 2.0 * y)).rgb;\n\t\tlet h: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x,\t\t   input.uv0.y - 2.0 * y)).rgb;\n\t\tlet i: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x + 2.0 * x, input.uv0.y - 2.0 * y)).rgb;\n\t\tlet j: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x - x, input.uv0.y + y)).rgb;\n\t\tlet k: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x + x, input.uv0.y + y)).rgb;\n\t\tlet l: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x - x, input.uv0.y - y)).rgb;\n\t\tlet m: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x + x, input.uv0.y - y)).rgb;\n\t\tvar value: vec3f = e * 0.125;\n\t\tvalue = value + (a + c + g + i) * 0.03125;\n\t\tvalue = value + (b + d + f + h) * 0.0625;\n\t\tvalue = value + (j + k + l + m) * 0.125;\n\t#endif\n\t#ifdef REMOVE_INVALID\n\t\tvalue = max(value, vec3f(0.0));\n\t#endif\n\toutput.color = vec4f(value, 1.0);\n\treturn output;\n}\n");const r=n.boxFilter??!1,s=`${r?"Box":""}-${n.premultiplyTexture?"Premultiply":""}-${n.premultiplySrcChannel??""}-${n.removeInvalid?"RemoveInvalid":""}`,i=new Map;r&&i.set("BOXFILTER",""),n.premultiplyTexture&&i.set("PREMULTIPLY",""),n.removeInvalid&&i.set("REMOVE_INVALID",""),i.set("{PREMULTIPLY_SRC_CHANNEL}",n.premultiplySrcChannel??"x"),this.shader=g.lo.createShader(e,{uniqueName:`DownSampleShader:${s}`,attributes:{aPosition:o.JYe},vertexChunk:"quadVS",fragmentChunk:"downsamplePS",fragmentDefines:i}),this.sourceTextureId=e.scope.resolve("sourceTexture"),this.premultiplyTextureId=e.scope.resolve("premultiplyTexture"),this.sourceInvResolutionId=e.scope.resolve("sourceInvResolution"),this.sourceInvResolutionValue=new Float32Array(2)}setSourceTexture(e){this._sourceTexture=e,this.options.resizeSource=e}execute(){this.sourceTextureId.setValue(this.sourceTexture),this.premultiplyTexture&&this.premultiplyTextureId.setValue(this.premultiplyTexture),this.sourceInvResolutionValue[0]=1/this.sourceTexture.width,this.sourceInvResolutionValue[1]=1/this.sourceTexture.height,this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue),super.execute()}}class b extends x{constructor(e,t){super(e),this.sourceTexture=t,y.W.get(e,o.BzK).set("upsamplePS","\n\tuniform sampler2D sourceTexture;\n\tuniform vec2 sourceInvResolution;\n\tvarying vec2 uv0;\n\tvoid main()\n\t{\n\t\tfloat x = sourceInvResolution.x;\n\t\tfloat y = sourceInvResolution.y;\n\t\tvec3 a = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y + y)).rgb;\n\t\tvec3 b = texture2D (sourceTexture, vec2 (uv0.x,\t uv0.y + y)).rgb;\n\t\tvec3 c = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y + y)).rgb;\n\t\tvec3 d = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y)).rgb;\n\t\tvec3 e = texture2D (sourceTexture, vec2 (uv0.x,\t uv0.y)).rgb;\n\t\tvec3 f = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y)).rgb;\n\t\tvec3 g = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y - y)).rgb;\n\t\tvec3 h = texture2D (sourceTexture, vec2 (uv0.x,\t uv0.y - y)).rgb;\n\t\tvec3 i = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y - y)).rgb;\n\t\tvec3 value = e * 4.0;\n\t\tvalue += (b + d + f + h) * 2.0;\n\t\tvalue += (a + c + g + i);\n\t\tvalue *= 1.0 / 16.0;\n\t\tgl_FragColor = vec4(value, 1.0);\n\t}\n"),y.W.get(e,o.g80).set("upsamplePS","\n\tvar sourceTexture: texture_2d<f32>;\n\tvar sourceTextureSampler: sampler;\n\tuniform sourceInvResolution: vec2f;\n\tvarying uv0: vec2f;\n\t@fragment\n\tfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n\t\tvar output: FragmentOutput;\n\t\tlet x: f32 = uniform.sourceInvResolution.x;\n\t\tlet y: f32 = uniform.sourceInvResolution.y;\n\t\tlet a: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x - x, input.uv0.y + y)).rgb;\n\t\tlet b: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x,\t input.uv0.y + y)).rgb;\n\t\tlet c: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x + x, input.uv0.y + y)).rgb;\n\t\tlet d: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x - x, input.uv0.y)).rgb;\n\t\tlet e: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x,\t input.uv0.y)).rgb;\n\t\tlet f: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x + x, input.uv0.y)).rgb;\n\t\tlet g: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x - x, input.uv0.y - y)).rgb;\n\t\tlet h: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x,\t input.uv0.y - y)).rgb;\n\t\tlet i: vec3f = textureSample(sourceTexture, sourceTextureSampler, vec2f(input.uv0.x + x, input.uv0.y - y)).rgb;\n\t\tvar value: vec3f = e * 4.0;\n\t\tvalue = value + (b + d + f + h) * 2.0;\n\t\tvalue = value + (a + c + g + i);\n\t\tvalue = value * (1.0 / 16.0);\n\t\toutput.color = vec4f(value, 1.0);\n\t\treturn output;\n\t}\n"),this.shader=g.lo.createShader(e,{uniqueName:"UpSampleShader",attributes:{aPosition:o.JYe},vertexChunk:"quadVS",fragmentChunk:"upsamplePS"}),this.sourceTextureId=e.scope.resolve("sourceTexture"),this.sourceInvResolutionId=e.scope.resolve("sourceInvResolution"),this.sourceInvResolutionValue=new Float32Array(2)}execute(){this.sourceTextureId.setValue(this.sourceTexture),this.sourceInvResolutionValue[0]=1/this.sourceTexture.width,this.sourceInvResolutionValue[1]=1/this.sourceTexture.height,this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue),super.execute()}}class S extends c.A{constructor(e,t,n){super(e),this.blurLevel=16,this.renderTargets=[],this._sourceTexture=t,this.textureFormat=n,this.bloomRenderTarget=this.createRenderTarget(0),this.bloomTexture=this.bloomRenderTarget.colorBuffer}destroy(){this.destroyRenderPasses(),this.destroyRenderTargets()}destroyRenderTargets(e=0){for(let t=e;t<this.renderTargets.length;t++){const e=this.renderTargets[t];e.destroyTextureBuffers(),e.destroy()}this.renderTargets.length=0}destroyRenderPasses(){for(let e=0;e<this.beforePasses.length;e++)this.beforePasses[e].destroy();this.beforePasses.length=0}createRenderTarget(e){return new h.O({depth:!1,colorBuffer:new l.g(this.device,{name:`BloomTexture${e}`,width:1,height:1,format:this.textureFormat,mipmaps:!1,minFilter:o.DrA,magFilter:o.DrA,addressU:o.vq6,addressV:o.vq6})})}createRenderTargets(e){for(let t=0;t<e;t++){const e=0===t?this.bloomRenderTarget:this.createRenderTarget(t);this.renderTargets.push(e)}}calcMipLevels(e,t,n){const r=Math.min(e,t);return Math.floor(Math.log2(r)-Math.log2(n))}createRenderPasses(e){const t=this.device;let n=this._sourceTexture;for(let s=0;s<e;s++){const e=new T(t,n),i=this.renderTargets[s];e.init(i,{resizeSource:n,scaleX:.5,scaleY:.5}),e.setClearColor(r.Q.BLACK),this.beforePasses.push(e),n=i.colorBuffer}n=this.renderTargets[e-1].colorBuffer;for(let r=e-2;r>=0;r--){const e=new b(t,n),s=this.renderTargets[r];e.init(s),e.blendState=v.t.ADDBLEND,this.beforePasses.push(e),n=s.colorBuffer}}onDisable(){this.renderTargets[0]?.resize(1,1),this.destroyRenderPasses(),this.destroyRenderTargets(1)}frameUpdate(){super.frameUpdate();const e=this.calcMipLevels(this._sourceTexture.width,this._sourceTexture.height,1),t=i.D.clamp(e,1,this.blurLevel);this.renderTargets.length!==t&&(this.destroyRenderPasses(),this.destroyRenderTargets(1),this.createRenderTargets(t),this.createRenderPasses(t))}}const P={composePS:'\n\t#include "tonemappingPS"\n\t#include "gammaPS"\n\tvarying vec2 uv0;\n\tuniform sampler2D sceneTexture;\n\tuniform vec2 sceneTextureInvRes;\n\t#include "composeBloomPS"\n\t#include "composeDofPS"\n\t#include "composeSsaoPS"\n\t#include "composeGradingPS"\n\t#include "composeVignettePS"\n\t#include "composeFringingPS"\n\t#include "composeCasPS"\n\t#include "composeColorLutPS"\n\tvoid main() {\n\t\tvec2 uv = uv0;\n\t\t#ifdef TAA\n\t\t#ifdef WEBGPU\n\t\t\tuv.y = 1.0 - uv.y;\n\t\t#endif\n\t\t#endif\n\t\tvec4 scene = texture2DLod(sceneTexture, uv, 0.0);\n\t\tvec3 result = scene.rgb;\n\t\t#ifdef CAS\n\t\t\tresult = applyCas(result, uv, sharpness);\n\t\t#endif\n\t\t#ifdef DOF\n\t\t\tresult = applyDof(result, uv0);\n\t\t#endif\n\t\t#ifdef SSAO_TEXTURE\n\t\t\tresult = applySsao(result, uv0);\n\t\t#endif\n\t\t#ifdef FRINGING\n\t\t\tresult = applyFringing(result, uv);\n\t\t#endif\n\t\t#ifdef BLOOM\n\t\t\tresult = applyBloom(result, uv0);\n\t\t#endif\n\t\t#ifdef GRADING\n\t\t\tresult = applyGrading(result);\n\t\t#endif\n\t\tresult = toneMap(max(vec3(0.0), result));\n\t\t#ifdef COLOR_LUT\n\t\t\tresult = applyColorLUT(result);\n\t\t#endif\n\t\t#ifdef VIGNETTE\n\t\t\tresult = applyVignette(result, uv);\n\t\t#endif\n\t\t#ifdef DEBUG_COMPOSE\n\t\t\t#if DEBUG_COMPOSE == scene\n\t\t\t\tresult = scene.rgb;\n\t\t\t#elif defined(BLOOM) && DEBUG_COMPOSE == bloom\n\t\t\t\tresult = dBloom * bloomIntensity;\n\t\t\t#elif defined(DOF) && DEBUG_COMPOSE == dofcoc\n\t\t\t\tresult = vec3(dCoc, 0.0);\n\t\t\t#elif defined(DOF) && DEBUG_COMPOSE == dofblur\n\t\t\t\tresult = dBlur;\n\t\t\t#elif defined(SSAO_TEXTURE) && DEBUG_COMPOSE == ssao\n\t\t\t\tresult = vec3(dSsao);\n\t\t\t#elif defined(VIGNETTE) && DEBUG_COMPOSE == vignette\n\t\t\t\tresult = vec3(dVignette);\n\t\t\t#endif\n\t\t#endif\n\t\tresult = gammaCorrectOutput(result);\n\t\tgl_FragColor = vec4(result, scene.a);\n\t}\n',composeBloomPS:"\n\t#ifdef BLOOM\n\t\tuniform sampler2D bloomTexture;\n\t\tuniform float bloomIntensity;\n\t\t\n\t\tvec3 dBloom;\n\t\t\n\t\tvec3 applyBloom(vec3 color, vec2 uv) {\n\t\t\tdBloom = texture2DLod(bloomTexture, uv, 0.0).rgb;\n\t\t\treturn color + dBloom * bloomIntensity;\n\t\t}\n\t#endif\n",composeDofPS:"\n\t#ifdef DOF\n\t\tuniform sampler2D cocTexture;\n\t\tuniform sampler2D blurTexture;\n\t\t\n\t\tvec2 dCoc;\n\t\tvec3 dBlur;\n\t\tvec3 getDofBlur(vec2 uv) {\n\t\t\tdCoc = texture2DLod(cocTexture, uv, 0.0).rg;\n\t\t\t#if DOF_UPSCALE\n\t\t\t\tvec2 blurTexelSize = 1.0 / vec2(textureSize(blurTexture, 0));\n\t\t\t\tvec3 bilinearBlur = vec3(0.0);\n\t\t\t\tfloat totalWeight = 0.0;\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\t\tvec2 offset = vec2(i, j) * blurTexelSize;\n\t\t\t\t\t\tvec2 cocSample = texture2DLod(cocTexture, uv + offset, 0.0).rg;\n\t\t\t\t\t\tvec3 blurSample = texture2DLod(blurTexture, uv + offset, 0.0).rgb;\n\t\t\t\t\t\tfloat cocWeight = clamp(cocSample.r + cocSample.g, 0.0, 1.0);\n\t\t\t\t\t\tbilinearBlur += blurSample * cocWeight;\n\t\t\t\t\t\ttotalWeight += cocWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (totalWeight > 0.0) {\n\t\t\t\t\tbilinearBlur /= totalWeight;\n\t\t\t\t}\n\t\t\t\tdBlur = bilinearBlur;\n\t\t\t\treturn bilinearBlur;\n\t\t\t#else\n\t\t\t\tdBlur = texture2DLod(blurTexture, uv, 0.0).rgb;\n\t\t\t\treturn dBlur;\n\t\t\t#endif\n\t\t}\n\t\tvec3 applyDof(vec3 color, vec2 uv) {\n\t\t\tvec3 blur = getDofBlur(uv);\n\t\t\treturn mix(color, blur, dCoc.r + dCoc.g);\n\t\t}\n\t#endif\n",composeSsaoPS:"\n\t#ifdef SSAO\n\t\t#define SSAO_TEXTURE\n\t#endif\n\t#if DEBUG_COMPOSE == ssao\n\t\t#define SSAO_TEXTURE\n\t#endif\n\t#ifdef SSAO_TEXTURE\n\t\tuniform sampler2D ssaoTexture;\n\t\t\n\t\tfloat dSsao;\n\t\t\n\t\tvec3 applySsao(vec3 color, vec2 uv) {\n\t\t\tdSsao = texture2DLod(ssaoTexture, uv, 0.0).r;\n\t\t\t\n\t\t\t#ifdef SSAO\n\t\t\t\treturn color * dSsao;\n\t\t\t#else\n\t\t\t\treturn color;\n\t\t\t#endif\n\t\t}\n\t#endif\n",composeGradingPS:"\n\t#ifdef GRADING\n\t\tuniform vec3 brightnessContrastSaturation;\n\t\tuniform vec3 tint;\n\t\tvec3 colorGradingHDR(vec3 color, float brt, float sat, float con) {\n\t\t\tcolor *= tint;\n\t\t\tcolor = color * brt;\n\t\t\tfloat grey = dot(color, vec3(0.3, 0.59, 0.11));\n\t\t\tgrey = grey / max(1.0, max(color.r, max(color.g, color.b)));\n\t\t\tcolor = mix(vec3(grey), color, sat);\n\t\t\treturn mix(vec3(0.5), color, con);\n\t\t}\n\t\tvec3 applyGrading(vec3 color) {\n\t\t\treturn colorGradingHDR(color, \n\t\t\t\tbrightnessContrastSaturation.x, \n\t\t\t\tbrightnessContrastSaturation.z, \n\t\t\t\tbrightnessContrastSaturation.y);\n\t\t}\n\t#endif\n",composeVignettePS:"\n\t#ifdef VIGNETTE\n\t\tuniform vec4 vignetterParams;\n\t\t\n\t\tfloat dVignette;\n\t\t\n\t\tfloat calcVignette(vec2 uv) {\n\t\t\tfloat inner = vignetterParams.x;\n\t\t\tfloat outer = vignetterParams.y;\n\t\t\tfloat curvature = vignetterParams.z;\n\t\t\tfloat intensity = vignetterParams.w;\n\t\t\tvec2 curve = pow(abs(uv * 2.0 -1.0), vec2(1.0 / curvature));\n\t\t\tfloat edge = pow(length(curve), curvature);\n\t\t\tdVignette = 1.0 - intensity * smoothstep(inner, outer, edge);\n\t\t\treturn dVignette;\n\t\t}\n\t\tvec3 applyVignette(vec3 color, vec2 uv) {\n\t\t\treturn color * calcVignette(uv);\n\t\t}\n\t#endif\n",composeFringingPS:"\n\t#ifdef FRINGING\n\t\tuniform float fringingIntensity;\n\t\tvec3 applyFringing(vec3 color, vec2 uv) {\n\t\t\tvec2 centerDistance = uv - 0.5;\n\t\t\tvec2 offset = fringingIntensity * pow(centerDistance, vec2(2.0, 2.0));\n\t\t\tcolor.r = texture2D(sceneTexture, uv - offset).r;\n\t\t\tcolor.b = texture2D(sceneTexture, uv + offset).b;\n\t\t\treturn color;\n\t\t}\n\t#endif\n",composeCasPS:"\n\t#ifdef CAS\n\t\tuniform float sharpness;\n\t\tfloat maxComponent(float x, float y, float z) { return max(x, max(y, z)); }\n\t\tvec3 toSDR(vec3 c) { return c / (1.0 + maxComponent(c.r, c.g, c.b)); }\n\t\tvec3 toHDR(vec3 c) { return c / (1.0 - maxComponent(c.r, c.g, c.b)); }\n\t\tvec3 applyCas(vec3 color, vec2 uv, float sharpness) {\n\t\t\tfloat x = sceneTextureInvRes.x;\n\t\t\tfloat y = sceneTextureInvRes.y;\n\t\t\tvec3 a = toSDR(texture2DLod(sceneTexture, uv + vec2(0.0, -y), 0.0).rgb);\n\t\t\tvec3 b = toSDR(texture2DLod(sceneTexture, uv + vec2(-x, 0.0), 0.0).rgb);\n\t\t\tvec3 c = toSDR(color.rgb);\n\t\t\tvec3 d = toSDR(texture2DLod(sceneTexture, uv + vec2(x, 0.0), 0.0).rgb);\n\t\t\tvec3 e = toSDR(texture2DLod(sceneTexture, uv + vec2(0.0, y), 0.0).rgb);\n\t\t\tfloat min_g = min(a.g, min(b.g, min(c.g, min(d.g, e.g))));\n\t\t\tfloat max_g = max(a.g, max(b.g, max(c.g, max(d.g, e.g))));\n\t\t\tfloat sharpening_amount = sqrt(min(1.0 - max_g, min_g) / max_g);\n\t\t\tfloat w = sharpening_amount * sharpness;\n\t\t\tvec3 res = (w * (a + b + d + e) + c) / (4.0 * w + 1.0);\n\t\t\tres = max(res, 0.0);\n\t\t\treturn toHDR(res);\n\t\t}\n\t#endif\n",composeColorLutPS:"\n\t#ifdef COLOR_LUT\n\t\tuniform sampler2D colorLUT;\n\t\tuniform vec4 colorLUTParams;\n\t\tvec3 applyColorLUT(vec3 color) {\n\t\t\tvec3 c = clamp(color, 0.0, 1.0);\n\t\t\tfloat width = colorLUTParams.x;\n\t\t\tfloat height = colorLUTParams.y;\n\t\t\tfloat maxColor = colorLUTParams.z;\n\t\t\tfloat cell = c.b * maxColor;\n\t\t\tfloat cell_l = floor(cell);\n\t\t\tfloat cell_h = ceil(cell);\n\t\t\tfloat half_px_x = 0.5 / width;\n\t\t\tfloat half_px_y = 0.5 / height;\n\t\t\tfloat r_offset = half_px_x + c.r / height * (maxColor / height);\n\t\t\tfloat g_offset = half_px_y + c.g * (maxColor / height);\n\t\t\tvec2 uv_l = vec2(cell_l / height + r_offset, g_offset);\n\t\t\tvec2 uv_h = vec2(cell_h / height + r_offset, g_offset);\n\t\t\tvec3 color_l = texture2DLod(colorLUT, uv_l, 0.0).rgb;\n\t\t\tvec3 color_h = texture2DLod(colorLUT, uv_h, 0.0).rgb;\n\t\t\tvec3 lutColor = mix(color_l, color_h, fract(cell));\n\t\t\treturn mix(color, lutColor, colorLUTParams.w);\n\t\t}\n\t#endif\n"};const _={composePS:'\n\t#include "tonemappingPS"\n\t#include "gammaPS"\n\tvarying uv0: vec2f;\n\tvar sceneTexture: texture_2d<f32>;\n\tvar sceneTextureSampler: sampler;\n\tuniform sceneTextureInvRes: vec2f;\n\t#include "composeBloomPS"\n\t#include "composeDofPS"\n\t#include "composeSsaoPS"\n\t#include "composeGradingPS"\n\t#include "composeVignettePS"\n\t#include "composeFringingPS"\n\t#include "composeCasPS"\n\t#include "composeColorLutPS"\n\t@fragment\n\tfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n\t\tvar output: FragmentOutput;\n\t\tvar uv = uv0;\n\t\t#ifdef TAA\n\t\t\tuv.y = 1.0 - uv.y;\n\t\t#endif\n\t\tlet scene = textureSampleLevel(sceneTexture, sceneTextureSampler, uv, 0.0);\n\t\tvar result = scene.rgb;\n\t\t#ifdef CAS\n\t\t\tresult = applyCas(result, uv, uniform.sharpness);\n\t\t#endif\n\t\t#ifdef DOF\n\t\t\tresult = applyDof(result, uv0);\n\t\t#endif\n\t\t#ifdef SSAO_TEXTURE\n\t\t\tresult = applySsao(result, uv0);\n\t\t#endif\n\t\t#ifdef FRINGING\n\t\t\tresult = applyFringing(result, uv);\n\t\t#endif\n\t\t#ifdef BLOOM\n\t\t\tresult = applyBloom(result, uv0);\n\t\t#endif\n\t\t#ifdef GRADING\n\t\t\tresult = applyGrading(result);\n\t\t#endif\n\t\tresult = toneMap(max(vec3f(0.0), result));\n\t\t#ifdef COLOR_LUT\n\t\t\tresult = applyColorLUT(result);\n\t\t#endif\n\t\t#ifdef VIGNETTE\n\t\t\tresult = applyVignette(result, uv);\n\t\t#endif\n\t\t#ifdef DEBUG_COMPOSE\n\t\t\t#if DEBUG_COMPOSE == scene\n\t\t\t\tresult = scene.rgb;\n\t\t\t#elif defined(BLOOM) && DEBUG_COMPOSE == bloom\n\t\t\t\tresult = dBloom * uniform.bloomIntensity;\n\t\t\t#elif defined(DOF) && DEBUG_COMPOSE == dofcoc\n\t\t\t\tresult = vec3f(dCoc, 0.0);\n\t\t\t#elif defined(DOF) && DEBUG_COMPOSE == dofblur\n\t\t\t\tresult = dBlur;\n\t\t\t#elif defined(SSAO_TEXTURE) && DEBUG_COMPOSE == ssao\n\t\t\t\tresult = vec3f(dSsao);\n\t\t\t#elif defined(VIGNETTE) && DEBUG_COMPOSE == vignette\n\t\t\t\tresult = vec3f(dVignette);\n\t\t\t#endif\n\t\t#endif\n\t\tresult = gammaCorrectOutput(result);\n\t\toutput.color = vec4f(result, scene.a);\n\t\treturn output;\n\t}\n',composeBloomPS:"\n\t#ifdef BLOOM\n\t\tvar bloomTexture: texture_2d<f32>;\n\t\tvar bloomTextureSampler: sampler;\n\t\tuniform bloomIntensity: f32;\n\t\t\n\t\tvar<private> dBloom: vec3f;\n\t\t\n\t\tfn applyBloom(color: vec3f, uv: vec2f) -> vec3f {\n\t\t\tdBloom = textureSampleLevel(bloomTexture, bloomTextureSampler, uv, 0.0).rgb;\n\t\t\treturn color + dBloom * uniform.bloomIntensity;\n\t\t}\n\t#endif\n",composeDofPS:"\n\t#ifdef DOF\n\t\tvar cocTexture: texture_2d<f32>;\n\t\tvar cocTextureSampler: sampler;\n\t\tvar blurTexture: texture_2d<f32>;\n\t\tvar blurTextureSampler: sampler;\n\t\t\n\t\tvar<private> dCoc: vec2f;\n\t\tvar<private> dBlur: vec3f;\n\t\tfn getDofBlur(uv: vec2f) -> vec3f {\n\t\t\tdCoc = textureSampleLevel(cocTexture, cocTextureSampler, uv, 0.0).rg;\n\t\t\t#if DOF_UPSCALE\n\t\t\t\tlet blurTexelSize = 1.0 / vec2f(textureDimensions(blurTexture, 0));\n\t\t\t\tvar bilinearBlur = vec3f(0.0);\n\t\t\t\tvar totalWeight = 0.0;\n\t\t\t\tfor (var i = -1; i <= 1; i++) {\n\t\t\t\t\tfor (var j = -1; j <= 1; j++) {\n\t\t\t\t\t\tlet offset = vec2f(f32(i), f32(j)) * blurTexelSize;\n\t\t\t\t\t\tlet cocSample = textureSampleLevel(cocTexture, cocTextureSampler, uv + offset, 0.0).rg;\n\t\t\t\t\t\tlet blurSample = textureSampleLevel(blurTexture, blurTextureSampler, uv + offset, 0.0).rgb;\n\t\t\t\t\t\tlet cocWeight = clamp(cocSample.r + cocSample.g, 0.0, 1.0);\n\t\t\t\t\t\tbilinearBlur += blurSample * cocWeight;\n\t\t\t\t\t\ttotalWeight += cocWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (totalWeight > 0.0) {\n\t\t\t\t\tbilinearBlur /= totalWeight;\n\t\t\t\t}\n\t\t\t\tdBlur = bilinearBlur;\n\t\t\t\treturn bilinearBlur;\n\t\t\t#else\n\t\t\t\tdBlur = textureSampleLevel(blurTexture, blurTextureSampler, uv, 0.0).rgb;\n\t\t\t\treturn dBlur;\n\t\t\t#endif\n\t\t}\n\t\tfn applyDof(color: vec3f, uv: vec2f) -> vec3f {\n\t\t\tlet blur = getDofBlur(uv);\n\t\t\treturn mix(color, blur, dCoc.r + dCoc.g);\n\t\t}\n\t#endif\n",composeSsaoPS:"\n\t#ifdef SSAO\n\t\t#define SSAO_TEXTURE\n\t#endif\n\t#if DEBUG_COMPOSE == ssao\n\t\t#define SSAO_TEXTURE\n\t#endif\n\t#ifdef SSAO_TEXTURE\n\t\tvar ssaoTexture: texture_2d<f32>;\n\t\tvar ssaoTextureSampler: sampler;\n\t\t\n\t\tvar<private> dSsao: f32;\n\t\t\n\t\tfn applySsao(color: vec3f, uv: vec2f) -> vec3f {\n\t\t\tdSsao = textureSampleLevel(ssaoTexture, ssaoTextureSampler, uv, 0.0).r;\n\t\t\t\n\t\t\t#ifdef SSAO\n\t\t\t\treturn color * dSsao;\n\t\t\t#else\n\t\t\t\treturn color;\n\t\t\t#endif\n\t\t}\n\t#endif\n",composeGradingPS:"\n\t#ifdef GRADING\n\t\tuniform brightnessContrastSaturation: vec3f;\n\t\tuniform tint: vec3f;\n\t\tfn colorGradingHDR(color: vec3f, brt: f32, sat: f32, con: f32) -> vec3f {\n\t\t\tvar colorOut = color * uniform.tint;\n\t\t\tcolorOut = colorOut * brt;\n\t\t\tlet grey = dot(colorOut, vec3f(0.3, 0.59, 0.11));\n\t\t\tlet normalizedGrey = grey / max(1.0, max(colorOut.r, max(colorOut.g, colorOut.b)));\n\t\t\tcolorOut = mix(vec3f(normalizedGrey), colorOut, sat);\n\t\t\treturn mix(vec3f(0.5), colorOut, con);\n\t\t}\n\t\tfn applyGrading(color: vec3f) -> vec3f {\n\t\t\treturn colorGradingHDR(color, \n\t\t\t\tuniform.brightnessContrastSaturation.x, \n\t\t\t\tuniform.brightnessContrastSaturation.z, \n\t\t\t\tuniform.brightnessContrastSaturation.y);\n\t\t}\n\t#endif\n",composeVignettePS:"\n\t#ifdef VIGNETTE\n\t\tuniform vignetterParams: vec4f;\n\t\t\n\t\tvar<private> dVignette: f32;\n\t\t\n\t\tfn calcVignette(uv: vec2f) -> f32 {\n\t\t\tlet inner = uniform.vignetterParams.x;\n\t\t\tlet outer = uniform.vignetterParams.y;\n\t\t\tlet curvature = uniform.vignetterParams.z;\n\t\t\tlet intensity = uniform.vignetterParams.w;\n\t\t\tlet curve = pow(abs(uv * 2.0 - 1.0), vec2f(1.0 / curvature));\n\t\t\tlet edge = pow(length(curve), curvature);\n\t\t\tdVignette = 1.0 - intensity * smoothstep(inner, outer, edge);\n\t\t\treturn dVignette;\n\t\t}\n\t\tfn applyVignette(color: vec3f, uv: vec2f) -> vec3f {\n\t\t\treturn color * calcVignette(uv);\n\t\t}\n\t#endif\n",composeFringingPS:"\n\t#ifdef FRINGING\n\t\tuniform fringingIntensity: f32;\n\t\tfn applyFringing(color: vec3f, uv: vec2f) -> vec3f {\n\t\t\tlet centerDistance = uv - 0.5;\n\t\t\tlet offset = uniform.fringingIntensity * pow(centerDistance, vec2f(2.0));\n\t\t\tvar colorOut = color;\n\t\t\tcolorOut.r = textureSample(sceneTexture, sceneTextureSampler, uv - offset).r;\n\t\t\tcolorOut.b = textureSample(sceneTexture, sceneTextureSampler, uv + offset).b;\n\t\t\treturn colorOut;\n\t\t}\n\t#endif\n",composeCasPS:"\n\t#ifdef CAS\n\t\tuniform sharpness: f32;\n\t\tfn maxComponent(x: f32, y: f32, z: f32) -> f32 { return max(x, max(y, z)); }\n\t\tfn toSDR(c: vec3f) -> vec3f { return c / (1.0 + maxComponent(c.r, c.g, c.b)); }\n\t\tfn toHDR(c: vec3f) -> vec3f { return c / (1.0 - maxComponent(c.r, c.g, c.b)); }\n\t\tfn applyCas(color: vec3f, uv: vec2f, sharpness: f32) -> vec3f {\n\t\t\tlet x = uniform.sceneTextureInvRes.x;\n\t\t\tlet y = uniform.sceneTextureInvRes.y;\n\t\t\tlet a = toSDR(textureSampleLevel(sceneTexture, sceneTextureSampler, uv + vec2f(0.0, -y), 0.0).rgb);\n\t\t\tlet b = toSDR(textureSampleLevel(sceneTexture, sceneTextureSampler, uv + vec2f(-x, 0.0), 0.0).rgb);\n\t\t\tlet c = toSDR(color.rgb);\n\t\t\tlet d = toSDR(textureSampleLevel(sceneTexture, sceneTextureSampler, uv + vec2f(x, 0.0), 0.0).rgb);\n\t\t\tlet e = toSDR(textureSampleLevel(sceneTexture, sceneTextureSampler, uv + vec2f(0.0, y), 0.0).rgb);\n\t\t\tlet min_g = min(a.g, min(b.g, min(c.g, min(d.g, e.g))));\n\t\t\tlet max_g = max(a.g, max(b.g, max(c.g, max(d.g, e.g))));\n\t\t\tlet sharpening_amount = sqrt(min(1.0 - max_g, min_g) / max_g);\n\t\t\tlet w = sharpening_amount * uniform.sharpness;\n\t\t\tvar res = (w * (a + b + d + e) + c) / (4.0 * w + 1.0);\n\t\t\tres = max(res, vec3f(0.0));\n\t\t\treturn toHDR(res);\n\t\t}\n\t#endif\n",composeColorLutPS:"\n\t#ifdef COLOR_LUT\n\t\tvar colorLUT: texture_2d<f32>;\n\t\tvar colorLUTSampler: sampler;\n\t\tuniform colorLUTParams: vec4f;\n\t\tfn applyColorLUT(color: vec3f) -> vec3f {\n\t\t\tvar c: vec3f = clamp(color, vec3f(0.0), vec3f(1.0));\n\t\t\tlet width: f32 = uniform.colorLUTParams.x;\n\t\t\tlet height: f32 = uniform.colorLUTParams.y;\n\t\t\tlet maxColor: f32 = uniform.colorLUTParams.z;\n\t\t\tlet cell: f32 = c.b * maxColor;\n\t\t\tlet cell_l: f32 = floor(cell);\n\t\t\tlet cell_h: f32 = ceil(cell);\n\t\t\tlet half_px_x: f32 = 0.5 / width;\n\t\t\tlet half_px_y: f32 = 0.5 / height;\n\t\t\tlet r_offset: f32 = half_px_x + c.r / height * (maxColor / height);\n\t\t\tlet g_offset: f32 = half_px_y + c.g * (maxColor / height);\n\t\t\tlet uv_l: vec2f = vec2f(cell_l / height + r_offset, g_offset);\n\t\t\tlet uv_h: vec2f = vec2f(cell_h / height + r_offset, g_offset);\n\t\t\tlet color_l: vec3f = textureSampleLevel(colorLUT, colorLUTSampler, uv_l, 0.0).rgb;\n\t\t\tlet color_h: vec3f = textureSampleLevel(colorLUT, colorLUTSampler, uv_h, 0.0).rgb;\n\t\t\tlet lutColor: vec3f = mix(color_l, color_h, fract(cell));\n\t\t\treturn mix(color, lutColor, uniform.colorLUTParams.w);\n\t\t}\n\t#endif\n"};class R extends x{constructor(e){super(e),this.sceneTexture=null,this.bloomIntensity=.01,this._bloomTexture=null,this._cocTexture=null,this.blurTexture=null,this.blurTextureUpscale=!1,this._ssaoTexture=null,this._toneMapping=u.llM,this._gradingEnabled=!1,this.gradingSaturation=1,this.gradingContrast=1,this.gradingBrightness=1,this.gradingTint=new r.Q(1,1,1,1),this._shaderDirty=!0,this._vignetteEnabled=!1,this.vignetteInner=.5,this.vignetteOuter=1,this.vignetteCurvature=.5,this.vignetteIntensity=.3,this._fringingEnabled=!1,this.fringingIntensity=10,this._taaEnabled=!1,this._sharpness=.5,this._gammaCorrection=u.JdY,this._colorLUT=null,this.colorLUTIntensity=1,this._key="",this._debug=null,y.W.get(e,o.BzK).add(P),y.W.get(e,o.g80).add(_);const{scope:t}=e;this.sceneTextureId=t.resolve("sceneTexture"),this.bloomTextureId=t.resolve("bloomTexture"),this.cocTextureId=t.resolve("cocTexture"),this.ssaoTextureId=t.resolve("ssaoTexture"),this.blurTextureId=t.resolve("blurTexture"),this.bloomIntensityId=t.resolve("bloomIntensity"),this.bcsId=t.resolve("brightnessContrastSaturation"),this.tintId=t.resolve("tint"),this.vignetterParamsId=t.resolve("vignetterParams"),this.fringingIntensityId=t.resolve("fringingIntensity"),this.sceneTextureInvResId=t.resolve("sceneTextureInvRes"),this.sceneTextureInvResValue=new Float32Array(2),this.sharpnessId=t.resolve("sharpness"),this.colorLUTId=t.resolve("colorLUT"),this.colorLUTParams=new Float32Array(4),this.colorLUTParamsId=t.resolve("colorLUTParams")}set debug(e){this._debug!==e&&(this._debug=e,this._shaderDirty=!0)}get debug(){return this._debug}set colorLUT(e){this._colorLUT!==e&&(this._colorLUT=e,this._shaderDirty=!0)}get colorLUT(){return this._colorLUT}set bloomTexture(e){this._bloomTexture!==e&&(this._bloomTexture=e,this._shaderDirty=!0)}get bloomTexture(){return this._bloomTexture}set cocTexture(e){this._cocTexture!==e&&(this._cocTexture=e,this._shaderDirty=!0)}get cocTexture(){return this._cocTexture}set ssaoTexture(e){this._ssaoTexture!==e&&(this._ssaoTexture=e,this._shaderDirty=!0)}get ssaoTexture(){return this._ssaoTexture}set taaEnabled(e){this._taaEnabled!==e&&(this._taaEnabled=e,this._shaderDirty=!0)}get taaEnabled(){return this._taaEnabled}set gradingEnabled(e){this._gradingEnabled!==e&&(this._gradingEnabled=e,this._shaderDirty=!0)}get gradingEnabled(){return this._gradingEnabled}set vignetteEnabled(e){this._vignetteEnabled!==e&&(this._vignetteEnabled=e,this._shaderDirty=!0)}get vignetteEnabled(){return this._vignetteEnabled}set fringingEnabled(e){this._fringingEnabled!==e&&(this._fringingEnabled=e,this._shaderDirty=!0)}get fringingEnabled(){return this._fringingEnabled}set toneMapping(e){this._toneMapping!==e&&(this._toneMapping=e,this._shaderDirty=!0)}get toneMapping(){return this._toneMapping}set sharpness(e){this._sharpness!==e&&(this._sharpness=e,this._shaderDirty=!0)}get sharpness(){return this._sharpness}get isSharpnessEnabled(){return this._sharpness>0}postInit(){this.setClearColor(r.Q.BLACK),this.setClearDepth(1),this.setClearStencil(0)}frameUpdate(){const e=(this.renderTarget??this.device.backBuffer).isColorBufferSrgb(0)?u.hcE:u.JdY;if(this._gammaCorrection!==e&&(this._gammaCorrection=e,this._shaderDirty=!0),this._shaderDirty){this._shaderDirty=!1;const e=u.IaO[this._gammaCorrection],t=`${this.toneMapping}-${e}-`+(this.bloomTexture?"bloom":"nobloom")+"-"+(this.cocTexture?"dof":"nodof")+"-"+(this.blurTextureUpscale?"dofupscale":"")+"-"+(this.ssaoTexture?"ssao":"nossao")+"-"+(this.gradingEnabled?"grading":"nograding")+"-"+(this.colorLUT?"colorlut":"nocolorlut")+"-"+(this.vignetteEnabled?"vignette":"novignette")+"-"+(this.fringingEnabled?"fringing":"nofringing")+"-"+(this.taaEnabled?"taa":"notaa")+"-"+(this.isSharpnessEnabled?"cas":"nocas")+`-${this._debug??""}`;if(this._key!==t){this._key=t;const n=new Map;n.set("TONEMAP",u.lh8[this.toneMapping]),n.set("GAMMA",e),this.bloomTexture&&n.set("BLOOM",!0),this.cocTexture&&n.set("DOF",!0),this.blurTextureUpscale&&n.set("DOF_UPSCALE",!0),this.ssaoTexture&&n.set("SSAO",!0),this.gradingEnabled&&n.set("GRADING",!0),this.colorLUT&&n.set("COLOR_LUT",!0),this.vignetteEnabled&&n.set("VIGNETTE",!0),this.fringingEnabled&&n.set("FRINGING",!0),this.taaEnabled&&n.set("TAA",!0),this.isSharpnessEnabled&&n.set("CAS",!0),this._debug&&n.set("DEBUG_COMPOSE",this._debug);const r=new Map(y.W.get(this.device,this.device.isWebGPU?o.g80:o.BzK));this.shader=g.lo.createShader(this.device,{uniqueName:`ComposeShader-${t}`,attributes:{aPosition:o.JYe},vertexChunk:"quadVS",fragmentChunk:"composePS",fragmentDefines:n,fragmentIncludes:r})}}}execute(){this.sceneTextureId.setValue(this.sceneTexture),this.sceneTextureInvResValue[0]=1/this.sceneTexture.width,this.sceneTextureInvResValue[1]=1/this.sceneTexture.height,this.sceneTextureInvResId.setValue(this.sceneTextureInvResValue),this._bloomTexture&&(this.bloomTextureId.setValue(this._bloomTexture),this.bloomIntensityId.setValue(this.bloomIntensity)),this._cocTexture&&(this.cocTextureId.setValue(this._cocTexture),this.blurTextureId.setValue(this.blurTexture)),this._ssaoTexture&&this.ssaoTextureId.setValue(this._ssaoTexture),this._gradingEnabled&&(this.bcsId.setValue([this.gradingBrightness,this.gradingContrast,this.gradingSaturation]),this.tintId.setValue([this.gradingTint.r,this.gradingTint.g,this.gradingTint.b]));const e=this._colorLUT;e&&(this.colorLUTParams[0]=e.width,this.colorLUTParams[1]=e.height,this.colorLUTParams[2]=e.height-1,this.colorLUTParams[3]=this.colorLUTIntensity,this.colorLUTParamsId.setValue(this.colorLUTParams),this.colorLUTId.setValue(e)),this._vignetteEnabled&&this.vignetterParamsId.setValue([this.vignetteInner,this.vignetteOuter,this.vignetteCurvature,this.vignetteIntensity]),this._fringingEnabled&&this.fringingIntensityId.setValue(this.fringingIntensity/1024),this.isSharpnessEnabled&&this.sharpnessId.setValue(i.D.lerp(-.125,-.2,this.sharpness)),super.execute()}}class C extends x{constructor(e,t,n){super(e),this.historyIndex=0,this.historyTexture=null,this.historyTextures=[],this.historyRenderTargets=[],this.sourceTexture=t,this.cameraComponent=n,y.W.get(e,o.BzK).set("sampleCatmullRomPS","\nvec4 SampleTextureCatmullRom(TEXTURE_ACCEPT(tex), vec2 uv, vec2 texSize) {\n\tvec2 samplePos = uv * texSize;\n\tvec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\tvec2 f = samplePos - texPos1;\n\tvec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));\n\tvec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);\n\tvec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));\n\tvec2 w3 = f * f * (-0.5 + 0.5 * f);\n\tvec2 w12 = w1 + w2;\n\tvec2 offset12 = w2 / (w1 + w2);\n\tvec2 texPos0 = (texPos1 - 1.0) / texSize;\n\tvec2 texPos3 = (texPos1 + 2.0) / texSize;\n\tvec2 texPos12 = (texPos1 + offset12) / texSize;\n\tvec4 result = vec4(0.0);\n\tresult += texture2DLod(tex, vec2(texPos0.x, texPos0.y), 0.0) * w0.x * w0.y;\n\tresult += texture2DLod(tex, vec2(texPos12.x, texPos0.y), 0.0) * w12.x * w0.y;\n\tresult += texture2DLod(tex, vec2(texPos3.x, texPos0.y), 0.0) * w3.x * w0.y;\n\tresult += texture2DLod(tex, vec2(texPos0.x, texPos12.y), 0.0) * w0.x * w12.y;\n\tresult += texture2DLod(tex, vec2(texPos12.x, texPos12.y), 0.0) * w12.x * w12.y;\n\tresult += texture2DLod(tex, vec2(texPos3.x, texPos12.y), 0.0) * w3.x * w12.y;\n\tresult += texture2DLod(tex, vec2(texPos0.x, texPos3.y), 0.0) * w0.x * w3.y;\n\tresult += texture2DLod(tex, vec2(texPos12.x, texPos3.y), 0.0) * w12.x * w3.y;\n\tresult += texture2DLod(tex, vec2(texPos3.x, texPos3.y), 0.0) * w3.x * w3.y;\n\treturn result;\n}\n"),y.W.get(e,o.g80).set("sampleCatmullRomPS","\nfn SampleTextureCatmullRom(tex: texture_2d<f32>, texSampler: sampler, uv: vec2f, texSize: vec2f) -> vec4f {\n\tlet samplePos: vec2f = uv * texSize;\n\tlet texPos1: vec2f = floor(samplePos - 0.5) + 0.5;\n\tlet f: vec2f = samplePos - texPos1;\n\tlet w0: vec2f = f * (-0.5 + f * (1.0 - 0.5 * f));\n\tlet w1: vec2f = 1.0 + f * f * (-2.5 + 1.5 * f);\n\tlet w2: vec2f = f * (0.5 + f * (2.0 - 1.5 * f));\n\tlet w3: vec2f = f * f * (-0.5 + 0.5 * f);\n\tlet w12: vec2f = w1 + w2;\n\tlet offset12: vec2f = w2 / w12;\n\tlet texPos0: vec2f = (texPos1 - 1.0) / texSize;\n\tlet texPos3: vec2f = (texPos1 + 2.0) / texSize;\n\tlet texPos12: vec2f = (texPos1 + offset12) / texSize;\n\tvar result: vec4f = vec4f(0.0);\n\tresult = result + textureSampleLevel(tex, texSampler, vec2f(texPos0.x, texPos0.y), 0.0) * w0.x * w0.y;\n\tresult = result + textureSampleLevel(tex, texSampler, vec2f(texPos12.x, texPos0.y), 0.0) * w12.x * w0.y;\n\tresult = result + textureSampleLevel(tex, texSampler, vec2f(texPos3.x, texPos0.y), 0.0) * w3.x * w0.y;\n\tresult = result + textureSampleLevel(tex, texSampler, vec2f(texPos0.x, texPos12.y), 0.0) * w0.x * w12.y;\n\tresult = result + textureSampleLevel(tex, texSampler, vec2f(texPos12.x, texPos12.y), 0.0) * w12.x * w12.y;\n\tresult = result + textureSampleLevel(tex, texSampler, vec2f(texPos3.x, texPos12.y), 0.0) * w3.x * w12.y;\n\tresult = result + textureSampleLevel(tex, texSampler, vec2f(texPos0.x, texPos3.y), 0.0) * w0.x * w3.y;\n\tresult = result + textureSampleLevel(tex, texSampler, vec2f(texPos12.x, texPos3.y), 0.0) * w12.x * w3.y;\n\tresult = result + textureSampleLevel(tex, texSampler, vec2f(texPos3.x, texPos3.y), 0.0) * w3.x * w3.y;\n\treturn result;\n}\n"),y.W.get(e,o.BzK).set("taaResolvePS",'\n\t#include  "sampleCatmullRomPS"\n\t#include  "screenDepthPS"\n\tuniform sampler2D sourceTexture;\n\tuniform sampler2D historyTexture;\n\tuniform mat4 matrix_viewProjectionPrevious;\n\tuniform mat4 matrix_viewProjectionInverse;\n\tuniform vec4 jitters;\n\tuniform vec2 textureSize;\n\tvarying vec2 uv0;\n\tvec2 reproject(vec2 uv, float depth) {\n\t\t#ifndef WEBGPU\n\t\t\tdepth = depth * 2.0 - 1.0;\n\t\t#endif\n\t\tvec4 ndc = vec4(uv * 2.0 - 1.0, depth, 1.0);\n\t\tndc.xy -= jitters.xy;\n\t\tvec4 worldPosition = matrix_viewProjectionInverse * ndc;\n\t\tworldPosition /= worldPosition.w;\n\t\tvec4 screenPrevious = matrix_viewProjectionPrevious * worldPosition;\n\t\treturn (screenPrevious.xy / screenPrevious.w) * 0.5 + 0.5;\n\t}\n\tvec4 colorClamp(vec2 uv, vec4 historyColor) {\n\t\tvec3 minColor = vec3(9999.0);\n\t\tvec3 maxColor = vec3(-9999.0);\n\t\tfor(float x = -1.0; x <= 1.0; ++x) {\n\t\t\tfor(float y = -1.0; y <= 1.0; ++y) {\n\t\t\t\tvec3 color = texture2D(sourceTexture, uv + vec2(x, y) / textureSize).rgb;\n\t\t\t\tminColor = min(minColor, color);\n\t\t\t\tmaxColor = max(maxColor, color);\n\t\t\t}\n\t\t}\n\t\tvec3 clamped = clamp(historyColor.rgb, minColor, maxColor);\n\t\treturn vec4(clamped, historyColor.a);\n\t}\n\tvoid main()\n\t{\n\t\tvec2 uv = uv0;\n\t\t#ifdef WEBGPU\n\t\t\tuv.y = 1.0 - uv.y;\n\t\t#endif\n\t\tvec4 srcColor = texture2D(sourceTexture, uv);\n\t\tfloat linearDepth = getLinearScreenDepth(uv0);\n\t\tfloat depth = delinearizeDepth(linearDepth);\n\t\tvec2 historyUv = reproject(uv0, depth);\n\t\t#ifdef QUALITY_HIGH\n\t\t\tvec4 historyColor = SampleTextureCatmullRom(TEXTURE_PASS(historyTexture), historyUv, textureSize);\n\t\t#else\n\t\t\tvec4 historyColor = texture2D(historyTexture, historyUv);\n\t\t#endif\n\t\tvec4 historyColorClamped = colorClamp(uv, historyColor);\n\t\tfloat mixFactor = (historyUv.x < 0.0 || historyUv.x > 1.0 || historyUv.y < 0.0 || historyUv.y > 1.0) ?\n\t\t\t1.0 : 0.05;\n\t\tgl_FragColor = mix(historyColorClamped, srcColor, mixFactor);\n\t}\n'),y.W.get(e,o.g80).set("taaResolvePS",'\n\t#include "sampleCatmullRomPS"\n\t#include "screenDepthPS"\n\tvar sourceTexture: texture_2d<f32>;\n\tvar sourceTextureSampler: sampler;\n\tvar historyTexture: texture_2d<f32>;\n\tvar historyTextureSampler: sampler;\n\tuniform matrix_viewProjectionPrevious: mat4x4f;\n\tuniform matrix_viewProjectionInverse: mat4x4f;\n\tuniform jitters: vec4f;\n\tuniform textureSize: vec2f;\n\tvarying uv0: vec2f;\n\tfn reproject(uv: vec2f, depth: f32) -> vec2f {\n\t\tvar ndc = vec4f(uv * 2.0 - 1.0, depth, 1.0);\n\t\tndc = vec4f(ndc.xy - uniform.jitters.xy, ndc.zw);\n\t\tvar worldPosition = uniform.matrix_viewProjectionInverse * ndc;\n\t\tworldPosition = worldPosition / worldPosition.w;\n\t\tlet screenPrevious = uniform.matrix_viewProjectionPrevious * worldPosition;\n\t\treturn (screenPrevious.xy / screenPrevious.w) * 0.5 + 0.5;\n\t}\n\tfn colorClamp(uv: vec2f, historyColor: vec4f) -> vec4f {\n\t\tvar minColor = vec3f(9999.0);\n\t\tvar maxColor = vec3f(-9999.0);\n\t\tfor (var ix: i32 = -1; ix <= 1; ix = ix + 1) {\n\t\t\tfor (var iy: i32 = -1; iy <= 1; iy = iy + 1) {\n\t\t\t\tlet color_sample = textureSample(sourceTexture, sourceTextureSampler, uv + vec2f(f32(ix), f32(iy)) / uniform.textureSize).rgb;\n\t\t\t\tminColor = min(minColor, color_sample);\n\t\t\t\tmaxColor = max(maxColor, color_sample);\n\t\t\t}\n\t\t}\n\t\tlet clamped = clamp(historyColor.rgb, minColor, maxColor);\n\t\treturn vec4f(clamped, historyColor.a);\n\t}\n\t@fragment\n\tfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n\t\tvar output: FragmentOutput;\n\t\tvar uv = input.uv0;\n\t\tuv.y = 1.0 - uv.y;\n\t\tlet srcColor = textureSample(sourceTexture, sourceTextureSampler, uv);\n\t\tlet linearDepth = getLinearScreenDepth(uv0);\n\t\tlet depth = delinearizeDepth(linearDepth);\n\t\tlet historyUv = reproject(uv0, depth);\n\t\t#ifdef QUALITY_HIGH\n\t\t\tvar historyColor: vec4f = SampleTextureCatmullRom(historyTexture, historyTextureSampler, historyUv, uniform.textureSize);\n\t\t#else\n\t\t\tvar historyColor: vec4f = textureSample(historyTexture, historyTextureSampler, historyUv);\n\t\t#endif\n\t\tlet historyColorClamped = colorClamp(uv, historyColor);\n\t\tlet mixFactor_condition = historyUv.x < 0.0 || historyUv.x > 1.0 || historyUv.y < 0.0 || historyUv.y > 1.0;\n\t\tlet mixFactor = select(0.05, 1.0, mixFactor_condition);\n\t\toutput.color = mix(historyColorClamped, srcColor, mixFactor);\n\t\treturn output;\n\t}\n');const r=new Map;r.set("QUALITY_HIGH",!0),g.lo.addScreenDepthChunkDefines(e,n.shaderParams,r),this.shader=g.lo.createShader(e,{uniqueName:"TaaResolveShader",attributes:{aPosition:o.JYe},vertexChunk:"quadVS",fragmentChunk:"taaResolvePS",fragmentDefines:r});const{scope:s}=e;this.sourceTextureId=s.resolve("sourceTexture"),this.textureSizeId=s.resolve("textureSize"),this.textureSize=new Float32Array(2),this.historyTextureId=s.resolve("historyTexture"),this.viewProjPrevId=s.resolve("matrix_viewProjectionPrevious"),this.viewProjInvId=s.resolve("matrix_viewProjectionInverse"),this.jittersId=s.resolve("jitters"),this.cameraParams=new Float32Array(4),this.cameraParamsId=s.resolve("camera_params"),this.setup()}destroy(){this.renderTarget&&(this.renderTarget.destroyTextureBuffers(),this.renderTarget.destroy(),this.renderTarget=null)}setup(){for(let e=0;e<2;++e)this.historyTextures[e]=new l.g(this.device,{name:`TAA-History-${e}`,width:4,height:4,format:this.sourceTexture.format,mipmaps:!1,minFilter:o.DrA,magFilter:o.DrA,addressU:o.vq6,addressV:o.vq6}),this.historyRenderTargets[e]=new h.O({colorBuffer:this.historyTextures[e],depth:!1});this.historyTexture=this.historyTextures[0],this.init(this.historyRenderTargets[0],{resizeSource:this.sourceTexture})}before(){this.sourceTextureId.setValue(this.sourceTexture),this.historyTextureId.setValue(this.historyTextures[1-this.historyIndex]),this.textureSize[0]=this.sourceTexture.width,this.textureSize[1]=this.sourceTexture.height,this.textureSizeId.setValue(this.textureSize);const e=this.cameraComponent.camera;this.viewProjPrevId.setValue(e._viewProjPrevious.data),this.viewProjInvId.setValue(e._viewProjInverse.data),this.jittersId.setValue(e._jitters);const t=e._farClip;this.cameraParams[0]=1/t,this.cameraParams[1]=t,this.cameraParams[2]=e._nearClip,this.cameraParams[3]=e.projection===u.RDY?1:0,this.cameraParamsId.setValue(this.cameraParams)}update(){return this.historyIndex=1-this.historyIndex,this.historyTexture=this.historyTextures[this.historyIndex],this.renderTarget=this.historyRenderTargets[this.historyIndex],this.historyTexture}}class D extends x{constructor(e,t,n){super(e),this.cameraComponent=t,y.W.get(e,o.BzK).set("cocPS",'\n\t#include "screenDepthPS"\n\tvarying vec2 uv0;\n\tuniform vec3 params;\n\tvoid main()\n\t{\n\t\tfloat depth = getLinearScreenDepth(uv0);\n\t\tfloat focusDistance = params.x;\n\t\tfloat focusRange = params.y;\n\t\tfloat invRange = params.z;\n\t\tfloat farRange = focusDistance + focusRange * 0.5;\n\t\t\n\t\tfloat cocFar = min((depth - farRange) * invRange, 1.0);\n\t\t#ifdef NEAR_BLUR\n\t\t\tfloat nearRange = focusDistance - focusRange * 0.5;\n\t\t\tfloat cocNear = min((nearRange - depth) * invRange, 1.0);\n\t\t#else\n\t\t\tfloat cocNear = 0.0;\n\t\t#endif\n\t\tgl_FragColor = vec4(cocFar, cocNear, 0.0, 0.0);\n\t}\n'),y.W.get(e,o.g80).set("cocPS",'\n#include "screenDepthPS"\nvarying uv0: vec2f;\nuniform params: vec3f;\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n\tvar output: FragmentOutput;\n\tlet depth: f32 = getLinearScreenDepth(uv0);\n\tlet focusDistance: f32 = uniform.params.x;\n\tlet focusRange: f32 = uniform.params.y;\n\tlet invRange: f32 = uniform.params.z;\n\tlet farRange: f32 = focusDistance + focusRange * 0.5;\n\tlet cocFar: f32 = min((depth - farRange) * invRange, 1.0);\n\t#ifdef NEAR_BLUR\n\t\tlet nearRange: f32 = focusDistance - focusRange * 0.5;\n\t\tvar cocNear: f32 = min((nearRange - depth) * invRange, 1.0);\n\t#else\n\t\tvar cocNear: f32 = 0.0;\n\t#endif\n\toutput.color = vec4f(cocFar, cocNear, 0.0, 0.0);\n\treturn output;\n}\n');const r=new Map;n&&r.set("NEAR_BLUR",""),g.lo.addScreenDepthChunkDefines(e,t.shaderParams,r),this.shader=g.lo.createShader(e,{uniqueName:`CocShader-${n}`,attributes:{aPosition:o.JYe},vertexChunk:"quadVS",fragmentChunk:"cocPS",fragmentDefines:r}),this.paramsId=e.scope.resolve("params"),this.paramsValue=new Float32Array(3),this.cameraParams=new Float32Array(4),this.cameraParamsId=e.scope.resolve("camera_params")}execute(){const{paramsValue:e,focusRange:t}=this;e[0]=this.focusDistance+.001,e[1]=t,e[2]=1/t,this.paramsId.setValue(e);const n=this.cameraComponent.camera,r=n._farClip;this.cameraParams[0]=1/r,this.cameraParams[1]=r,this.cameraParams[2]=n._nearClip,this.cameraParams[3]=n.projection===u.RDY?1:0,this.cameraParamsId.setValue(this.cameraParams),super.execute()}}class I{static concentric(e,t){const n=[];n.push(0,0);const r=2*Math.PI/e/t;for(let s=1;s<=e;s++){const t=s/e,i=2*Math.PI*t,o=Math.max(1,Math.floor(i/r)),a=2*Math.PI/o;for(let e=0;e<o;e++){const r=e*a,s=t*Math.cos(r),i=t*Math.sin(r);n.push(s,i)}}return n}}class w extends x{constructor(e,t,n,r){super(e),this.blurRadiusNear=1,this.blurRadiusFar=1,this._blurRings=3,this._blurRingPoints=3,this.nearTexture=t,this.farTexture=n,this.cocTexture=r,y.W.get(e,o.BzK).set("dofBlurPS","\n\t#if defined(NEAR_BLUR)\n\t\tuniform sampler2D nearTexture;\n\t#endif\n\tuniform sampler2D farTexture;\n\tuniform sampler2D cocTexture;\n\tuniform vec2 kernel[{KERNEL_COUNT}];\n\tuniform float blurRadiusNear;\n\tuniform float blurRadiusFar;\n\tvarying vec2 uv0;\n\tvoid main()\n\t{\n\t\tvec2 coc = texture2D(cocTexture, uv0).rg;\n\t\tfloat cocFar = coc.r;\n\t\tvec3 sum = vec3(0.0, 0.0, 0.0);\n\t\t#if defined(NEAR_BLUR)\n\t\t\tfloat cocNear = coc.g;\n\t\t\tif (cocNear > 0.0001) {\n\t\t\t\tivec2 nearTextureSize = textureSize(nearTexture, 0);\n\t\t\t\tvec2 step = cocNear * blurRadiusNear / vec2(nearTextureSize);\n\t\t\t\tfor (int i = 0; i < {KERNEL_COUNT}; i++) {\n\t\t\t\t\tvec2 uv = uv0 + step * kernel[i];\n\t\t\t\t\tvec3 tap = texture2DLod(nearTexture, uv, 0.0).rgb;\n\t\t\t\t\tsum += tap.rgb;\n\t\t\t\t}\n\t\t\t\tsum *= float({INV_KERNEL_COUNT});\n\t\t\t} else\n\t\t#endif\n\t\t\t\n\t\t\tif (cocFar > 0.0001) {\n\t\t\tivec2 farTextureSize = textureSize(farTexture, 0);\n\t\t\tvec2 step = cocFar * blurRadiusFar / vec2(farTextureSize);\n\t\t\tfloat sumCoC = 0.0; \n\t\t\tfor (int i = 0; i < {KERNEL_COUNT}; i++) {\n\t\t\t\tvec2 uv = uv0 + step * kernel[i];\n\t\t\t\tvec3 tap = texture2DLod(farTexture, uv, 0.0).rgb;\n\t\t\t\tfloat cocThis = texture2DLod(cocTexture, uv, 0.0).r;\n\t\t\t\ttap *= cocThis;\n\t\t\t\tsumCoC += cocThis;\n\t\t\t\tsum += tap;\n\t\t\t}\n\t\t\tif (sumCoC > 0.0)\n\t\t\t\tsum /= sumCoC;\n\t\t\tsum /= cocFar;\n\t\t}\n\t\tpcFragColor0 = vec4(sum, 1.0);\n\t}\n"),y.W.get(e,o.g80).set("dofBlurPS","\n#if defined(NEAR_BLUR)\n\tvar nearTexture: texture_2d<f32>;\n\tvar nearTextureSampler: sampler;\n#endif\nvar farTexture: texture_2d<f32>;\nvar farTextureSampler: sampler;\nvar cocTexture: texture_2d<f32>;\nvar cocTextureSampler: sampler;\nuniform kernel: array<vec2f, {KERNEL_COUNT}>;\nuniform blurRadiusNear: f32;\nuniform blurRadiusFar: f32;\nvarying uv0: vec2f;\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n\tvar output: FragmentOutput;\n\tlet coc: vec2f = textureSample(cocTexture, cocTextureSampler, input.uv0).rg;\n\tlet cocFar: f32 = coc.r;\n\tvar sum: vec3f = vec3f(0.0, 0.0, 0.0);\n\t#if defined(NEAR_BLUR)\n\t\tlet cocNear: f32 = coc.g;\n\t\tif (cocNear > 0.0001) {\n\t\t\tlet nearTextureSize: vec2f = vec2f(textureDimensions(nearTexture, 0));\n\t\t\tlet step: vec2f = cocNear * uniform.blurRadiusNear / nearTextureSize;\n\t\t\tfor (var i: i32 = 0; i < {KERNEL_COUNT}; i = i + 1) {\n\t\t\t\tlet uv: vec2f = uv0 + step * uniform.kernel[i].element;\n\t\t\t\tlet tap: vec3f = textureSampleLevel(nearTexture, nearTextureSampler, uv, 0.0).rgb;\n\t\t\t\tsum = sum + tap;\n\t\t\t}\n\t\t\tsum = sum * f32({INV_KERNEL_COUNT});\n\t\t} else\n\t#endif\n\t\tif (cocFar > 0.0001) {\n\t\t\tlet farTextureSize: vec2f = vec2f(textureDimensions(farTexture, 0));\n\t\t\tlet step: vec2f = cocFar * uniform.blurRadiusFar / farTextureSize;\n\t\t\tvar sumCoC: f32 = 0.0;\n\t\t\tfor (var i: i32 = 0; i < {KERNEL_COUNT}; i = i + 1) {\n\t\t\t\tlet uv: vec2f = uv0 + step * uniform.kernel[i].element;\n\t\t\t\tvar tap: vec3f = textureSampleLevel(farTexture, farTextureSampler, uv, 0.0).rgb;\n\t\t\t\tlet cocThis: f32 = textureSampleLevel(cocTexture, cocTextureSampler, uv, 0.0).r;\n\t\t\t\ttap = tap * cocThis;\n\t\t\t\tsumCoC = sumCoC + cocThis;\n\t\t\t\tsum = sum + tap;\n\t\t\t}\n\t\t\tif (sumCoC > 0.0) {\n\t\t\t\tsum = sum / sumCoC;\n\t\t\t}\n\t\t\tsum = sum / cocFar;\n\t\t}\n\toutput.color = vec4f(sum, 1.0);\n\treturn output;\n}\n");const{scope:s}=e;this.kernelId=s.resolve("kernel[0]"),this.kernelCountId=s.resolve("kernelCount"),this.blurRadiusNearId=s.resolve("blurRadiusNear"),this.blurRadiusFarId=s.resolve("blurRadiusFar"),this.nearTextureId=s.resolve("nearTexture"),this.farTextureId=s.resolve("farTexture"),this.cocTextureId=s.resolve("cocTexture")}set blurRings(e){this._blurRings!==e&&(this._blurRings=e,this.shader=null)}get blurRings(){return this._blurRings}set blurRingPoints(e){this._blurRingPoints!==e&&(this._blurRingPoints=e,this.shader=null)}get blurRingPoints(){return this._blurRingPoints}createShader(){this.kernel=new Float32Array(I.concentric(this.blurRings,this.blurRingPoints));const e=this.kernel.length>>1,t=null!==this.nearTexture,n=new Map;n.set("{KERNEL_COUNT}",e),n.set("{INV_KERNEL_COUNT}",1/e),t&&n.set("NEAR_BLUR",""),this.shader=g.lo.createShader(this.device,{uniqueName:`DofBlurShader-${e}-${t?"nearBlur":"noNearBlur"}`,attributes:{aPosition:o.JYe},vertexChunk:"quadVS",fragmentChunk:"dofBlurPS",fragmentDefines:n})}execute(){this.shader||this.createShader(),this.nearTextureId.setValue(this.nearTexture),this.farTextureId.setValue(this.farTexture),this.cocTextureId.setValue(this.cocTexture),this.kernelId.setValue(this.kernel),this.kernelCountId.setValue(this.kernel.length>>1),this.blurRadiusNearId.setValue(this.blurRadiusNear),this.blurRadiusFarId.setValue(this.blurRadiusFar),super.execute()}}class L extends c.A{constructor(e,t,n,r,s,i){super(e),this.focusDistance=100,this.focusRange=50,this.blurRadius=1,this.blurRings=3,this.blurRingPoints=3,this.highQuality=!0,this.cocTexture=null,this.blurTexture=null,this.cocPass=null,this.farPass=null,this.blurPass=null,this.highQuality=s,this.cocPass=this.setupCocPass(e,t,n,i),this.beforePasses.push(this.cocPass);const o=s?n:r;this.farPass=this.setupFarPass(e,o,.5),this.beforePasses.push(this.farPass),this.blurPass=this.setupBlurPass(e,r,i,s?2:.5),this.beforePasses.push(this.blurPass)}destroy(){this.destroyRenderPasses(),this.cocPass=null,this.farPass=null,this.blurPass=null,this.destroyRT(this.cocRT),this.destroyRT(this.farRt),this.destroyRT(this.blurRt),this.cocRT=null,this.farRt=null,this.blurRt=null}destroyRenderPasses(){for(let e=0;e<this.beforePasses.length;e++)this.beforePasses[e].destroy();this.beforePasses.length=0}destroyRT(e){e&&(e.destroyTextureBuffers(),e.destroy())}setupCocPass(e,t,n,s){const i=s?o.MqB:o.FfR;this.cocRT=this.createRenderTarget("CoCTexture",i),this.cocTexture=this.cocRT.colorBuffer;const a=new D(e,t,s);return a.init(this.cocRT,{resizeSource:n}),a.setClearColor(r.Q.BLACK),a}setupFarPass(e,t,n){this.farRt=this.createRenderTarget("FarDofTexture",t.format);const s=new T(e,t,{boxFilter:!0,premultiplyTexture:this.cocTexture,premultiplySrcChannel:"r"});return s.init(this.farRt,{resizeSource:t,scaleX:n,scaleY:n}),s.setClearColor(r.Q.BLACK),s}setupBlurPass(e,t,n,s){const i=this.farRt?.colorBuffer;this.blurRt=this.createRenderTarget("DofBlurTexture",t.format),this.blurTexture=this.blurRt.colorBuffer;const o=new w(e,n?t:null,i,this.cocTexture);return o.init(this.blurRt,{resizeSource:t,scaleX:s,scaleY:s}),o.setClearColor(r.Q.BLACK),o}createTexture(e,t){return new l.g(this.device,{name:e,width:1,height:1,format:t,mipmaps:!1,minFilter:o.DrA,magFilter:o.DrA,addressU:o.vq6,addressV:o.vq6})}createRenderTarget(e,t){return new h.O({colorBuffer:this.createTexture(e,t),depth:!1,stencil:!1})}frameUpdate(){super.frameUpdate(),this.cocPass.focusDistance=this.focusDistance,this.cocPass.focusRange=this.focusRange,this.blurPass.blurRadiusNear=this.blurRadius,this.blurPass.blurRadiusFar=this.blurRadius*(this.highQuality?1:.5),this.blurPass.blurRings=this.blurRings,this.blurPass.blurRingPoints=this.blurRingPoints}}var E=n(33984);const O=[];class A extends c.A{constructor(e,t,n,s,i){super(e),this.viewBindGroups=[],this.linearDepthClearValue=new r.Q(0,0,0,0),this.scene=t,this.renderer=n,this.camera=s,this.setupRenderTarget(i)}destroy(){super.destroy(),this.renderTarget?.destroy(),this.renderTarget=null,this.linearDepthTexture?.destroy(),this.linearDepthTexture=null,this.viewBindGroups.forEach(e=>{e.defaultUniformBuffer.destroy(),e.destroy()}),this.viewBindGroups.length=0}setupRenderTarget(e){const{device:t}=this;this.linearDepthFormat=t.textureFloatRenderable?o.IQA:o.Lxj,this.linearDepthTexture=new l.g(t,{name:"SceneLinearDepthTexture",width:1,height:1,format:this.linearDepthFormat,mipmaps:!1,minFilter:o.uhC,magFilter:o.uhC,addressU:o.vq6,addressV:o.vq6});const n=new h.O({name:"PrepassRT",colorBuffer:this.linearDepthTexture,depth:!0,samples:1});this.camera.shaderParams.sceneDepthMapLinear=!0,this.init(n,e)}after(){this.device.scope.resolve("uSceneDepthMap").setValue(this.linearDepthTexture)}execute(){const{renderer:e,scene:t,renderTarget:n}=this,r=this.camera.camera,s=t.layers.layerList,i=t.layers.subLayerEnabled,o=t.layers.subLayerList;for(let a=0;a<s.length;a++){const t=s[a];if(t.id===u.$9T)break;if(t.enabled&&i[a]&&t.camerasSet.has(r)){const s=t.getCulledInstances(r),i=o[a]?s.transparent:s.opaque;for(let e=0;e<i.length;e++){const t=i[e];t.material?.depthWrite&&O.push(t)}e.renderForwardLayer(r,n,null,void 0,u.pP7,this.viewBindGroups,{meshInstances:O}),O.length=0}}}frameUpdate(){super.frameUpdate();const{camera:e}=this;let t;if(this.setClearDepth(e.clearDepthBuffer?1:void 0),e.clearDepthBuffer){const n=e.farClip-Number.MIN_VALUE;t=this.linearDepthClearValue,this.linearDepthFormat===o.IQA?t.r=n:E.A.float2RGBA8(n,t)}this.setClearColor(t)}}var F=n(60017);class U extends x{constructor(e,t,n,r){super(e),this.sourceTexture=t,y.W.get(e,o.BzK).set("depthAwareBlurPS",'\n\t#include "screenDepthPS"\n\tvarying vec2 uv0;\n\tuniform sampler2D sourceTexture;\n\tuniform vec2 sourceInvResolution;\n\tuniform int filterSize;\n\tfloat random(const highp vec2 w) {\n\t\tconst vec3 m = vec3(0.06711056, 0.00583715, 52.9829189);\n\t\treturn fract(m.z * fract(dot(w, m.xy)));\n\t}\n\tmediump float bilateralWeight(in mediump float depth, in mediump float sampleDepth) {\n\t\tmediump float diff = (sampleDepth - depth);\n\t\treturn max(0.0, 1.0 - diff * diff);\n\t}\n\tvoid tap(inout float sum, inout float totalWeight, float weight, float depth, vec2 position) {\n\t\tmediump float color = texture2D(sourceTexture, position).r;\n\t\tmediump float textureDepth = -getLinearScreenDepth(position);\n\t\n\t\tmediump float bilateral = bilateralWeight(depth, textureDepth);\n\t\tbilateral *= weight;\n\t\tsum += color * bilateral;\n\t\ttotalWeight += bilateral;\n\t}\n\tvoid main() {\n\t\tmediump float depth = -getLinearScreenDepth(uv0);\n\t\tmediump float totalWeight = 1.0;\n\t\tmediump float color = texture2D(sourceTexture, uv0 ).r;\n\t\tmediump float sum = color * totalWeight;\n\t\tfor (mediump int i = -filterSize; i <= filterSize; i++) {\n\t\t\tmediump float weight = 1.0;\n\t\t\t#ifdef HORIZONTAL\n\t\t\t\tvec2 offset = vec2(i, 0) * sourceInvResolution;\n\t\t\t#else\n\t\t\t\tvec2 offset = vec2(0, i) * sourceInvResolution;\n\t\t\t#endif\n\t\t\ttap(sum, totalWeight, weight, depth, uv0 + offset);\n\t\t}\n\t\tmediump float ao = sum / totalWeight;\n\t\tgl_FragColor.r = ao;\n\t}\n'),y.W.get(e,o.g80).set("depthAwareBlurPS",'\n#include "screenDepthPS"\nvarying uv0: vec2f;\nvar sourceTexture: texture_2d<f32>;\nvar sourceTextureSampler: sampler;\nuniform sourceInvResolution: vec2f;\nuniform filterSize: i32;\nfn random(w: vec2f) -> f32 {\n\tconst m: vec3f = vec3f(0.06711056, 0.00583715, 52.9829189);\n\treturn fract(m.z * fract(dot(w, m.xy)));\n}\nfn bilateralWeight(depth: f32, sampleDepth: f32) -> f32 {\n\tlet diff: f32 = (sampleDepth - depth);\n\treturn max(0.0, 1.0 - diff * diff);\n}\nfn tap(sum_ptr: ptr<function, f32>, totalWeight_ptr: ptr<function, f32>, weight: f32, depth: f32, position: vec2f) {\n\tlet color: f32 = textureSample(sourceTexture, sourceTextureSampler, position).r;\n\tlet textureDepth: f32 = -getLinearScreenDepth(position);\n\tlet bilateral: f32 = bilateralWeight(depth, textureDepth) * weight;\n\t*sum_ptr = *sum_ptr + color * bilateral;\n\t*totalWeight_ptr = *totalWeight_ptr + bilateral;\n}\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n\tvar output: FragmentOutput;\n\tlet depth: f32 = -getLinearScreenDepth(input.uv0);\n\tvar totalWeight: f32 = 1.0;\n\tlet color: f32 = textureSample(sourceTexture, sourceTextureSampler, input.uv0 ).r;\n\tvar sum: f32 = color * totalWeight;\n\tfor (var i: i32 = -uniform.filterSize; i <= uniform.filterSize; i = i + 1) {\n\t\tlet weight: f32 = 1.0;\n\t\t#ifdef HORIZONTAL\n\t\t\tvar offset: vec2f = vec2f(f32(i), 0.0) * uniform.sourceInvResolution;\n\t\t#else\n\t\t\tvar offset: vec2f = vec2f(0.0, f32(i)) * uniform.sourceInvResolution;\n\t\t#endif\n\t\ttap(&sum, &totalWeight, weight, depth, input.uv0 + offset);\n\t}\n\tlet ao: f32 = sum / totalWeight;\n\toutput.color = vec4f(ao, ao, ao, 1.0);\n\treturn output;\n}\n');const s=new Map;r&&s.set("HORIZONTAL",""),g.lo.addScreenDepthChunkDefines(e,n.shaderParams,s),this.shader=g.lo.createShader(e,{uniqueName:`DepthAware${r?"Horizontal":"Vertical"}BlurShader`,attributes:{aPosition:o.JYe},vertexChunk:"quadVS",fragmentChunk:"depthAwareBlurPS",fragmentDefines:s});const i=this.device.scope;this.sourceTextureId=i.resolve("sourceTexture"),this.sourceInvResolutionId=i.resolve("sourceInvResolution"),this.sourceInvResolutionValue=new Float32Array(2),this.filterSizeId=i.resolve("filterSize")}execute(){this.filterSizeId.setValue(4),this.sourceTextureId.setValue(this.sourceTexture);const{width:e,height:t}=this.sourceTexture;this.sourceInvResolutionValue[0]=1/e,this.sourceInvResolutionValue[1]=1/t,this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue),super.execute()}}class B extends x{constructor(e,t,n,s){super(e),this.radius=5,this.intensity=1,this.power=1,this.sampleCount=10,this.minAngle=5,this.randomize=!1,this._scale=1,this._blueNoise=new F.d(19),this.sourceTexture=t,this.cameraComponent=n,y.W.get(e,o.BzK).set("ssaoPS",'\n\t#include "screenDepthPS"\n\t\n\tvarying vec2 uv0;\n\tuniform vec2 uInvResolution;\n\tuniform float uAspect;\n\t#define saturate(x) clamp(x,0.0,1.0)\n\thighp float getWFromProjectionMatrix(const mat4 p, const vec3 v) {\n\t\treturn -v.z;\n\t}\n\thighp float getViewSpaceZFromW(const mat4 p, const float w) {\n\t\treturn -w;\n\t}\n\tconst float kLog2LodRate = 3.0;\n\tfloat random(const highp vec2 w) {\n\t\tconst vec3 m = vec3(0.06711056, 0.00583715, 52.9829189);\n\t\treturn fract(m.z * fract(dot(w, m.xy)));\n\t}\n\thighp vec2 getFragCoord() {\n\t\treturn gl_FragCoord.xy;\n\t}\n\thighp vec3 computeViewSpacePositionFromDepth(highp vec2 uv, highp float linearDepth) {\n\t\treturn vec3((0.5 - uv) * vec2(uAspect, 1.0) * linearDepth, linearDepth);\n\t}\n\thighp vec3 faceNormal(highp vec3 dpdx, highp vec3 dpdy) {\n\t\treturn normalize(cross(dpdx, dpdy));\n\t}\n\thighp vec3 computeViewSpaceNormal(const highp vec3 position) {\n\t\treturn faceNormal(dFdx(position), dFdy(position));\n\t}\n\thighp vec3 computeViewSpaceNormal(const highp vec3 position, const highp vec2 uv) {\n\t\thighp vec2 uvdx = uv + vec2(uInvResolution.x, 0.0);\n\t\thighp vec2 uvdy = uv + vec2(0.0, uInvResolution.y);\n\t\thighp vec3 px = computeViewSpacePositionFromDepth(uvdx, -getLinearScreenDepth(uvdx));\n\t\thighp vec3 py = computeViewSpacePositionFromDepth(uvdy, -getLinearScreenDepth(uvdy));\n\t\thighp vec3 dpdx = px - position;\n\t\thighp vec3 dpdy = py - position;\n\t\treturn faceNormal(dpdx, dpdy);\n\t}\n\tuniform vec2 uSampleCount;\n\tuniform float uSpiralTurns;\n\t#define PI (3.14159)\n\tmediump vec3 tapLocation(mediump float i, const mediump float noise) {\n\t\tmediump float offset = ((2.0 * PI) * 2.4) * noise;\n\t\tmediump float angle = ((i * uSampleCount.y) * uSpiralTurns) * (2.0 * PI) + offset;\n\t\tmediump float radius = (i + noise + 0.5) * uSampleCount.y;\n\t\treturn vec3(cos(angle), sin(angle), radius * radius);\n\t}\n\thighp vec2 startPosition(const float noise) {\n\t\tfloat angle = ((2.0 * PI) * 2.4) * noise;\n\t\treturn vec2(cos(angle), sin(angle));\n\t}\n\tuniform vec2 uAngleIncCosSin;\n\thighp mat2 tapAngleStep() {\n\t\thighp vec2 t = uAngleIncCosSin;\n\t\treturn mat2(t.x, t.y, -t.y, t.x);\n\t}\n\tmediump vec3 tapLocationFast(mediump float i, mediump vec2 p, const mediump float noise) {\n\t\tmediump float radius = (i + noise + 0.5) * uSampleCount.y;\n\t\treturn vec3(p, radius * radius);\n\t}\n\tuniform float uMaxLevel;\n\tuniform float uInvRadiusSquared;\n\tuniform float uMinHorizonAngleSineSquared;\n\tuniform float uBias;\n\tuniform float uPeak2;\n\tvoid computeAmbientOcclusionSAO(inout mediump float occlusion, mediump float i, mediump float ssDiskRadius,\n\t\t\tconst highp vec2 uv, const highp vec3 origin, const mediump vec3 normal,\n\t\t\tconst mediump vec2 tapPosition, const float noise) {\n\t\tmediump vec3 tap = tapLocationFast(i, tapPosition, noise);\n\t\tmediump float ssRadius = max(1.0, tap.z * ssDiskRadius);\n\t\tmediump vec2 uvSamplePos = uv + vec2(ssRadius * tap.xy) * uInvResolution;\n\t\tmediump float level = clamp(floor(log2(ssRadius)) - kLog2LodRate, 0.0, float(uMaxLevel));\n\t\thighp float occlusionDepth = -getLinearScreenDepth(uvSamplePos);\n\t\thighp vec3 p = computeViewSpacePositionFromDepth(uvSamplePos, occlusionDepth);\n\t\tvec3 v = p - origin;\n\t\tfloat vv = dot(v, v);\n\t\tfloat vn = dot(v, normal);\n\t\tmediump float w = max(0.0, 1.0 - vv * uInvRadiusSquared);\n\t\tw = w * w;\n\t\tw *= step(vv * uMinHorizonAngleSineSquared, vn * vn);\n\t\tocclusion += w * max(0.0, vn + origin.z * uBias) / (vv + uPeak2);\n\t}\n\tuniform float uProjectionScaleRadius;\n\tuniform float uIntensity;\n\tuniform float uRandomize;\n\tfloat scalableAmbientObscurance(highp vec2 uv, highp vec3 origin, vec3 normal) {\n\t\tfloat noise = random(getFragCoord()) + uRandomize;\n\t\thighp vec2 tapPosition = startPosition(noise);\n\t\thighp mat2 angleStep = tapAngleStep();\n\t\tfloat ssDiskRadius = -(uProjectionScaleRadius / origin.z);\n\t\tfloat occlusion = 0.0;\n\t\tfor (float i = 0.0; i < uSampleCount.x; i += 1.0) {\n\t\t\tcomputeAmbientOcclusionSAO(occlusion, i, ssDiskRadius, uv, origin, normal, tapPosition, noise);\n\t\t\ttapPosition = angleStep * tapPosition;\n\t\t}\n\t\treturn occlusion;\n\t}\n\tuniform float uPower;\n\tvoid main() {\n\t\thighp vec2 uv = uv0;\n\t\thighp float depth = -getLinearScreenDepth(uv0);\n\t\thighp vec3 origin = computeViewSpacePositionFromDepth(uv, depth);\n\t\tvec3 normal = computeViewSpaceNormal(origin, uv);\n\t\tfloat occlusion = 0.0;\n\t\tif (uIntensity > 0.0) {\n\t\t\tocclusion = scalableAmbientObscurance(uv, origin, normal);\n\t\t}\n\t\tfloat ao = max(0.0, 1.0 - occlusion * uIntensity);\n\t\tao = pow(ao, uPower);\n\t\tgl_FragColor = vec4(ao, ao, ao, 1.0);\n\t}\n'),y.W.get(e,o.g80).set("ssaoPS",'\n\t#include "screenDepthPS"\n\tvarying uv0: vec2f;\n\tuniform uInvResolution: vec2f;\n\tuniform uAspect: f32;\n\tfn getWFromProjectionMatrix(p: mat4x4f, v: vec3f) -> f32 {\n\t\treturn -v.z;\n\t}\n\tfn getViewSpaceZFromW(p: mat4x4f, w: f32) -> f32 {\n\t\treturn -w;\n\t}\n\tconst kLog2LodRate: f32 = 3.0;\n\tfn random(w: vec2f) -> f32 {\n\t\tconst m: vec3f = vec3f(0.06711056, 0.00583715, 52.9829189);\n\t\treturn fract(m.z * fract(dot(w, m.xy)));\n\t}\n\tfn getFragCoord() -> vec2f {\n\t\treturn pcPosition.xy;\n\t}\n\tfn computeViewSpacePositionFromDepth(uv: vec2f, linearDepth: f32) -> vec3f {\n\t\treturn vec3f((0.5 - uv) * vec2f(uniform.uAspect, 1.0) * linearDepth, linearDepth);\n\t}\n\tfn faceNormal(dpdx: vec3f, dpdy: vec3f) -> vec3f {\n\t\treturn normalize(cross(dpdx, dpdy));\n\t}\n\tfn computeViewSpaceNormalDeriv(position: vec3f) -> vec3f {\n\t\treturn faceNormal(dpdx(position), dpdy(position));\n\t}\n\tfn computeViewSpaceNormalDepth(position: vec3f, uv: vec2f) -> vec3f {\n\t\tlet uvdx: vec2f = uv + vec2f(uniform.uInvResolution.x, 0.0);\n\t\tlet uvdy: vec2f = uv + vec2f(0.0, uniform.uInvResolution.y);\n\t\tlet px: vec3f = computeViewSpacePositionFromDepth(uvdx, -getLinearScreenDepth(uvdx));\n\t\tlet py: vec3f = computeViewSpacePositionFromDepth(uvdy, -getLinearScreenDepth(uvdy));\n\t\tlet dpdx: vec3f = px - position;\n\t\tlet dpdy: vec3f = py - position;\n\t\treturn faceNormal(dpdx, dpdy);\n\t}\n\tuniform uSampleCount: vec2f;\n\tuniform uSpiralTurns: f32;\n\tconst PI: f32 = 3.14159;\n\tfn tapLocation(i: f32, noise: f32) -> vec3f {\n\t\tlet offset: f32 = ((2.0 * PI) * 2.4) * noise;\n\t\tlet angle: f32 = ((i * uniform.uSampleCount.y) * uniform.uSpiralTurns) * (2.0 * PI) + offset;\n\t\tlet radius: f32 = (i + noise + 0.5) * uniform.uSampleCount.y;\n\t\treturn vec3f(cos(angle), sin(angle), radius * radius);\n\t}\n\tfn startPosition(noise: f32) -> vec2f {\n\t\tlet angle: f32 = ((2.0 * PI) * 2.4) * noise;\n\t\treturn vec2f(cos(angle), sin(angle));\n\t}\n\tuniform uAngleIncCosSin: vec2f;\n\tfn tapAngleStep() -> mat2x2f {\n\t\tlet t: vec2f = uniform.uAngleIncCosSin;\n\t\treturn mat2x2f(vec2f(t.x, t.y), vec2f(-t.y, t.x));\n\t}\n\tfn tapLocationFast(i: f32, p: vec2f, noise_in: f32) -> vec3f {\n\t\tlet radius: f32 = (i + noise_in + 0.5) * uniform.uSampleCount.y;\n\t\treturn vec3f(p.x, p.y, radius * radius);\n\t}\n\tuniform uMaxLevel: f32;\n\tuniform uInvRadiusSquared: f32;\n\tuniform uMinHorizonAngleSineSquared: f32;\n\tuniform uBias: f32;\n\tuniform uPeak2: f32;\n\tfn computeAmbientOcclusionSAO(occlusion_ptr: ptr<function, f32>, i: f32, ssDiskRadius: f32,\n\t\t\tuv: vec2f, origin: vec3f, normal: vec3f,\n\t\t\ttapPosition: vec2f, noise: f32) {\n\t\tlet tap: vec3f = tapLocationFast(i, tapPosition, noise);\n\t\tlet ssRadius: f32 = max(1.0, tap.z * ssDiskRadius);\n\t\tlet uvSamplePos: vec2f = uv + (ssRadius * tap.xy) * uniform.uInvResolution;\n\t\tlet level: f32 = clamp(floor(log2(ssRadius)) - kLog2LodRate, 0.0, uniform.uMaxLevel);\n\t\tlet occlusionDepth: f32 = -getLinearScreenDepth(uvSamplePos);\n\t\tlet p: vec3f = computeViewSpacePositionFromDepth(uvSamplePos, occlusionDepth);\n\t\tlet v: vec3f = p - origin;\n\t\tlet vv: f32 = dot(v, v);\n\t\tlet vn: f32 = dot(v, normal);\n\t\tvar w_val: f32 = max(0.0, 1.0 - vv * uniform.uInvRadiusSquared);\n\t\tw_val = w_val * w_val;\n\t\tw_val = w_val * step(vv * uniform.uMinHorizonAngleSineSquared, vn * vn);\n\t\t*occlusion_ptr = *occlusion_ptr + w_val * max(0.0, vn + origin.z * uniform.uBias) / (vv + uniform.uPeak2);\n\t}\n\tuniform uProjectionScaleRadius: f32;\n\tuniform uIntensity: f32;\n\tuniform uRandomize: f32;\n\tfn scalableAmbientObscurance(uv: vec2f, origin: vec3f, normal: vec3f) -> f32 {\n\t\tlet noise: f32 = random(getFragCoord()) + uniform.uRandomize;\n\t\tvar tapPosition: vec2f = startPosition(noise);\n\t\tlet angleStep: mat2x2f = tapAngleStep();\n\t\tlet ssDiskRadius: f32 = -(uniform.uProjectionScaleRadius / origin.z);\n\t\tvar occlusion: f32 = 0.0;\n\t\tfor (var i: i32 = 0; i < i32(uniform.uSampleCount.x); i = i + 1) {\n\t\t\tcomputeAmbientOcclusionSAO(&occlusion, f32(i), ssDiskRadius, uv, origin, normal, tapPosition, noise);\n\t\t\ttapPosition = angleStep * tapPosition;\n\t\t}\n\t\treturn occlusion;\n\t}\n\tuniform uPower: f32;\n\t@fragment\n\tfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n\t\tvar output: FragmentOutput;\n\t\tlet uv: vec2f = input.uv0;\n\t\tlet depth: f32 = -getLinearScreenDepth(input.uv0);\n\t\tlet origin: vec3f = computeViewSpacePositionFromDepth(uv, depth);\n\t\tlet normal: vec3f = computeViewSpaceNormalDepth(origin, uv);\n\t\tvar occlusion: f32 = 0.0;\n\t\tif (uniform.uIntensity > 0.0) {\n\t\t\tocclusion = scalableAmbientObscurance(uv, origin, normal);\n\t\t}\n\t\tvar ao: f32 = max(0.0, 1.0 - occlusion * uniform.uIntensity);\n\t\tao = pow(ao, uniform.uPower);\n\t\toutput.color = vec4f(ao, ao, ao, 1.0);\n\t\treturn output;\n\t}\n');const i=new Map;g.lo.addScreenDepthChunkDefines(e,n.shaderParams,i),this.shader=g.lo.createShader(e,{uniqueName:"SsaoShader",attributes:{aPosition:o.JYe},vertexChunk:"quadVS",fragmentChunk:"ssaoPS",fragmentDefines:i});const a=this.createRenderTarget("SsaoFinalTexture");this.ssaoTexture=a.colorBuffer,this.init(a,{resizeSource:this.sourceTexture});const u=new r.Q(0,0,0,0);if(this.setClearColor(u),s){const t=this.createRenderTarget("SsaoTempTexture"),r=new U(e,a.colorBuffer,n,!0);r.init(t,{resizeSource:a.colorBuffer}),r.setClearColor(u);const s=new U(e,t.colorBuffer,n,!1);s.init(a,{resizeSource:a.colorBuffer}),s.setClearColor(u),this.afterPasses.push(r),this.afterPasses.push(s)}this.ssaoTextureId=e.scope.resolve("ssaoTexture"),this.ssaoTextureSizeInvId=e.scope.resolve("ssaoTextureSizeInv")}destroy(){if(this.renderTarget?.destroyTextureBuffers(),this.renderTarget?.destroy(),this.renderTarget=null,this.afterPasses.length>0){const e=this.afterPasses[0].renderTarget;e?.destroyTextureBuffers(),e?.destroy()}this.afterPasses.forEach(e=>e.destroy()),this.afterPasses.length=0,super.destroy()}set scale(e){this._scale=e,this.scaleX=e,this.scaleY=e}get scale(){return this._scale}createRenderTarget(e){return new h.O({depth:!1,colorBuffer:new l.g(this.device,{name:e,width:1,height:1,format:o.FfR,mipmaps:!1,minFilter:o.uhC,magFilter:o.uhC,addressU:o.vq6,addressV:o.vq6})})}execute(){const{device:e,sourceTexture:t,sampleCount:n,minAngle:r,scale:s}=this,{width:i,height:o}=this.renderTarget.colorBuffer,a=e.scope;a.resolve("uAspect").setValue(i/o),a.resolve("uInvResolution").setValue([1/i,1/o]),a.resolve("uSampleCount").setValue([n,1/n]);const u=Math.sin(r*Math.PI/180);a.resolve("uMinHorizonAngleSineSquared").setValue(u*u);const l=1/(n-.5)*10*2*3.141,c=this.radius/s,f=.1*c,d=2*f*3.141*2*this.intensity/n,h=.5*t.height;a.resolve("uSpiralTurns").setValue(10),a.resolve("uAngleIncCosSin").setValue([Math.cos(l),Math.sin(l)]),a.resolve("uMaxLevel").setValue(0),a.resolve("uInvRadiusSquared").setValue(1/(c*c)),a.resolve("uBias").setValue(.001),a.resolve("uPeak2").setValue(f*f),a.resolve("uIntensity").setValue(d),a.resolve("uPower").setValue(this.power),a.resolve("uProjectionScaleRadius").setValue(h*c),a.resolve("uRandomize").setValue(this.randomize?this._blueNoise.value():0),super.execute()}after(){this.ssaoTextureId.setValue(this.ssaoTexture);const e=this.sourceTexture;this.ssaoTextureSizeInvId.setValue([1/e.width,1/e.height])}}class V{constructor(){this.stencil=!1,this.samples=1,this.sceneColorMap=!1,this.lastGrabLayerId=u.CTD,this.lastGrabLayerIsTransparent=!1,this.lastSceneLayerId=u.t0Z,this.lastSceneLayerIsTransparent=!0,this.taaEnabled=!1,this.bloomEnabled=!1,this.ssaoType=a,this.ssaoBlurEnabled=!0,this.prepassEnabled=!1,this.dofEnabled=!1,this.dofNearBlur=!1,this.dofHighQuality=!0}}const M=new V;class z extends c.A{constructor(e,t,n,r={}){super(e.graphicsDevice),this._renderTargetScale=1,this.layersDirty=!1,this.rt=null,this.app=e,this.cameraComponent=n,this.cameraFrame=t,this.options=this.sanitizeOptions(r),this.setupRenderPasses(this.options)}destroy(){this.reset()}reset(){this.sceneTexture=null,this.sceneTextureHalf=null,this.rt&&(this.rt.destroyTextureBuffers(),this.rt.destroy(),this.rt=null),this.rtHalf&&(this.rtHalf.destroyTextureBuffers(),this.rtHalf.destroy(),this.rtHalf=null),this.beforePasses.forEach(e=>e.destroy()),this.beforePasses.length=0,this.prePass=null,this.scenePass=null,this.scenePassTransparent=null,this.colorGrabPass=null,this.composePass=null,this.bloomPass=null,this.ssaoPass=null,this.taaPass=null,this.afterPass=null,this.scenePassHalf=null,this.dofPass=null}sanitizeOptions(e){return((e=Object.assign({},M,e)).taaEnabled||e.ssaoType!==a||e.dofEnabled)&&(e.prepassEnabled=!0),e}set renderTargetScale(e){this._renderTargetScale=e,this.scenePass&&(this.scenePass.scaleX=e,this.scenePass.scaleY=e)}get renderTargetScale(){return this._renderTargetScale}needsReset(e){const t=this.options;return e.ssaoType!==t.ssaoType||e.ssaoBlurEnabled!==t.ssaoBlurEnabled||e.taaEnabled!==t.taaEnabled||e.samples!==t.samples||e.stencil!==t.stencil||e.bloomEnabled!==t.bloomEnabled||e.prepassEnabled!==t.prepassEnabled||e.sceneColorMap!==t.sceneColorMap||e.dofEnabled!==t.dofEnabled||e.dofNearBlur!==t.dofNearBlur||e.dofHighQuality!==t.dofHighQuality||(n=e.formats,r=t.formats,!(n===r||Array.isArray(n)&&Array.isArray(r)&&n.length===r.length&&n.every((e,t)=>e===r[t])));var n,r}update(e){e=this.sanitizeOptions(e),(this.needsReset(e)||this.layersDirty)&&(this.layersDirty=!1,this.reset()),this.options=e,this.sceneTexture||this.setupRenderPasses(this.options)}createRenderTarget(e,t,n,r,s){const i=new l.g(this.device,{name:e,width:4,height:4,format:this.hdrFormat,mipmaps:!1,minFilter:o.DrA,magFilter:o.DrA,addressU:o.vq6,addressV:o.vq6});return new h.O({colorBuffer:i,depth:t,stencil:n,samples:r,flipY:s})}setupRenderPasses(e){const{device:t}=this,n=this.cameraComponent,r=n.renderTarget;this.hdrFormat=t.getRenderableHdrFormat(e.formats,!0,e.samples)||o.Lxj,this._bloomEnabled=e.bloomEnabled&&this.hdrFormat!==o.Lxj,this._sceneHalfEnabled=this._bloomEnabled||e.dofEnabled,n.shaderParams.ssaoEnabled="lighting"===e.ssaoType;const s=!!r?.flipY;this.rt=this.createRenderTarget("SceneColor",!0,e.stencil,e.samples,s),this.sceneTexture=this.rt.colorBuffer,this._sceneHalfEnabled&&(this.rtHalf=this.createRenderTarget("SceneColorHalf",!1,!1,1,s),this.sceneTextureHalf=this.rtHalf.colorBuffer),this.sceneOptions={resizeSource:r,scaleX:this.renderTargetScale,scaleY:this.renderTargetScale},this.createPasses(e);const i=this.collectPasses();this.beforePasses=i.filter(e=>null!=e)}collectPasses(){return[this.prePass,this.ssaoPass,this.scenePass,this.colorGrabPass,this.scenePassTransparent,this.taaPass,this.scenePassHalf,this.bloomPass,this.dofPass,this.composePass,this.afterPass]}createPasses(e){this.setupScenePrepass(e),this.setupSsaoPass(e);const t=this.setupScenePass(e),n=this.setupTaaPass(e);this.setupSceneHalfPass(e,n),this.setupBloomPass(e,this.sceneTextureHalf),this.setupDofPass(e,this.sceneTexture,this.sceneTextureHalf),this.setupComposePass(e),this.setupAfterPass(e,t)}setupScenePrepass(e){if(e.prepassEnabled){const{app:e,device:t,cameraComponent:n}=this,{scene:r,renderer:s}=e;this.prePass=new A(t,r,s,n,this.sceneOptions)}}setupScenePassSettings(e){e.gammaCorrection=u.hcE,e.toneMapping=u.YJk}setupScenePass(e){const{app:t,device:n,cameraComponent:r}=this,{scene:s,renderer:i}=t,o=s.layers;this.scenePass=new d.r(n,o,s,i),this.setupScenePassSettings(this.scenePass),this.scenePass.init(this.rt,this.sceneOptions);const a=e.sceneColorMap?e.lastGrabLayerId:e.lastSceneLayerId,u=e.sceneColorMap?e.lastGrabLayerIsTransparent:e.lastSceneLayerIsTransparent,l={lastAddedIndex:0,clearRenderTarget:!0};return l.lastAddedIndex=this.scenePass.addLayers(o,r,l.lastAddedIndex,l.clearRenderTarget,a,u),l.clearRenderTarget=!1,e.sceneColorMap&&(this.colorGrabPass=new f.j(n),this.colorGrabPass.source=this.rt,this.scenePassTransparent=new d.r(n,o,s,i),this.setupScenePassSettings(this.scenePassTransparent),this.scenePassTransparent.init(this.rt),l.lastAddedIndex=this.scenePassTransparent.addLayers(o,r,l.lastAddedIndex,l.clearRenderTarget,e.lastSceneLayerId,e.lastSceneLayerIsTransparent),this.scenePassTransparent.rendersAnything||(this.scenePassTransparent.destroy(),this.scenePassTransparent=null),this.scenePassTransparent&&e.prepassEnabled&&(this.scenePassTransparent.depthStencilOps.storeDepth=!0)),l}setupSsaoPass(e){const{ssaoBlurEnabled:t,ssaoType:n}=e,{device:r,cameraComponent:s}=this;n!==a&&(this.ssaoPass=new B(r,this.sceneTexture,s,t))}setupSceneHalfPass(e,t){this._sceneHalfEnabled&&(this.scenePassHalf=new T(this.device,this.sceneTexture,{boxFilter:!0,removeInvalid:!0}),this.scenePassHalf.name="RenderPassSceneHalf",this.scenePassHalf.init(this.rtHalf,{resizeSource:t,scaleX:.5,scaleY:.5}),this.scenePassHalf.setClearColor(r.Q.BLACK))}setupBloomPass(e,t){this._bloomEnabled&&(this.bloomPass=new S(this.device,t,this.hdrFormat))}setupDofPass(e,t,n){e.dofEnabled&&(this.dofPass=new L(this.device,this.cameraComponent,t,n,e.dofHighQuality,e.dofNearBlur))}setupTaaPass(e){let t=this.sceneTexture;return e.taaEnabled&&(this.taaPass=new C(this.device,this.sceneTexture,this.cameraComponent),t=this.taaPass.historyTexture),t}setupComposePass(e){this.composePass=new R(this.device),this.composePass.bloomTexture=this.bloomPass?.bloomTexture,this.composePass.taaEnabled=e.taaEnabled,this.composePass.cocTexture=this.dofPass?.cocTexture,this.composePass.blurTexture=this.dofPass?.blurTexture,this.composePass.blurTextureUpscale=!this.dofPass?.highQuality;const t=this.cameraComponent.renderTarget;this.composePass.init(t),this.composePass.ssaoTexture="combine"===e.ssaoType?this.ssaoPass.ssaoTexture:null}setupAfterPass(e,t){const{app:n,cameraComponent:r}=this,{scene:s,renderer:i}=n,o=s.layers,a=r.renderTarget;this.afterPass=new d.r(this.device,o,s,i),this.afterPass.init(a),this.afterPass.addLayers(o,r,t.lastAddedIndex,t.clearRenderTarget)}frameUpdate(){this.layersDirty&&this.cameraFrame.update(),super.frameUpdate();const e=this.taaPass?.update()??this.rt.colorBuffer;this.composePass.sceneTexture=e,this.scenePassHalf?.setSourceTexture(e)}}class N{constructor(e,t){this._enabled=!0,this.rendering={renderFormats:[o.s_z,o.WBN,o.s7h],stencil:!1,renderTargetScale:1,samples:1,sceneColorMap:!1,sceneDepthMap:!1,toneMapping:0,sharpness:0},this.ssao={type:a,blurEnabled:!0,randomize:!1,intensity:.5,radius:30,samples:12,power:6,minAngle:10,scale:1},this.bloom={intensity:0,blurLevel:16},this.grading={enabled:!1,brightness:1,contrast:1,saturation:1,tint:new r.Q(1,1,1,1)},this.colorLUT={texture:null,intensity:1},this.vignette={intensity:0,inner:.5,outer:1,curvature:.5},this.taa={enabled:!1,jitter:1},this.fringing={intensity:0},this.dof={enabled:!1,nearBlur:!1,focusDistance:100,focusRange:10,blurRadius:3,blurRings:4,blurRingPoints:5,highQuality:!0},this.debug=null,this.options=new V,this.renderPassCamera=null,this.app=e,this.cameraComponent=t,this.updateOptions(),this.enable(),this.cameraLayersChanged=t.on("set:layers",()=>{this.renderPassCamera&&(this.renderPassCamera.layersDirty=!0)})}destroy(){this.disable(),this.cameraLayersChanged.off()}enable(){this.renderPassCamera=this.createRenderPass(),this.cameraComponent.renderPasses=[this.renderPassCamera]}disable(){const e=this.cameraComponent;e.renderPasses?.forEach(e=>{e.destroy()}),e.renderPasses=[],e.rendering=null,e.jitter=0,e.shaderParams.ssaoEnabled=!1,this.renderPassCamera=null}createRenderPass(){return new z(this.app,this,this.cameraComponent,this.options)}set enabled(e){this._enabled!==e&&(e?this.enable():this.disable(),this._enabled=e)}get enabled(){return this._enabled}updateOptions(){const{options:e,rendering:t,bloom:n,taa:r,ssao:s}=this;e.stencil=t.stencil,e.samples=t.samples,e.sceneColorMap=t.sceneColorMap,e.prepassEnabled=t.sceneDepthMap,e.bloomEnabled=n.intensity>0,e.taaEnabled=r.enabled,e.ssaoType=s.type,e.ssaoBlurEnabled=s.blurEnabled,e.formats=t.renderFormats.slice(),e.dofEnabled=this.dof.enabled,e.dofNearBlur=this.dof.nearBlur,e.dofHighQuality=this.dof.highQuality}update(){if(!this._enabled)return;const e=this.cameraComponent,{options:t,renderPassCamera:n,rendering:r,bloom:s,grading:o,vignette:u,fringing:l,taa:c,ssao:f}=this;this.updateOptions(),n.update(t);const{composePass:d,bloomPass:h,ssaoPass:v,dofPass:p}=n;n.renderTargetScale=i.D.clamp(r.renderTargetScale,.1,1),d.toneMapping=r.toneMapping,d.sharpness=r.sharpness,t.bloomEnabled&&h&&(d.bloomIntensity=s.intensity,h.blurLevel=s.blurLevel),t.dofEnabled&&(p.focusDistance=this.dof.focusDistance,p.focusRange=this.dof.focusRange,p.blurRadius=this.dof.blurRadius,p.blurRings=this.dof.blurRings,p.blurRingPoints=this.dof.blurRingPoints),t.ssaoType!==a&&(v.intensity=f.intensity,v.power=f.power,v.radius=f.radius,v.sampleCount=f.samples,v.minAngle=f.minAngle,v.scale=f.scale,v.randomize=f.randomize),d.gradingEnabled=o.enabled,o.enabled&&(d.gradingSaturation=o.saturation,d.gradingBrightness=o.brightness,d.gradingContrast=o.contrast,d.gradingTint=o.tint),d.colorLUT=this.colorLUT.texture,d.colorLUTIntensity=this.colorLUT.intensity,d.vignetteEnabled=u.intensity>0,d.vignetteEnabled&&(d.vignetteInner=u.inner,d.vignetteOuter=u.outer,d.vignetteCurvature=u.curvature,d.vignetteIntensity=u.intensity),d.fringingEnabled=l.intensity>0,d.fringingEnabled&&(d.fringingIntensity=l.intensity),e.jitter=c.enabled?c.jitter:0,d.debug=this.debug,"ssao"===d.debug&&t.ssaoType===a&&(d.debug=null),"vignette"!==d.debug||d.vignetteEnabled||(d.debug=null)}}const k=0,W="none",G=18,j=12,H=14,q="none";class Q{renderFormat=G;renderFormatFallback0=j;renderFormatFallback1=H;stencil=!1;renderTargetScale=1;samples=1;sceneColorMap=!1;sceneDepthMap=!1;toneMapping=k;sharpness=0;debug=q}class X{type=W;blurEnabled=!0;intensity=.5;radius=30;samples=12;power=6;minAngle=10;scale=1}class ${enabled=!1;intensity=.01;blurLevel=16}class Y{enabled=!1;brightness=1;contrast=1;saturation=1;tint=new r.Q(1,1,1,1)}class K{texture=null;intensity=1}class Z{enabled=!1;intensity=.5;inner=.5;outer=1;curvature=.5}class J{enabled=!1;intensity=50}class ee{enabled=!1;jitter=1}class te{enabled=!1;highQuality=!0;nearBlur=!1;focusDistance=100;focusRange=10;blurRadius=3;blurRings=4;blurRingPoints=5}class ne extends s.e{static scriptName="cameraFrame";rendering=new Q;ssao=new X;bloom=new $;grading=new Y;colorLUT=new K;vignette=new Z;taa=new ee;fringing=new J;dof=new te;engineCameraFrame;initialize(){this.engineCameraFrame=new N(this.app,this.entity.camera),this.on("enable",()=>{this.engineCameraFrame.enabled=!0}),this.on("disable",()=>{this.engineCameraFrame.enabled=!1}),this.on("destroy",()=>{this.engineCameraFrame.destroy()}),this.on("state",e=>{this.engineCameraFrame.enabled=e})}postUpdate(e){const t=this.engineCameraFrame,{rendering:n,bloom:r,grading:s,vignette:i,fringing:o,taa:a,ssao:u,dof:l,colorLUT:c}=this,f=t.rendering;f.renderFormats.length=0,f.renderFormats.push(n.renderFormat),f.renderFormats.push(n.renderFormatFallback0),f.renderFormats.push(n.renderFormatFallback1),f.stencil=n.stencil,f.renderTargetScale=n.renderTargetScale,f.samples=n.samples,f.sceneColorMap=n.sceneColorMap,f.sceneDepthMap=n.sceneDepthMap,f.toneMapping=n.toneMapping,f.sharpness=n.sharpness;const d=t.ssao;d.type=u.type,u.type!==W&&(d.intensity=u.intensity,d.radius=u.radius,d.samples=u.samples,d.power=u.power,d.minAngle=u.minAngle,d.scale=u.scale);const h=t.bloom;h.intensity=r.enabled?r.intensity:0,r.enabled&&(h.blurLevel=r.blurLevel);const v=t.grading;v.enabled=s.enabled,s.enabled&&(v.brightness=s.brightness,v.contrast=s.contrast,v.saturation=s.saturation,v.tint.copy(s.tint));const p=t.colorLUT;c.texture?.resource?(p.texture=c.texture.resource,p.intensity=c.intensity):p.texture=null;const m=t.vignette;m.intensity=i.enabled?i.intensity:0,i.enabled&&(m.inner=i.inner,m.outer=i.outer,m.curvature=i.curvature);const x=t.taa;x.enabled=a.enabled,a.enabled&&(x.jitter=a.jitter);t.fringing.intensity=o.enabled?o.intensity:0;const g=t.dof;g.enabled=l.enabled,l.enabled&&(g.highQuality=l.highQuality,g.nearBlur=l.nearBlur,g.focusDistance=l.focusDistance,g.focusRange=l.focusRange,g.blurRadius=l.blurRadius,g.blurRings=l.blurRings,g.blurRingPoints=l.blurRingPoints),t.debug=n.debug,t.update()}}},16230:(e,t,n)=>{n.d(t,{d:()=>c});var r=n(74848),s=n(18881),i=n(73416),o=n(71586),a=n(56460),u=n(53282);const l=e=>((0,s.x)("render",e,d.schema),null),c=e=>{const t=(0,u.cF)(e,d);return"asset"!==t.type||t.asset?"container"===t.asset?.type?(0,r.jsx)(i.m,{asset:t.asset,children:t.children}):(0,r.jsx)(l,{...t}):null},f=["asset","box","capsule","cone","cylinder","plane","sphere","torus"],d=(0,u.xE)("Render",()=>new o.w("mock-render",(0,u.s_)()).addComponent("render"),e=>e.system.destroy(),"RenderComponent");d.schema={...d.schema,children:{validate:e=>"object"==typeof e&&null!==e,errorMsg:e=>`Invalid value for prop "children": ${e}. Expected an object.`,default:void 0},asset:{validate:e=>!e||e instanceof a.V,errorMsg:e=>`Invalid value for prop "asset": ${e}. Expected an Asset.`,default:void 0},type:{validate:e=>"string"==typeof e&&f.includes(e),errorMsg:e=>`Invalid value for prop "type": ${e}. Expected one of: "${f.join('", "')}".`,default:"box"}}},19748:(e,t,n)=>{n.d(t,{v:()=>o});var r=n(18881),s=n(71586),i=n(53282);const o=e=>{const t=(0,i.hE)(e,a);return(0,r.x)("light",t,a.schema),null},a=(0,i.xE)("Light",()=>new s.w("mock-light",(0,i.s_)()).addComponent("light"),e=>e.system.destroy(),"LightComponent");a.schema={...a.schema,type:{validate:e=>"string"==typeof e&&["directional","omni","spot"].includes(e),errorMsg:e=>`Invalid value for prop "type": ${e}. Expected one of: "directional", "omni", "spot".`,default:"directional"}}},43025:(e,t,n)=>{n.d(t,{O:()=>g});var r=n(9039),s=n(36805),i=n(27351),o=n(63744),a=n(96540),u=n(10977),l=n(53282),c=n(56460);function f(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function d(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?f(Object(n),!0).forEach(function(t){h(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):f(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function h(e,t,n){return(t=function(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var r=n.call(e,t||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==typeof t?t:String(t)}(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const v=function e(t){return n.withOptions=n=>e(d(d({},t),n)),n;function n(e,...n){const r="string"==typeof e?[e]:e.raw,{alignValues:s=!1,escapeSpecialCharacters:i=Array.isArray(e),trimWhitespace:o=!0}=t;let a="";for(let t=0;t<r.length;t++){let e=r[t];if(i&&(e=e.replace(/\\\n[ \t]*/g,"").replace(/\\`/g,"`").replace(/\\\$/g,"$").replace(/\\\{/g,"{")),a+=e,t<n.length){a+=s?m(n[t],a):n[t]}}const u=a.split("\n");let l=null;for(const t of u){const e=t.match(/^(\s+)\S+/);if(e){const t=e[1].length;l=l?Math.min(l,t):t}}if(null!==l){const e=l;a=u.map(t=>" "===t[0]||"\t"===t[0]?t.slice(e):t).join("\n")}return o&&(a=a.trim()),i&&(a=a.replace(/\\n/g,"\n")),a}}({}),p=v;function m(e,t){if("string"!=typeof e||!e.includes("\n"))return e;const n=t.slice(t.lastIndexOf("\n")+1).match(/^(\s+)/);if(n){const t=n[1];return e.replace(/\n/g,`\n${t}`)}return e}const x=new Set;function g(e){const t=(0,u.n)(),{center:n,scale:o,rotation:c,depthWrite:f,type:d,showSkybox:h,...v}=e,m={center:n,scale:o,rotation:c,depthWrite:f,type:d,showSkybox:h},g=(0,l.hE)(v,T),b=(0,l.hE)(m,y),S=(0,a.useRef)(!1);return(0,a.useEffect)(()=>{const e=t.root.getGuid(),n=x.has(e);return x.add(e),S.current=n,n&&(0,l.mc)(p`Multiple \`<Environment/>\` components have been mounted.
                Only the first \`<Environment/>\` component will be used.`),()=>{x.delete(e)}}),(0,a.useEffect)(()=>{if(S.current)return;const e=g.skybox;if(!e)return;const n=Array.isArray(e.resources)&&6===e.resources.length;let s=e.resource;return n||(s=r.S.generateSkyboxCubemap(e.resource)),t.scene.skybox=s,()=>{t?.scene&&(t.scene.skybox=null)}},[S.current,g.skybox?.id]),(0,a.useEffect)(()=>{if(!S.current)return t.scene.envAtlas=g?.envAtlas?.resource??null,()=>{t?.scene&&(t.scene.envAtlas=null)}},[S.current,g.envAtlas?.id]),(0,a.useEffect)(()=>{if(S.current)return;t.scene.exposure=g.exposure??1,t.scene.envAtlas=g.envAtlas?.resource??null,b.rotation&&(t.scene.skyboxRotation=(new s.k).setFromEulerAngles(b.rotation[0],b.rotation[1],b.rotation[2])),b.scale&&t.scene.sky.node.setLocalScale(...b.scale),b.position&&t.scene.sky.node.setLocalPosition(...b.position),b.center&&t.scene.sky.center.set(...b.center),t.scene.sky.type=b.type??i.QNk,t.scene.sky.depthWrite=b.depthWrite??!0,t.scene.skyboxMip=g.skyboxMip??0,t.scene.skyboxLuminance=g.skyboxLuminance??1,t.scene.skyboxIntensity=g.skyboxIntensity??1,t.scene.skyboxHighlightMultiplier=g.skyboxHighlightMultiplier??1;const e=t?.scene?.layers?.getLayerByName("Skybox");return e&&(e.enabled=b.showSkybox??!0),()=>{if(t.scene){t.scene.exposure=1,t.scene.skyboxRotation=(new s.k).setFromEulerAngles(0,0,0),t.scene.sky.node.setLocalScale(1,1,1),t.scene.sky.node.setLocalPosition(0,0,0),t.scene.sky.center.set(0,.05,0),t.scene.sky.type=i.llp,t.scene.sky.depthWrite=!1,t.scene.skyboxMip=0,t.scene.skyboxLuminance=0,t.scene.skyboxIntensity=1,t.scene.skyboxHighlightMultiplier=1;const e=t?.scene?.layers?.getLayerByName("Skybox");e&&(e.enabled=!0)}}},[S.current,g.exposure,b.type,b.depthWrite,b.showSkybox,g.skyboxMip,g.skyboxLuminance,g.skyboxIntensity,g.skyboxHighlightMultiplier,`scale-${b.scale?.join("-")}`,`rotation-${b.rotation?.join("-")}`,`center-${b.center?.join("-")}`]),null}const y=(0,l.xE)("Sky",()=>new o.m((0,l.s_)().scene),e=>e.resetSkyMesh()),T=(0,l.xE)("Scene",()=>(0,l.s_)().scene);y.schema={...y.schema,scale:{validate:e=>Array.isArray(e)&&3===e.length&&e.every(e=>"number"==typeof e),errorMsg:e=>`Expected an array of 3 numbers, got \`${typeof e}\``,default:[100,100,100]},rotation:{validate:e=>Array.isArray(e)&&3===e.length&&e.every(e=>"number"==typeof e),errorMsg:e=>`Expected an array of 3 numbers, got \`${typeof e}\``,default:[0,0,0]},position:{validate:e=>Array.isArray(e)&&3===e.length&&e.every(e=>"number"==typeof e),errorMsg:e=>`Expected an array of 3 numbers, got \`${typeof e}\``,default:[0,0,0]},center:{validate:e=>Array.isArray(e)&&3===e.length&&e.every(e=>"number"==typeof e),errorMsg:e=>`Expected an array of 3 numbers, got \`${typeof e}\``,default:[0,.05,0]},showSkybox:{validate:e=>"boolean"==typeof e,errorMsg:e=>`Expected a boolean, got \`${typeof e}\``,default:!0}},T.schema={...T.schema,envAtlas:{validate:e=>e instanceof c.V&&"texture"===e.type,errorMsg:e=>`Expected a \`Asset\` instance, got \`${typeof e}\``,default:null},skybox:{validate:e=>e instanceof c.V&&"texture"===e.type,errorMsg:e=>`Expected a \`Asset\` instance, got \`${typeof e}\``,default:null}}},73416:(e,t,n)=>{n.d(t,{m:()=>a});var r=n(74848),s=n(96540),i=n(10977),o=n(18676);const a=({asset:e,children:t,...n})=>{const a=(0,s.useRef)(null),u=(0,s.useRef)(null),l=(0,i.n)();return(0,s.useLayoutEffect)(()=>{if(l&&e?.resource&&a.current){const t=e.resource.instantiateRenderEntity(null);a.current.addChild(t),u.current=t}return()=>{a.current&&u.current&&(u.current.destroy(),a.current.removeChild(u.current),a.current=null,u.current=null)}},[l,parent,e,e?.resource]),e?.resource?(0,r.jsx)(o.w,{ref:a,...n,children:t}):null}},78692:(e,t,n)=>{n.d(t,{x:()=>h});var r=n(48355),s=n(40050),i=n(91622),o=n(27351),a=n(70917),u=n(51261),l=n(1002),c=n(53322),f=n(85169);const d=new s.Z;class h extends f.e{static scriptName="grid";static RESOLUTION_LOW=0;static RESOLUTION_MEDIUM=1;static RESOLUTION_HIGH=2;_material;_meshInstance;_halfExtents=new s.Z;_colorX=new r.Q(1,.3,.3);_colorZ=new r.Q(.3,.3,1);_resolution=h.RESOLUTION_HIGH;initialize(){if(this.entity.render)return void console.error("The entity already has a render component.");this.entity.addComponent("render",{castShadows:!1}),this._material=new l.B({uniqueName:"grid-shader",vertexGLSL:"\n    attribute vec3 vertex_position;\n    attribute vec2 aUv0;\n\n    uniform mat4 matrix_model;\n    uniform mat4 matrix_viewProjection;\n\n    varying vec2 uv0;\n\n    void main(void) {\n        gl_Position = matrix_viewProjection * matrix_model * vec4(vertex_position, 1.0);\n        uv0 = aUv0;\n    }\n",fragmentGLSL:"\n    uniform vec2 uHalfExtents;\n    uniform vec3 uColorX;\n    uniform vec3 uColorZ;\n    uniform int uResolution;\n\n    varying vec2 uv0;\n\n    // https://bgolus.medium.com/the-best-darn-grid-shader-yet-727f9278b9d8#1e7c\n    float pristineGrid(in vec2 uv, in vec2 ddx, in vec2 ddy, vec2 lineWidth) {\n        vec2 uvDeriv = vec2(length(vec2(ddx.x, ddy.x)), length(vec2(ddx.y, ddy.y)));\n        bvec2 invertLine = bvec2(lineWidth.x > 0.5, lineWidth.y > 0.5);\n        vec2 targetWidth = vec2(\n            invertLine.x ? 1.0 - lineWidth.x : lineWidth.x,\n            invertLine.y ? 1.0 - lineWidth.y : lineWidth.y\n        );\n        vec2 drawWidth = clamp(targetWidth, uvDeriv, vec2(0.5));\n        vec2 lineAA = uvDeriv * 1.5;\n        vec2 gridUV = abs(fract(uv) * 2.0 - 1.0);\n        gridUV.x = invertLine.x ? gridUV.x : 1.0 - gridUV.x;\n        gridUV.y = invertLine.y ? gridUV.y : 1.0 - gridUV.y;\n        vec2 grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);\n\n        grid2 *= clamp(targetWidth / drawWidth, 0.0, 1.0);\n        grid2 = mix(grid2, targetWidth, clamp(uvDeriv * 2.0 - 1.0, 0.0, 1.0));\n        grid2.x = invertLine.x ? 1.0 - grid2.x : grid2.x;\n        grid2.y = invertLine.y ? 1.0 - grid2.y : grid2.y;\n\n        return mix(grid2.x, 1.0, grid2.y);\n    }\n\n    void main(void) {\n        vec2 uv = uv0;\n\n        vec2 pos = (uv * 2.0 - 1.0) * uHalfExtents;\n        vec2 ddx = dFdx(pos);\n        vec2 ddy = dFdy(pos);\n\n        float epsilon = 1.0 / 255.0;\n\n        vec2 levelPos;\n        float levelSize;\n        float levelAlpha;\n\n        levelPos = pos * 0.1;\n        levelSize = 2.0 / 1000.0;\n        levelAlpha = pristineGrid(levelPos, ddx * 0.1, ddy * 0.1, vec2(levelSize));\n        if (levelAlpha > epsilon) {\n            vec3 color;\n            if (abs(levelPos.x) < levelSize) {\n                if (abs(levelPos.y) < levelSize) {\n                    color = vec3(1.0);\n                } else {\n                    color = uColorZ;\n                }\n            } else if (abs(levelPos.y) < levelSize) {\n                color = uColorX;\n            } else {\n                color = vec3(0.9);\n            }\n            gl_FragColor = vec4(color, levelAlpha);\n            return;\n        }\n\n        levelPos = pos;\n        levelSize = 1.0 / 100.0;\n        levelAlpha = pristineGrid(levelPos, ddx, ddy, vec2(levelSize));\n        if (levelAlpha > epsilon) {\n            if (uResolution < 1) {\n                discard;\n            }\n            gl_FragColor = vec4(vec3(0.7), levelAlpha);\n            return;\n        }\n\n        levelPos = pos * 10.0;\n        levelSize = 1.0 / 100.0;\n        levelAlpha = pristineGrid(levelPos, ddx * 10.0, ddy * 10.0, vec2(levelSize));\n        if (levelAlpha > epsilon) {\n            if (uResolution < 2) {\n                discard;\n            }\n            gl_FragColor = vec4(vec3(0.7), levelAlpha);\n            return;\n        }\n\n        discard;\n    }\n",vertexWGSL:"\n    attribute vertex_position: vec3f;\n    attribute aUv0: vec2f;\n\n    uniform matrix_model: mat4x4f;\n    uniform matrix_viewProjection: mat4x4f;\n\n    varying uv0: vec2f;\n\n    @vertex\n    fn vertexMain(input: VertexInput) -> VertexOutput {\n        var output: VertexOutput;\n        output.position = uniform.matrix_viewProjection * uniform.matrix_model * vec4f(input.vertex_position, 1.0);\n        output.uv0 = input.aUv0;\n        return output;\n    }\n",fragmentWGSL:"\n    uniform uHalfExtents: vec2f;\n    uniform uColorX: vec3f;\n    uniform uColorZ: vec3f;\n    uniform uResolution: u32;\n\n    varying uv0: vec2f;\n\n    // https://bgolus.medium.com/the-best-darn-grid-shader-yet-727f9278b9d8#1e7c\n    fn pristineGrid(uv: vec2f, ddx: vec2f, ddy: vec2f, lineWidth: vec2f) -> f32 {\n        let uvDeriv = vec2f(length(vec2f(ddx.x, ddy.x)), length(vec2f(ddx.y, ddy.y)));\n        let invertLine = vec2<bool>(lineWidth.x > 0.5, lineWidth.y > 0.5);\n        let targetWidth = vec2f(\n            select(lineWidth.x, 1.0 - lineWidth.x, invertLine.x),\n            select(lineWidth.y, 1.0 - lineWidth.y, invertLine.y)\n        );\n        let drawWidth = clamp(targetWidth, uvDeriv, vec2f(0.5));\n        let lineAA = uvDeriv * 1.5;\n        var gridUV = abs(fract(uv) * 2.0 - 1.0);\n        gridUV.x = select(1.0 - gridUV.x, gridUV.x, invertLine.x);\n        gridUV.y = select(1.0 - gridUV.y, gridUV.y, invertLine.y);\n        var grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);\n\n        grid2 *= clamp(targetWidth / drawWidth, vec2f(0.0), vec2f(1.0));\n        grid2 = mix(grid2, targetWidth, clamp(uvDeriv * 2.0 - 1.0, vec2f(0.0), vec2f(1.0)));\n        grid2.x = select(grid2.x, 1.0 - grid2.x, invertLine.x);\n        grid2.y = select(grid2.y, 1.0 - grid2.y, invertLine.y);\n\n        return mix(grid2.x, 1.0, grid2.y);\n    }\n\n    @fragment\n    fn fragmentMain(input: FragmentInput) -> FragmentOutput {\n        var output: FragmentOutput;\n        let uv: vec2f = input.uv0;\n\n        let pos: vec2f = (uv * 2.0 - 1.0) * uniform.uHalfExtents;\n        let ddx: vec2f = dpdx(pos);\n        let ddy: vec2f = dpdy(pos);\n\n        let epsilon: f32 = 1.0 / 255.0;\n\n        var levelPos: vec2f;\n        var levelSize: f32;\n        var levelAlpha: f32;\n\n        levelPos = pos * 0.1;\n        levelSize = 2.0 / 1000.0;\n        levelAlpha = pristineGrid(levelPos, ddx * 0.1, ddy * 0.1, vec2f(levelSize));\n        if (levelAlpha > epsilon) {\n            var color: vec3f;\n            if (abs(levelPos.x) < levelSize) {\n                if (abs(levelPos.y) < levelSize) {\n                    color = vec3f(1.0);\n                } else {\n                    color = uniform.uColorZ;\n                }\n            } else if (abs(levelPos.y) < levelSize) {\n                color = uniform.uColorX;\n            } else {\n                color = vec3f(0.9);\n            }\n            output.color = vec4f(color, levelAlpha);\n            return output;\n        }\n\n        levelPos = pos;\n        levelSize = 1.0 / 100.0;\n        levelAlpha = pristineGrid(levelPos, ddx, ddy, vec2f(levelSize));\n        if (levelAlpha > epsilon) {\n            if (uniform.uResolution < 1) {\n                discard;\n            }\n            output.color = vec4f(vec3f(0.7), levelAlpha);\n            return output;\n        }\n\n        levelPos = pos * 10.0;\n        levelSize = 1.0 / 100.0;\n        levelAlpha = pristineGrid(levelPos, ddx * 10.0, ddy * 10.0, vec2f(levelSize));\n        if (levelAlpha > epsilon) {\n            if (uniform.uResolution < 2) {\n                discard;\n            }\n            output.color = vec4f(vec3f(0.7), levelAlpha);\n            return output;\n        }\n\n        discard;\n        return output;\n    }\n",attributes:{vertex_position:i.JYe,aUv0:i.slc}}),this._material.blendType=o.i96,this._material.cull=i.pLF,this._material.update();const e=a.e.fromGeometry(this.app.graphicsDevice,new c.b);this._meshInstance=new u.F(e,this._material),this.entity.render.meshInstances=[this._meshInstance],this.colorX=this._colorX,this.colorZ=this._colorZ,this.resolution=this._resolution,this._set("uHalfExtents",this._calcHalfExtents(d)),this.app.on("prerender",()=>{if(!this.enabled)return;const e=this._calcHalfExtents(d);this._halfExtents.distance(e)>.001&&this._set("uHalfExtents",e)}),this.on("enable",()=>{this._meshInstance.visible=!0}),this.on("disable",()=>{this._meshInstance.visible=!1}),this.on("destroy",this.destroy,this)}_calcHalfExtents(e){const t=this.entity.getLocalScale();return e.set(t.x/2,t.z/2)}_set(e,t){this._material&&(t instanceof r.Q&&this._material.setParameter(e,[t.r,t.g,t.b]),t instanceof s.Z&&this._material.setParameter(e,[t.x,t.y]),"number"==typeof t&&this._material.setParameter(e,t),this._material.update(),this._meshInstance.material=this._material)}set colorX(e){e instanceof r.Q&&(this._colorX.copy(e),this._set("uColorX",this._colorX))}get colorX(){return this._colorX}set colorZ(e){e instanceof r.Q&&(this._colorZ.copy(e),this._set("uColorZ",this._colorZ))}get colorZ(){return this._colorZ}set resolution(e){this._resolution=e,this._set("uResolution",this._resolution)}get resolution(){return this._resolution}destroy(){this.entity.removeComponent("render")}}}}]);