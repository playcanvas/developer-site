"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[66334],{6937:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"user-manual/graphics/shaders/glsl-specifics","title":"GLSL Specifics","description":"GLSL shaders used by the PlayCanvas engine must satisfy certain requirements. These requirements allow the engine to correctly integrate shaders, ensuring they receive the necessary resources such as attributes, uniforms, and varyings. Following these rules also allows us to automatically process the shader for slightly different requirements when transpiling to WGSL for use with WebGPU.","source":"@site/docs/user-manual/graphics/shaders/glsl-specifics.md","sourceDirName":"user-manual/graphics/shaders","slug":"/user-manual/graphics/shaders/glsl-specifics","permalink":"/user-manual/graphics/shaders/glsl-specifics","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/graphics/shaders/glsl-specifics.md","tags":[],"version":"current","frontMatter":{"title":"GLSL Specifics"},"sidebar":"userManualSidebar","previous":{"title":"Shaders","permalink":"/user-manual/graphics/shaders/"},"next":{"title":"WGSL Specifics","permalink":"/user-manual/graphics/shaders/wgsl-specifics"}}');var t=n(74848),i=n(28453);const a={title:"GLSL Specifics"},l=void 0,o={},c=[{value:"Attributes",id:"attributes",level:3},{value:"Uniforms",id:"uniforms",level:3},{value:"Varyings",id:"varyings",level:3}];function d(e){const s={a:"a",admonition:"admonition",code:"code",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"GLSL shaders used by the PlayCanvas engine must satisfy certain requirements. These requirements allow the engine to correctly integrate shaders, ensuring they receive the necessary resources such as attributes, uniforms, and varyings. Following these rules also allows us to automatically process the shader for slightly different requirements when transpiling to WGSL for use with WebGPU."}),"\n",(0,t.jsx)(s.p,{children:"The following sections outline key aspects of writing GLSL shaders for PlayCanvas."}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"#version"})," should not be included in the shader source. PlayCanvas automatically adds the appropriate version directive based on whether WebGL2 or WebGPU is targeted."]})}),"\n",(0,t.jsx)(s.h3,{id:"attributes",children:"Attributes"}),"\n",(0,t.jsx)(s.p,{children:"Attributes define per-vertex input data, and can only be used in the vertex shader. They must be declared using the following syntax:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-glsl",children:"attribute vec2 aUv0;\n"})}),"\n",(0,t.jsxs)(s.p,{children:["The attribute names must match the names specified in the ",(0,t.jsx)(s.code,{children:"attributes"})," property when creating the ",(0,t.jsx)(s.a,{href:"/user-manual/graphics/shaders/",children:"ShaderMaterial"}),"."]}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"in"})," keyword (introduced in GLSL 3.3+) is not supported."]})}),"\n",(0,t.jsx)(s.h3,{id:"uniforms",children:"Uniforms"}),"\n",(0,t.jsx)(s.p,{children:"Uniforms are used to pass resources from the engine to the shader. They are declared in the standard way for numerical and texture uniforms:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-glsl",children:"uniform vec3 view_position;\n"})}),"\n",(0,t.jsx)(s.p,{children:"The engine automatically sets appropriate uniform values when rendering."}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["Currently, our uniform system supports only simple types, including ",(0,t.jsx)(s.code,{children:"float"}),", ",(0,t.jsx)(s.code,{children:"int"}),", ",(0,t.jsx)(s.code,{children:"uint"}),", as well as vectors and matrices (e.g., ",(0,t.jsx)(s.code,{children:"vec4"}),", ",(0,t.jsx)(s.code,{children:"mat4"}),"). Structs are not supported at this time, so all uniform values must be declared as individual variables of basic types."]})}),"\n",(0,t.jsx)(s.h3,{id:"varyings",children:"Varyings"}),"\n",(0,t.jsx)(s.p,{children:"Varyings are used to pass values from the vertex shader to the fragment shader. They must be declared using standard GLSL syntax:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-glsl",children:"varying vec2 uv0;\n"})}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"in"}),"/",(0,t.jsx)(s.code,{children:"out"})," syntax (introduced in GLSL 3.3+) is not supported."]})})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>l});var r=n(96540);const t={},i=r.createContext(t);function a(e){const s=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);