"use strict";(self.webpackChunkdeveloper_playcanvas_com=self.webpackChunkdeveloper_playcanvas_com||[]).push([[47450],{11470:(t,n,e)=>{e.d(n,{A:()=>P});var i=e(96540),o=e(34164),s=e(23104),a=e(56347),r=e(205),l=e(57485),c=e(31682),d=e(70679);function u(t){return i.Children.toArray(t).filter(t=>"\n"!==t).map(t=>{if(!t||(0,i.isValidElement)(t)&&function(t){const{props:n}=t;return!!n&&"object"==typeof n&&"value"in n}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(t){const{values:n,children:e}=t;return(0,i.useMemo)(()=>{const t=n??function(t){return u(t).map(({props:{value:t,label:n,attributes:e,default:i}})=>({value:t,label:n,attributes:e,default:i}))}(e);return function(t){const n=(0,c.XI)(t,(t,n)=>t.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(t=>t.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t},[n,e])}function p({value:t,tabValues:n}){return n.some(n=>n.value===t)}function m({queryString:t=!1,groupId:n}){const e=(0,a.W6)(),o=function({queryString:t=!1,groupId:n}){if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(o),(0,i.useCallback)(t=>{if(!o)return;const n=new URLSearchParams(e.location.search);n.set(o,t),e.replace({...e.location,search:n.toString()})},[o,e])]}function b(t){const{defaultValue:n,queryString:e=!1,groupId:o}=t,s=h(t),[a,l]=(0,i.useState)(()=>function({defaultValue:t,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map(t=>t.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const e=n.find(t=>t.default)??n[0];if(!e)throw new Error("Unexpected error: 0 tabValues");return e.value}({defaultValue:n,tabValues:s})),[c,u]=m({queryString:e,groupId:o}),[b,y]=function({groupId:t}){const n=function(t){return t?`docusaurus.tab.${t}`:null}(t),[e,o]=(0,d.Dv)(n);return[e,(0,i.useCallback)(t=>{n&&o.set(t)},[n,o])]}({groupId:o}),f=(()=>{const t=c??b;return p({value:t,tabValues:s})?t:null})();(0,r.A)(()=>{f&&l(f)},[f]);return{selectedValue:a,selectValue:(0,i.useCallback)(t=>{if(!p({value:t,tabValues:s}))throw new Error(`Can't select invalid tab value=${t}`);l(t),u(t),y(t)},[u,y,s]),tabValues:s}}var y=e(92303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=e(74848);function g({className:t,block:n,selectedValue:e,selectValue:i,tabValues:a}){const r=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.a_)(),c=t=>{const n=t.currentTarget,o=r.indexOf(n),s=a[o].value;s!==e&&(l(n),i(s))},d=t=>{let n=null;switch(t.key){case"Enter":c(t);break;case"ArrowRight":{const e=r.indexOf(t.currentTarget)+1;n=r[e]??r[0];break}case"ArrowLeft":{const e=r.indexOf(t.currentTarget)-1;n=r[e]??r[r.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":n},t),children:a.map(({value:t,label:n,attributes:i})=>(0,v.jsx)("li",{role:"tab",tabIndex:e===t?0:-1,"aria-selected":e===t,ref:t=>{r.push(t)},onKeyDown:d,onClick:c,...i,className:(0,o.A)("tabs__item",f.tabItem,i?.className,{"tabs__item--active":e===t}),children:n??t},t))})}function C({lazy:t,children:n,selectedValue:e}){const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const t=s.find(t=>t.props.value===e);return t?(0,i.cloneElement)(t,{className:(0,o.A)("margin-top--md",t.props.className)}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:s.map((t,n)=>(0,i.cloneElement)(t,{key:n,hidden:t.props.value!==e}))})}function j(t){const n=b(t);return(0,v.jsxs)("div",{className:(0,o.A)("tabs-container",f.tabList),children:[(0,v.jsx)(g,{...n,...t}),(0,v.jsx)(C,{...n,...t})]})}function P(t){const n=(0,y.A)();return(0,v.jsx)(j,{...t,children:u(t.children)},String(n))}},19365:(t,n,e)=>{e.d(n,{A:()=>a});e(96540);var i=e(34164);const o={tabItem:"tabItem_Ymn6"};var s=e(74848);function a({children:t,hidden:n,className:e}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,i.A)(o.tabItem,e),hidden:n,children:t})}},28453:(t,n,e)=>{e.d(n,{R:()=>a,x:()=>r});var i=e(96540);const o={},s=i.createContext(o);function a(t){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof t?t(n):{...n,...t}},[n,t])}function r(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:a(t.components),i.createElement(s.Provider,{value:n},t.children)}},88657:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"user-manual/physics/calling-ammo","title":"Calling the ammo.js API","description":"The PlayCanvas integration with ammo.js does not expose the full capability of the ammo.js API. However, it is possible to call the ammo.js API directly from your PlayCanvas scripts.","source":"@site/docs/user-manual/physics/calling-ammo.md","sourceDirName":"user-manual/physics","slug":"/user-manual/physics/calling-ammo","permalink":"/user-manual/physics/calling-ammo","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/physics/calling-ammo.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Calling the ammo.js API","sidebar_position":6},"sidebar":"userManualSidebar","previous":{"title":"Ray Casting","permalink":"/user-manual/physics/ray-casting"},"next":{"title":"Updating ammo.js","permalink":"/user-manual/physics/physics-migration"}}');var o=e(74848),s=e(28453),a=e(11470),r=e(19365);const l={title:"Calling the ammo.js API",sidebar_position:6},c=void 0,d={},u=[{value:"Joint Constraints",id:"joint-constraints",level:2},{value:"Continuous Collision Detection",id:"continuous-collision-detection",level:2}];function h(t){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...t.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"The PlayCanvas integration with ammo.js does not expose the full capability of the ammo.js API. However, it is possible to call the ammo.js API directly from your PlayCanvas scripts."}),"\n",(0,o.jsxs)(n.p,{children:["PlayCanvas currently uses ",(0,o.jsx)(n.a,{href:"https://github.com/kripken/ammo.js/commit/dcab07bf0e7f2b4b64c01dc45da846344c8f50be",children:"this build"})," of ammo.js. The API exposed by this build can be found ",(0,o.jsx)(n.a,{href:"https://github.com/kripken/ammo.js/blob/dcab07bf0e7f2b4b64c01dc45da846344c8f50be/ammo.idl",children:"here"}),". Although there is no official documentation for ammo.js, you can refer to the ",(0,o.jsx)(n.a,{href:"https://github.com/bulletphysics/bullet3/blob/master/docs/Bullet_User_Manual.pdf",children:"Bullet Physics User Guide"})," to learn more."]}),"\n",(0,o.jsx)(n.h2,{id:"joint-constraints",children:"Joint Constraints"}),"\n",(0,o.jsx)(n.p,{children:"There are currently no PlayCanvas components which implement physics constraints (sometimes known as physics joints). However, it is easy to leverage the ammo.js API to create scripts that implement constraints."}),"\n",(0,o.jsx)(n.p,{children:"Here is the script for a point-to-point constraint (essentially a ball and socket joint):"}),"\n","\n",(0,o.jsxs)(a.A,{defaultValue:"classic",groupId:"script-code",children:[(0,o.jsx)(r.A,{value:"esm",label:"ESM",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"import { Script, Vec3, Entity, Color } from 'playcanvas';\n\nexport class PointToPointConstraint extends Script {\n    static scriptName = \"pointToPointConstraint\";\n\n    /**\n     * Position of the constraint in the local space of this entity.\n     * \n     * @attribute\n     * @title Pivot\n     * @type {Vec3}\n     */\n    pivotA = new pc.Vec3(0, 0, 0);\n\n    /**\n     * Optional second entity.\n     * \n     * @attribute\n     * @title Connected Entity\n     * @type {Entity}\n     */\n    entityB = null;\n\n    /**\n     * Position of the constraint in the local space of entity B (if specified).\n     * \n     * @attribute\n     * @title Connected Pivot\n     * @type {Vec3}\n     */\n    pivotB = new pc.Vec3(0, 0, 0);\n\n    /**\n     * Maximum breaking impulse threshold required to break the constraint.\n     * \n     * @attribute\n     * @title Break Threshold\n     * @type {number}\n     */\n    breakingThreshold = 3.4e+38;\n\n    /**\n     * Enable collision between linked rigid bodies.\n     * \n     * @attribute\n     * @title Enable Collision\n     * @type {boolean}\n     */\n    enableCollision = true;\n\n    /**\n     * Enable to render a representation of the constraint.\n     * \n     * @attribute\n     * @title Debug Render\n     * @type {boolean}\n     */\n    debugRender = false;\n\n    /**\n     * The color of the debug rendering of the constraint.\n     * \n     * @attribute\n     * @title Debug Color\n     * @type {Color}\n     */\n    debugColor = new Color(1, 0, 0);\n\n    initialize() {\n        this.createConstraint();\n\n        this.on('attr', (name, value, prev) => {\n            // If any constraint properties change, recreate the constraint\n            if (name === 'pivotA' || name === 'entityB' || name === 'pivotB') {\n                this.createConstraint();\n            } else if (name === 'breakingThreshold') {\n                this.constraint.setBreakingImpulseThreshold(this.breakingThreshold);\n                this.activate();\n            }\n        });\n        this.on('enable', () => {\n            this.createConstraint();\n        });\n        this.on('disable', () => {\n            this.destroyConstraint();\n        });\n        this.on('destroy', () => {\n            this.destroyConstraint();\n        });\n    }\n\n    createConstraint() {\n        if (this.constraint) {\n            this.destroyConstraint();\n        }\n\n        var bodyA = this.entity.rigidbody.body;\n        var pivotA = new Ammo.btVector3(this.pivotA.x, this.pivotA.y, this.pivotA.z);\n        if (this.entityB && this.entityB.rigidbody) {\n            var bodyB = this.entityB.rigidbody.body;\n            var pivotB = new Ammo.btVector3(this.pivotB.x, this.pivotB.y, this.pivotB.z);\n            this.constraint = new Ammo.btPoint2PointConstraint(bodyA, bodyB, pivotA, pivotB);\n        } else {\n            this.constraint = new Ammo.btPoint2PointConstraint(bodyA, pivotA);\n        }\n\n        var dynamicsWorld = this.app.systems.rigidbody.dynamicsWorld;\n        dynamicsWorld.addConstraint(this.constraint, !this.enableCollision);\n\n        this.activate();\n    }\n\n    destroyConstraint() {\n        if (this.constraint) {\n            const dynamicsWorld = this.app.systems.rigidbody.dynamicsWorld;\n            dynamicsWorld.removeConstraint(this.constraint);\n            Ammo.destroy(this.constraint);\n            this.constraint = null;\n        }\n    }\n\n    activate() {\n        this.entity.rigidbody.activate();\n        if (this.entityB) {\n            this.entityB.rigidbody.activate();\n        }\n    }\n\n    update(dt) {\n        if (this.debugRender) {\n        // Note that it's generally bad to allocate new objects in an update function\n        // but this is just for debug rendering and will normally be disabled\n        var tempVecA = new Vec3();\n        this.entity.getWorldTransform().transformPoint(this.pivotA, tempVecA);\n        this.app.renderLine(this.entity.getPosition(), tempVecA, this.debugColor);\n        if (this.entityB) {\n            this.app.renderLine(this.entityB.getPosition(), tempVecA, this.debugColor);\n        }\n    }\n    }\n}\n\n"})})}),(0,o.jsx)(r.A,{value:"classic",label:"Classic",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"var PointToPointConstraint = pc.createScript('pointToPointConstraint');\n\nPointToPointConstraint.attributes.add('pivotA', {\n    title: 'Pivot',\n    description: 'Position of the constraint in the local space of this entity.',\n    type: 'vec3',\n    default: [0, 0, 0]\n});\nPointToPointConstraint.attributes.add('entityB', {\n    title: 'Connected Entity',\n    description: 'Optional second entity',\n    type: 'entity'\n});\nPointToPointConstraint.attributes.add('pivotB', {\n    title: 'Connected Pivot',\n    description: 'Position of the constraint in the local space of entity B (if specified).',\n    type: 'vec3',\n    default: [0, 0, 0]\n});\nPointToPointConstraint.attributes.add('breakingThreshold', {\n    title: 'Break Threshold',\n    description: 'Maximum breaking impulse threshold required to break the constraint.',\n    type: 'number',\n    default: 3.4e+38\n});\nPointToPointConstraint.attributes.add('enableCollision', {\n    title: 'Enable Collision',\n    description: 'Enable collision between linked rigid bodies.',\n    type: 'boolean',\n    default: true\n});\nPointToPointConstraint.attributes.add('debugRender', {\n    title: 'Debug Render',\n    description: 'Enable to render a representation of the constraint.',\n    type: 'boolean',\n    default: false\n});\nPointToPointConstraint.attributes.add('debugColor', {\n    title: 'Debug Color',\n    description: 'The color of the debug rendering of the constraint.',\n    type: 'rgb',\n    default: [1, 0, 0]\n});\n\n// initialize code called once per entity\nPointToPointConstraint.prototype.initialize = function() {\n    this.createConstraint();\n\n    this.on('attr', function(name, value, prev) {\n        // If any constraint properties change, recreate the constraint\n        if (name === 'pivotA' || name === 'entityB' || name === 'pivotB') {\n            this.createConstraint();\n        } else if (name === 'breakingThreshold') {\n            this.constraint.setBreakingImpulseThreshold(this.breakingThreshold);\n            this.activate();\n        }\n    });\n    this.on('enable', function () {\n        this.createConstraint();\n    });\n    this.on('disable', function () {\n        this.destroyConstraint();\n    });\n    this.on('destroy', function () {\n        this.destroyConstraint();\n    });\n};\n\nPointToPointConstraint.prototype.createConstraint = function() {\n    if (this.constraint) {\n        this.destroyConstraint();\n    }\n\n    var bodyA = this.entity.rigidbody.body;\n    var pivotA = new Ammo.btVector3(this.pivotA.x, this.pivotA.y, this.pivotA.z);\n    if (this.entityB && this.entityB.rigidbody) {\n        var bodyB = this.entityB.rigidbody.body;\n        var pivotB = new Ammo.btVector3(this.pivotB.x, this.pivotB.y, this.pivotB.z);\n        this.constraint = new Ammo.btPoint2PointConstraint(bodyA, bodyB, pivotA, pivotB);\n    } else {\n        this.constraint = new Ammo.btPoint2PointConstraint(bodyA, pivotA);\n    }\n\n    var dynamicsWorld = this.app.systems.rigidbody.dynamicsWorld;\n    dynamicsWorld.addConstraint(this.constraint, !this.enableCollision);\n\n    this.activate();\n};\n\nPointToPointConstraint.prototype.destroyConstraint = function() {\n    if (this.constraint) {\n        var dynamicsWorld = this.app.systems.rigidbody.dynamicsWorld;\n        dynamicsWorld.removeConstraint(this.constraint);\n        Ammo.destroy(this.constraint);\n        this.constraint = null;\n    }\n};\n\nPointToPointConstraint.prototype.activate = function() {\n    this.entity.rigidbody.activate();\n    if (this.entityB) {\n        this.entityB.rigidbody.activate();\n    }\n};\n\n// update code called every frame\nPointToPointConstraint.prototype.update = function(dt) {\n    if (this.debugRender) {\n        // Note that it's generally bad to allocate new objects in an update function\n        // but this is just for debug rendering and will normally be disabled\n        var tempVecA = new pc.Vec3();\n        this.entity.getWorldTransform().transformPoint(this.pivotA, tempVecA);\n        this.app.renderLine(this.entity.getPosition(), tempVecA, this.debugColor);\n        if (this.entityB) {\n            this.app.renderLine(this.entityB.getPosition(), tempVecA, this.debugColor);\n        }\n    }\n};\n"})})})]}),"\n",(0,o.jsxs)(n.p,{children:["You can find a project that implements all of the constraint types from ammo.js ",(0,o.jsx)(n.a,{href:"https://playcanvas.com/project/618829/overview/physics-constraints",children:"here"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"continuous-collision-detection",children:"Continuous Collision Detection"}),"\n",(0,o.jsx)(n.p,{children:"Sometimes, you might find that fast moving rigid bodies in your simulations pass through one another. To overcome this, ammo.js provides a concept called Continuous Collision Detection (or CCD for short). This enables additional checks for collisions by sweeping a sphere volume between the previous and current positions of a rigid body and looking for intersections with the volumes of other bodies."}),"\n",(0,o.jsx)(n.p,{children:"You can enable CCD for any PlayCanvas rigid body using the following script:"}),"\n",(0,o.jsxs)(a.A,{defaultValue:"classic",groupId:"script-code",children:[(0,o.jsx)(r.A,{value:"esm",label:"ESM",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"import { Script } from 'playcanvas';\n\nexport class Ccd extends Script {\n    static scriptName = \"ccd\";\n\n    /**\n     * Number of meters moved in one frame before CCD is enabled.\n     * \n     * @attribute\n     * @title Motion Threshold\n     * @type {number}\n     */\n    motionThreshold = 1;\n\n    /**\n     * This should be below the half extent of the collision volume. E.g., For an object of dimensions 1 meter, try 0.2.\n     * \n     * @attribute\n     * @title Swept Sphere Radius\n     * @type {number}\n     */\n    sweptSphereRadius = 0.2;\n\n    initialize() {\n        const body = this.entity.rigidbody.body;\n        body.setCcdMotionThreshold(this.motionThreshold);\n        body.setCcdSweptSphereRadius(this.sweptSphereRadius);\n\n        this.on('attr:motionThreshold', function(value) {\n            body = this.entity.rigidbody.body;\n            body.setCcdMotionThreshold(value);\n        });\n        this.on('attr:sweptSphereRadius', function(value) {\n            body = this.entity.rigidbody.body;\n            body.setCcdSweptSphereRadius(value);\n        });\n    }\n}\n"})})}),(0,o.jsx)(r.A,{value:"classic",label:"Classic",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"var Ccd = pc.createScript('ccd');\n\nCcd.attributes.add('motionThreshold', {\n    type: 'number',\n    default: 1,\n    title: 'Motion Threshold',\n    description: 'Number of meters moved in one frame before CCD is enabled'\n});\n\nCcd.attributes.add('sweptSphereRadius', {\n    type: 'number',\n    default: 0.2,\n    title: 'Swept Sphere Radius',\n    description: 'This should be below the half extent of the collision volume. E.g For an object of dimensions 1 meter, try 0.2'\n});\n\n// initialize code called once per entity\nCcd.prototype.initialize = function() {\n    var body; // Type btRigidBody\n\n    body = this.entity.rigidbody.body;\n    body.setCcdMotionThreshold(this.motionThreshold);\n    body.setCcdSweptSphereRadius(this.sweptSphereRadius);\n\n    this.on('attr:motionThreshold', function(value, prev) {\n        body = this.entity.rigidbody.body;\n        body.setCcdMotionThreshold(value);\n    });\n    this.on('attr:sweptSphereRadius', function(value, prev) {\n        body = this.entity.rigidbody.body;\n        body.setCcdSweptSphereRadius(value);\n    });\n};\n"})})})]}),"\n",(0,o.jsxs)(n.p,{children:["You can find a project that implements CCD ",(0,o.jsx)(n.a,{href:"https://playcanvas.com/project/447023/overview/physics-with-ccd",children:"here"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"These are just two examples of using the ammo.js API directly. You can also use it to implement additional things like:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Compound collision shapes"}),"\n",(0,o.jsx)(n.li,{children:"Soft body simulation"}),"\n",(0,o.jsx)(n.li,{children:"Cloth simulation"}),"\n",(0,o.jsx)(n.li,{children:"Vehicles"}),"\n"]})]})}function p(t={}){const{wrapper:n}={...(0,s.R)(),...t.components};return n?(0,o.jsx)(n,{...t,children:(0,o.jsx)(h,{...t})}):h(t)}}}]);