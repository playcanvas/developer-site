"use strict";(self.webpackChunkdeveloper_playcanvas_com=self.webpackChunkdeveloper_playcanvas_com||[]).push([[47772],{28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>l});var n=i(96540);const s={},r=n.createContext(s);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:t},e.children)}},67757:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/component-rigid-body-dynamic-4445b8fb008d63c06781163359a0a410.png"},95720:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/trigger_setup-d9648f7e24e200f3ae06cdb6c7f24ac3.jpg"},98930:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/collision_and_triggers-6003c6ce32c2321eb92814181b0874e2.jpg"},99269:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"tutorials/collision-and-triggers","title":"Collision and Triggers","description":"Rigidbodies collide with each other, a sound is played on a collision and a trigger volume resets the shapes.","source":"@site/docs/tutorials/collision-and-triggers.md","sourceDirName":"tutorials","slug":"/tutorials/collision-and-triggers","permalink":"/tutorials/collision-and-triggers","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/tutorials/collision-and-triggers.md","tags":[{"inline":true,"label":"collision","permalink":"/tags/collision"},{"inline":true,"label":"physics","permalink":"/tags/physics"}],"version":"current","frontMatter":{"title":"Collision and Triggers","tags":["collision","physics"],"thumb":"https://s3-eu-west-1.amazonaws.com/images.playcanvas.com/projects/12/405871/0D7E2F-image-75.jpg"},"sidebar":"tutorialsSidebar","previous":{"title":"Changing textures at runtime","permalink":"/tutorials/changing-textures-at-runtime"},"next":{"title":"Compound Physics Shapes","permalink":"/tutorials/compound-physics-shapes"}}');var s=i(74848),r=i(28453);const o={title:"Collision and Triggers",tags:["collision","physics"],thumb:"https://s3-eu-west-1.amazonaws.com/images.playcanvas.com/projects/12/405871/0D7E2F-image-75.jpg"},l=void 0,a={},c=[{value:"The Collision Component",id:"the-collision-component",level:2},{value:"Trigger Volumes",id:"trigger-volumes",level:3},{value:"Rigid Bodies",id:"rigid-bodies",level:3},{value:"Setting up the ground",id:"setting-up-the-ground",level:2},{value:"Setting up the trigger",id:"setting-up-the-trigger",level:2},{value:"The Rigid Bodies",id:"the-rigid-bodies",level:2},{value:"Contact Events",id:"contact-events",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("div",{className:"iframe-container",children:(0,s.jsx)("iframe",{src:"https://playcanv.as/p/1Hj5fX2I/",title:"Collision and Triggers",allow:"camera; microphone; xr-spatial-tracking; fullscreen",allowfullscreen:!0})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:"Rigidbodies collide with each other, a sound is played on a collision and a trigger volume resets the shapes."})}),"\n",(0,s.jsxs)(t.p,{children:["This tutorial introduces the basics of rigid-body physics, collision detection and trigger volumes. Have a look at the ",(0,s.jsx)(t.a,{href:"https://playcanvas.com/project/405871",children:"tutorial project"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"the-collision-component",children:"The Collision Component"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.em,{children:"collision"})," component defines a shape which can be used either to trigger events if another Entity enters or exits it -- we call this a Trigger Volume -- or it can be used together with the ",(0,s.jsx)(t.em,{children:"rigidbody"})," component to give an Entity physical properties in your game -- like a bouncing ball or a heavy crate."]}),"\n",(0,s.jsxs)(t.p,{children:["The most important property of a ",(0,s.jsx)(t.em,{children:"collision"})," component is it's ",(0,s.jsx)(t.strong,{children:"Type"}),", this determines the shape of the volume that will be used. There are four options:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Box"})," A simple box"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Sphere"})," A simple sphere"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Capsule"})," A pill-shaped capsule. Useful for characters, as it can be tall and thin, but has a nice rounded-base with a single contact point."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Mesh"})," Use any arbitrary mesh shape for the volume. ",(0,s.jsx)(t.strong,{children:"Note"})," There are some limitations to the mesh collision, in particular, when using it with the ",(0,s.jsx)(t.em,{children:"rigidbody"})," component, they must be ",(0,s.jsx)(t.strong,{children:"Static"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"trigger-volumes",children:"Trigger Volumes"}),"\n",(0,s.jsxs)(t.p,{children:["To create a Trigger Volume all we need to do is add a ",(0,s.jsx)(t.em,{children:"collision"})," component to an Entity. In this tutorial we're adding a large box-shaped Trigger Volume underneath the slope to catch the falling bodies and reset their position."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Collisions &amp; Triggers",src:i(98930).A+"",width:"640",height:"582"})}),"\n",(0,s.jsx)(t.p,{children:"You can see the trigger volume underneath the ramp displayed as a blue outline."}),"\n",(0,s.jsx)(t.h3,{id:"rigid-bodies",children:"Rigid Bodies"}),"\n",(0,s.jsx)(t.p,{children:"A rigid body is a physical presence in your game world. You can set it up with real physics properties like Mass and Friction; it will collide with other rigid bodies and respond in a realistic manner."}),"\n",(0,s.jsxs)(t.p,{children:["To create a rigid body in your Scene, pick an Entity and add a ",(0,s.jsx)(t.em,{children:"rigidbody"})," component and a ",(0,s.jsx)(t.em,{children:"collision"})," component. By default you will create a ",(0,s.jsx)(t.strong,{children:"static box"}),". The ",(0,s.jsx)(t.em,{children:"rigidbody"})," component has a multitude of options which you can use to tune the properties of your object."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"rigidbody component",src:i(67757).A+"",width:"627",height:"418"})}),"\n",(0,s.jsxs)(t.p,{children:["For details on each property take a look at the ",(0,s.jsxs)(t.a,{href:"/user-manual/scenes/components/rigidbody/",children:[(0,s.jsx)(t.em,{children:"rigidbody"})," documentation"]}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["For this demo, the important property is the ",(0,s.jsx)(t.strong,{children:"Type"}),". You can pick one of three options:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Static"})," this Entity will never move."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Dynamic"})," this Entity will move under gravity and any other forces that you apply to it."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Kinematic"})," this Entity will not respond to forces, but will move if you directly set it's position or velocity."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"setting-up-the-ground",children:"Setting up the ground"}),"\n",(0,s.jsx)(t.p,{children:"The first Entity we need in this tutorial is the green block that forms the ground."}),"\n",(0,s.jsx)("img",{loading:"lazy",src:"/img/tutorials/collision/ground_setup.png",width:"300"}),"\n",(0,s.jsxs)(t.p,{children:["You can see in the attribute panel, that it has ",(0,s.jsx)(t.em,{children:"render"}),", ",(0,s.jsx)(t.em,{children:"collision"})," and ",(0,s.jsx)(t.em,{children:"rigidbody"})," components. We've increased the Entity and the ",(0,s.jsx)(t.em,{children:"collision"})," box properties so that it is nice and large. And we've also slightly increased the friction and restitution properties. This means that the surface is slightly rougher and slightly bouncier than the defaults."]}),"\n",(0,s.jsx)(t.h2,{id:"setting-up-the-trigger",children:"Setting up the trigger"}),"\n",(0,s.jsx)(t.p,{children:"The next Entity we'll need is the trigger."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Trigger Entity",src:i(95720).A+"",width:"316",height:"228"})}),"\n",(0,s.jsxs)(t.p,{children:["With this Entity we have a ",(0,s.jsx)(t.em,{children:"collision"})," component but no ",(0,s.jsx)(t.em,{children:"rigidbody"})," so it acts as a trigger. The trigger Entity also has a ",(0,s.jsx)(t.em,{children:"script"})," component with some code attached. Triggers are only useful if something happens when they are triggered, so we need to add some code to fire and listen for events when the trigger is activated."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"var Trigger = pc.createScript('trigger');\n\n// initialize code called once per entity\nTrigger.prototype.initialize = function() {\n    this.entity.collision.on('triggerenter', this.onTriggerEnter, this);\n};\n\nTrigger.prototype.onTriggerEnter = function(entity) {\n    entity.rigidbody.linearVelocity = pc.Vec3.ZERO;\n    entity.rigidbody.angularVelocity = pc.Vec3.ZERO;\n    // Reset back to roughly the position the entity started in.\n    var position = entity.getPosition();\n    entity.rigidbody.teleport(position.x, 10, 0);\n};\n"})}),"\n",(0,s.jsx)(t.p,{children:"There two significant parts to the code above."}),"\n",(0,s.jsxs)(t.p,{children:["First in the ",(0,s.jsx)(t.code,{children:"initialize"})," method we start listening to the ",(0,s.jsx)(t.strong,{children:"triggerenter"})," event. This event fires once when a rigid body enters a trigger volume (where a trigger volume is an entity that has a collision component but no rigidbody component). The companion event is ",(0,s.jsx)(t.strong,{children:"triggerleave"})," which is fired once the penetrating rigid body leaves the trigger."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"this.entity.collision.on('triggerenter', this.onTriggerEnter, this);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Notice, the third argument, ",(0,s.jsx)(t.code,{children:"this"}),", which is the 'scope' that will be used in the event listener. Usually, you'll want to add the current Script Object as the third argument so that the value of ",(0,s.jsx)(t.code,{children:"this"})," in the event listener is that same Script Object."]}),"\n",(0,s.jsxs)(t.p,{children:["The second part of this code is the function which handles the event, ",(0,s.jsx)(t.code,{children:"onTriggerEnter"}),". When the trigger is entered, this function is called and passed the ",(0,s.jsx)(t.a,{href:"https://api.playcanvas.com/engine/classes/Entity.html",children:(0,s.jsx)(t.code,{children:"Entity"})})," object entering the trigger volume."]}),"\n",(0,s.jsx)(t.p,{children:"In this case, when the trigger is fired, we reset the penetrating Entity back up to the position it started in, and reset its velocities."}),"\n",(0,s.jsx)(t.h2,{id:"the-rigid-bodies",children:"The Rigid Bodies"}),"\n",(0,s.jsxs)(t.p,{children:["We've set the ground to ",(0,s.jsx)(t.strong,{children:"Static"}),", now we'll create the falling objects and make sure they are ",(0,s.jsx)(t.strong,{children:"Dynamic"}),"."]}),"\n",(0,s.jsx)("img",{loading:"lazy",src:"/img/tutorials/collision/box_setup.png",width:"300"}),"\n",(0,s.jsxs)(t.p,{children:["This is the ",(0,s.jsx)(t.em,{children:"rigidbody"})," and ",(0,s.jsx)(t.em,{children:"collision"})," setup for the box component, the sphere and capsule are setup in the same way."]}),"\n",(0,s.jsx)(t.h2,{id:"contact-events",children:"Contact Events"}),"\n",(0,s.jsxs)(t.p,{children:["There are three events available on the ",(0,s.jsx)(t.em,{children:"collision"})," component:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"contact"})," - fires for every point of contact when two rigid bodies touch."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"collisionstart"})," - fires at the start of a collision when two rigid bodies touch."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"collisionend"})," - fires when two rigid bodies separate."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The difference between ",(0,s.jsx)(t.strong,{children:"contact"})," and ",(0,s.jsx)(t.strong,{children:"collisionstart"})," is subtle but important. Imagine a cube landing at an angle on a flat surface. When the edge of the cube hits the surface the two corners of the cube will strike at the same moment. Three events will fire, two ",(0,s.jsx)(t.strong,{children:"contact"})," events for each corner of the cube, and one ",(0,s.jsx)(t.strong,{children:"collisionstart"})," event. Then the cube will rotate and continue to fall until it lies flat, all the while remaining in contact with the surface. When it lands flat, two more ",(0,s.jsx)(t.strong,{children:"contact"})," events will fire as the edge of the cube hits the surface. As the cube remained in contact with the surface all that time, no more ",(0,s.jsx)(t.strong,{children:"collisionstart"})," events are fired."]}),"\n",(0,s.jsxs)(t.p,{children:["Both events are useful, but in this demo we'll use the ",(0,s.jsx)(t.strong,{children:"collisionstart"})," event to trigger a sound effect that plays when the objects hit the ground. Here's the code:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"var Collider = pc.createScript('collider');\n\n// initialize code called once per entity\nCollider.prototype.initialize = function () {\n    this.entity.collision.on('collisionstart', this.onCollisionStart, this);\n};\n\nCollider.prototype.onCollisionStart = function (result) {\n    if (result.other.rigidbody) {\n        this.entity.sound.play(\"hit\");\n    }\n};\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In the ",(0,s.jsx)(t.code,{children:"initialize"})," method we set up the event listener, and then in the event handler we check to see if the other entity has a ",(0,s.jsx)(t.strong,{children:"rigidbody"}),' component (this is to avoid playing a sound when we enter a trigger volume) and then we play the "hit" sound effect. So now, every time an Entity with the collider script attached collides with another rigid body, it will play the hit sound.']}),"\n",(0,s.jsx)(t.p,{children:"And that's all there is to handling Collisions and Triggers in PlayCanvas."})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);