"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[31912],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>c});var i=r(96540);const a={},t=i.createContext(a);function s(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(t.Provider,{value:n},e.children)}},47563:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"user-manual/graphics/advanced-rendering/indirect-drawing","title":"Indirect Drawing","description":"Indirect drawing is a GPU-driven rendering technique where draw call parameters (such as vertex count, instance count, etc.) are stored in GPU buffer memory rather than being specified directly by the CPU. This allows compute shaders to dynamically generate or modify rendering parameters, enabling more efficient GPU-driven rendering workflows.","source":"@site/docs/user-manual/graphics/advanced-rendering/indirect-drawing.md","sourceDirName":"user-manual/graphics/advanced-rendering","slug":"/user-manual/graphics/advanced-rendering/indirect-drawing","permalink":"/user-manual/graphics/advanced-rendering/indirect-drawing","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/graphics/advanced-rendering/indirect-drawing.md","tags":[],"version":"current","frontMatter":{"title":"Indirect Drawing"},"sidebar":"userManualSidebar","previous":{"title":"Multiple Render Targets","permalink":"/user-manual/graphics/advanced-rendering/multiple-render-targets"},"next":{"title":"Gaussian Splatting","permalink":"/user-manual/gaussian-splatting/"}}');var a=r(74848),t=r(28453);const s={title:"Indirect Drawing"},c=void 0,d={},l=[{value:"How Indirect Drawing Works",id:"how-indirect-drawing-works",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Setting Up Indirect Drawing",id:"setting-up-indirect-drawing",level:3},{value:"Configuring Buffer Size",id:"configuring-buffer-size",level:3},{value:"Understanding the Indirect Draw Buffer",id:"understanding-the-indirect-draw-buffer",level:3},{value:"Using with Compute Shaders",id:"using-with-compute-shaders",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"Live Example",id:"live-example",level:2}];function o(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Indirect drawing is a GPU-driven rendering technique where draw call parameters (such as vertex count, instance count, etc.) are stored in GPU buffer memory rather than being specified directly by the CPU. This allows compute shaders to dynamically generate or modify rendering parameters, enabling more efficient GPU-driven rendering workflows."}),"\n",(0,a.jsxs)(n.p,{children:["This feature is currently ",(0,a.jsx)(n.strong,{children:"only supported on WebGPU"})," (you can check WebGPU availability using ",(0,a.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/GraphicsDevice.html#iswebgpu",children:(0,a.jsx)(n.code,{children:"GraphicsDevice.isWebGPU"})}),") and is ignored on other platforms."]}),"\n",(0,a.jsx)(n.h2,{id:"how-indirect-drawing-works",children:"How Indirect Drawing Works"}),"\n",(0,a.jsx)(n.p,{children:"In traditional rendering, the CPU specifies draw parameters like vertex count and instance count for each draw call. With indirect drawing, these parameters are stored in a GPU buffer, and the GPU reads them during rendering. This enables:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"GPU-driven culling"}),": Compute shaders can determine which objects to render"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dynamic instance counts"}),": Procedurally control how many instances to draw"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reduced CPU overhead"}),": Less CPU-GPU synchronization"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Complex rendering effects"}),": Enable advanced techniques like GPU-driven LOD selection"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(n.h3,{id:"setting-up-indirect-drawing",children:"Setting Up Indirect Drawing"}),"\n",(0,a.jsxs)(n.p,{children:["Indirect drawing requires allocating a slot in the indirect draw buffer and assigning it to a mesh instance. ",(0,a.jsx)(n.strong,{children:"Important"}),": slots must be allocated fresh each frame:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Get a fresh slot every frame\nconst indirectSlot = app.graphicsDevice.getIndirectDrawSlot();\n\n// Configure the mesh instance to use indirect rendering\n// First parameter: camera component (or null for all cameras)\n// Second parameter: the allocated slot\nmeshInstance.setIndirect(null, indirectSlot);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"configuring-buffer-size",children:"Configuring Buffer Size"}),"\n",(0,a.jsx)(n.p,{children:"Control the maximum number of indirect draw calls per frame:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Set maximum indirect draw calls per frame (default: 1024)\napp.graphicsDevice.maxIndirectDrawCount = 2048;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"understanding-the-indirect-draw-buffer",children:"Understanding the Indirect Draw Buffer"}),"\n",(0,a.jsx)(n.p,{children:"The indirect draw buffer is a storage buffer that holds draw call parameters. It's automatically managed by the graphics device:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Access via ",(0,a.jsx)(n.code,{children:"app.graphicsDevice.indirectDrawBuffer"})]}),"\n",(0,a.jsxs)(n.li,{children:["Size controlled by ",(0,a.jsx)(n.code,{children:"maxIndirectDrawCount"})," property"]}),"\n",(0,a.jsxs)(n.li,{children:["Each slot contains: ",(0,a.jsx)(n.code,{children:"indexCount"}),", ",(0,a.jsx)(n.code,{children:"instanceCount"}),", ",(0,a.jsx)(n.code,{children:"firstIndex"}),", ",(0,a.jsx)(n.code,{children:"baseVertex"}),", ",(0,a.jsx)(n.code,{children:"firstInstance"})]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"using-with-compute-shaders",children:"Using with Compute Shaders"}),"\n",(0,a.jsxs)(n.p,{children:["Indirect drawing is most powerful when combined with compute shaders that generate the draw parameters. The ",(0,a.jsx)(n.code,{children:"getIndirectMetaData()"})," method returns essential mesh information for compute shaders:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Get mesh metadata needed for indirect rendering\n// Returns Int32Array [count, base, baseVertex, 0]\nconst meshMetaData = meshInstance.getIndirectMetaData();\n\n// Create compute shader to control rendering parameters\nconst compute = new pc.Compute(device, shader, 'IndirectDrawCompute');\ncompute.setParameter('indirectMetaData', meshMetaData);\ncompute.setParameter('indirectDrawBuffer', app.graphicsDevice.indirectDrawBuffer);\ncompute.setParameter('indirectSlot', indirectSlot);\n\n// Dispatch compute shader to generate draw parameters\ndevice.computeDispatch([compute], 'GenerateIndirectDraw');\n"})}),"\n",(0,a.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,a.jsx)(n.p,{children:"For detailed API documentation, refer to these PlayCanvas engine classes and methods:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/MeshInstance.html#setindirect",children:(0,a.jsx)(n.code,{children:"MeshInstance.setIndirect()"})})," - Configure a mesh instance for indirect rendering"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/GraphicsDevice.html#getindirectdrawslot",children:(0,a.jsx)(n.code,{children:"GraphicsDevice.getIndirectDrawSlot()"})})," - Allocate a slot in the indirect draw buffer"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/GraphicsDevice.html#indirectdrawbuffer",children:(0,a.jsx)(n.code,{children:"GraphicsDevice.indirectDrawBuffer"})})," - Access the indirect draw buffer"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/GraphicsDevice.html#maxindirectdrawcount",children:(0,a.jsx)(n.code,{children:"GraphicsDevice.maxIndirectDrawCount"})})," - Control maximum indirect draw calls per frame"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"live-example",children:"Live Example"}),"\n",(0,a.jsxs)(n.p,{children:["See the ",(0,a.jsx)(n.a,{href:"https://playcanvas.github.io/#/compute/indirect-draw",children:"Indirect Draw example"})," for a complete demonstration of indirect drawing with animated instance counts."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);