"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[41344],{7184:(e,n,t)=>{t.d(n,{C:()=>N,G:()=>b});var s=t(11470),i=t(19365),o=t(59849),a=t(96540),d=t(95293),r=t(58640),l=t(18676),c=t(58817),h=t(19748),p=t(83395),u=t(43025),m=t(10977),y=t(7306),g=t(55937),f=t(78692),x=t(8939),j=t(40050),v=t(93953),w=t(27351),M=t(74848);const G="// \u2191 imports hidden",b=({code:e,label:n,filename:t,language:d="jsx",showDemo:l=!1,showViewSourceButton:c=!0,showControls:h=!0,children:p})=>{const[u,m]=(0,a.useState)(0);if(!p||!e)return console.error("CodeExample: code and children are required"),null;return(0,M.jsxs)(s.A,{defaultValue:u>0?"Code":l?"Demo":"Code",children:[(0,M.jsx)(i.A,{value:"Demo",children:(0,M.jsxs)("div",{className:"code-example-demo",children:[p,c&&(0,M.jsxs)("div",{className:"code-example-demo-footer",children:[n," - ",(0,M.jsx)("a",{href:"#",onClick:e=>{e.preventDefault(),m(e=>e+1)},children:"View Code"})]}),(0,M.jsx)("div",{className:"code-example-controls",children:(0,M.jsx)(r.XA,{fill:!0,hidden:!1===h})})]})}),(0,M.jsx)(i.A,{value:"Code",children:(0,M.jsx)(o.A,{language:d,title:t,children:e.includes(G)?G+e.split(G)[1]:e})})]},u)},k=e=>{const{width:n=8,depth:t=8,intensity:s=.75}=e,i=(0,a.useMemo)(()=>new v.e(n,1,t),[n,t]);return(0,M.jsxs)(l.w,{children:[(0,M.jsx)(h.v,{type:"directional",castShadows:!0,normalOffsetBias:0,shadowBias:0,shadowDistance:16,shadowResolution:1024,shadowType:w.au1,shadowUpdateMode:w.M5l,vsmBlurSize:8,shadowIntensity:s,intensity:0}),(0,M.jsx)(p.e,{script:x.X,intensity:s,scale:i})]})},N=({children:e,useLight:n=!0,useControls:t=!1,useGrid:s=!1,useShadow:i=!1,camera:o=[0,0,10],sceneOffset:r=[0,-.501,0],exposure:h=1})=>{const{colorMode:x}=(0,d.G)(),v=(0,m.n)(),{asset:w}=(0,y.yj)("/assets/helipad.png"),G="dark"===x?"#2a2a2a":"#e4e0e0",[b,N]=(0,a.useState)(!1),[L,A]=(0,a.useState)(!1),E=(0,a.useCallback)(()=>N(!0),[]),C=(0,a.useCallback)(()=>N(!1),[]),B=(0,a.useCallback)(()=>A(!0),[]),S=(0,a.useCallback)(()=>A(!1),[]);return(0,a.useEffect)(()=>{const e=v.graphicsDevice.canvas;e.style.cursor=b?"grabbing":L?"grab":"default"},[b,L,v]),(0,a.useEffect)(()=>{const e=()=>N(!1);return v.graphicsDevice.canvas.addEventListener("pointerup",e),()=>v.graphicsDevice?.canvas.removeEventListener("pointerup",e)},[v]),(0,M.jsxs)(l.w,{children:[(0,M.jsxs)(l.w,{name:"camera",position:o,children:[(0,M.jsx)(c.i,{clearColor:G,renderSceneColorMap:!0}),t&&(0,M.jsx)(p.e,{script:g.a,enableFly:!1,pitchRange:new j.Z(-90,-5)})]}),n&&(0,M.jsx)(u.O,{envAtlas:w,showSkybox:!1,exposure:h}),s&&(0,M.jsx)(l.w,{name:"grid",scale:[1e3,1,1e3],position:[0,-.5,0],children:(0,M.jsx)(p.e,{script:f.x})}),i&&(0,M.jsx)(l.w,{position:r,children:(0,M.jsx)(k,{})}),(0,M.jsx)(l.w,{onPointerOver:B,onPointerOut:S,onPointerDown:E,onPointerUp:C,children:e})]})}},24421:(e,n,t)=>{t.d(n,{A:()=>h});var s=t(18676),i=t(19748),o=t(83395),a=t(93953),d=t(27351),r=t(8939),l=t(96540),c=t(74848);const h=e=>{const{width:n=2,depth:t=2,intensity:h=.75}=e,p=(0,l.useMemo)(()=>new a.e(n,1,t),[n,t]);return(0,c.jsxs)(s.w,{position:[0,.001,0],children:[(0,c.jsx)(i.v,{type:"directional",castShadows:!0,normalOffsetBias:0,shadowBias:0,shadowDistance:16,shadowResolution:1024,shadowType:d.au1,shadowUpdateMode:d.M5l,vsmBlurSize:8,shadowIntensity:h,intensity:0}),(0,c.jsx)(o.e,{script:r.X,intensity:h,scale:p})]})}},30728:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>x,contentTitle:()=>f,default:()=>w,frontMatter:()=>g,metadata:()=>s,toc:()=>j});const s=JSON.parse('{"id":"user-manual/playcanvas-react/guide/modifying-glb-models","title":"Modifying GLB Models","description":"3D models are usually provided as standalone assets. They can feel like black boxes, which makes even small tweaks awkward\u2014you have to reopen a DCC tool, make the change, export, and repeat whenever the model updates.","source":"@site/docs/user-manual/playcanvas-react/guide/modifying-glb-models.mdx","sourceDirName":"user-manual/playcanvas-react/guide","slug":"/user-manual/playcanvas-react/guide/modifying-glb-models","permalink":"/user-manual/playcanvas-react/guide/modifying-glb-models","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/playcanvas-react/guide/modifying-glb-models.mdx","tags":[],"version":"current","frontMatter":{"title":"Modifying GLB Models"},"sidebar":"userManualSidebar","previous":{"title":"Loading Assets","permalink":"/user-manual/playcanvas-react/guide/loading-assets"},"next":{"title":"Physics","permalink":"/user-manual/playcanvas-react/guide/physics"}}');var i=t(74848),o=t(28453),a=t(7184),d=t(58769),r=t(18676),l=t(7306),c=t(33257);const h=()=>{const{asset:e,error:n}=(0,l.fn)("/assets/statue.glb");return n?(console.error("Error loading model:",n),null):e?(0,i.jsx)(r.w,{name:"asset",children:(0,i.jsx)(c.A,{asset:e},e.id)}):null},p="import { useModel } from '@playcanvas/react/hooks';\nimport { Gltf, Entity } from '@playcanvas/react';\n\nexport const GltfBasic = () => {\n  const { asset, error } = useModel('/assets/statue.glb');\n\n  if (error) {\n    console.error('Error loading model:', error);\n    return null;\n  }\n\n  if (!asset) return null;\n\n  return <Entity name='asset'>\n    <Gltf asset={asset} key={asset.id} />\n  </Entity>;\n};\n\n";var u=t(19276);const m=()=>{const{asset:e,error:n}=(0,l.fn)("/assets/statue.glb");return n?(console.error("Error loading model:",n),null):e?(0,i.jsx)(c.A,{asset:e,children:(0,i.jsx)(u.B.Node,{path:"**[light]",children:(0,i.jsx)(u.B.Light,{remove:!0})})},e.id):null},y="import { useModel } from '@playcanvas/react/hooks';\nimport { Gltf, Modify } from '@playcanvas/react';\n\nexport const GltfRemoveLights = () => {\n  const { asset, error } = useModel('/assets/statue.glb');\n\n  if (error) {\n    console.error('Error loading model:', error);\n    return null;\n  }\n\n  if (!asset) return null;\n\n  return (\n    <Gltf asset={asset} key={asset.id}>\n      <Modify.Node path=\"**[light]\">\n        <Modify.Light remove />\n      </Modify.Node>\n    </Gltf>\n  );\n};\n\n",g={title:"Modifying GLB Models"},f=void 0,x={},j=[{value:"The <code>&lt;Gltf&gt;</code> Component",id:"the-gltf-component",level:2},{value:"Modifying GLB Models",id:"modifying-glb-models",level:2},{value:"Finding the Right Nodes",id:"finding-the-right-nodes",level:2},{value:"Adding Components &amp; Entities",id:"adding-components--entities",level:2},{value:"Adding Physics",id:"adding-physics",level:3},{value:"Adding Animations",id:"adding-animations",level:3},{value:"Adding a New Entity",id:"adding-a-new-entity",level:3},{value:"Modifying Existing Components",id:"modifying-existing-components",level:2},{value:"Removing Components",id:"removing-components",level:3},{value:"Changing Light Properties",id:"changing-light-properties",level:3},{value:"Updating Render Properties",id:"updating-render-properties",level:3},{value:"Functional Updates",id:"functional-updates",level:3},{value:"Finding Entities with useEntity",id:"finding-entities-with-useentity",level:2},{value:"Using Path Patterns",id:"using-path-patterns",level:3},{value:"Using Predicate Functions",id:"using-predicate-functions",level:3},{value:"Multiple Modifications",id:"multiple-modifications",level:2},{value:"Related",id:"related",level:2}];function v(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"3D models are usually provided as standalone assets. They can feel like black boxes, which makes even small tweaks awkward\u2014you have to reopen a DCC tool, make the change, export, and repeat whenever the model updates."}),"\n",(0,i.jsx)(n.p,{children:"There are plenty of scenarios where you need to inspect or adjust a model in code. Maybe the source GLB includes lights you don't want. Maybe you\u2019re building a car configurator and need to drive the headlights\u2019 emissive intensity from React state. Or perhaps you want every mesh in the model to get physics components."}),"\n",(0,i.jsxs)(n.h2,{id:"the-gltf-component",children:["The ",(0,i.jsx)(n.code,{children:"<Gltf>"})," Component"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"<Gltf>"})," component is a one-stop shop for rendering a GLB model and customizing it. It works just like ",(0,i.jsx)(n.code,{children:"<Render>"}),", but exposes the model\u2019s internal hierarchy."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { useModel } from '@playcanvas/react/hooks';\nimport { Gltf } from '@playcanvas/react';\n\nconst GltfModel = () => {\n  const { asset } = useModel('model.glb');\n  return <Gltf asset={asset} key={asset.id} />;\n};\n"})}),"\n",(0,i.jsx)(a.G,{label:"Rendering a GLB model with Gltf",code:p,showDemo:!0,children:(0,i.jsx)(d.l,{children:(0,i.jsx)(a.C,{useLight:!0,useShadow:!0,useGrid:!0,camera:[2,1,2],useControls:!0,exposure:3,children:(0,i.jsx)(r.w,{name:"model",scale:[.1,.1,.1],position:[0,-.5,0],children:(0,i.jsx)(h,{})})})})}),"\n",(0,i.jsx)(n.h2,{id:"modifying-glb-models",children:"Modifying GLB Models"}),"\n",(0,i.jsxs)(n.p,{children:["You can modify a GLB model with the ",(0,i.jsx)(n.code,{children:"<Modify>"})," component. It selects subnodes in the hierarchy and applies updates to each match. You can add, remove, or adjust components and even insert new entities."]}),"\n",(0,i.jsx)(n.p,{children:"Here\u2019s how you might attach a light to a hand on the model:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'<Gltf asset={asset} key={asset.id}>\n  {/* Select the Hand child under Arm under Body */}\n  <Modify.Node path="Body.Arm.Hand">\n    <Light color="red" intensity={2} />\n  </Modify.Node>\n</Gltf>\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"<Modify.Node>"})," accepts a ",(0,i.jsx)(n.code,{children:"path"})," prop that identifies which nodes to modify. In this example we\u2019re targeting the ",(0,i.jsx)(n.code,{children:'"Hand"'})," node beneath ",(0,i.jsx)(n.code,{children:'"Arm"'})," beneath ",(0,i.jsx)(n.code,{children:'"Body"'}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"finding-the-right-nodes",children:"Finding the Right Nodes"}),"\n",(0,i.jsxs)(n.p,{children:["The path prop accepts a glob-like pattern for selecting nodes. This means you can select multiple components at once. For example if you want to select every ",(0,i.jsx)(n.code,{children:'"Hand"'})," under the ",(0,i.jsx)(n.code,{children:'"Body"'})," node in the model you can use a wildcard pattern:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'{/* Load the model */}\n<Gltf asset={asset} key={asset.id}>\n  {/* Select all hand nodes under the Body node */}\n  <Modify.Node path="Body.**.Hand">\n    {/* Add a light to each hand */}\n    <Light color="red" intensity={2} />\n  </Modify.Node>\n</Gltf>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You can also select nodes by their component type. For example if you want to select all nodes with a ",(0,i.jsx)(n.code,{children:'"Light"'})," component you can use the ",(0,i.jsx)(n.code,{children:'"[light]"'})," pattern:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'{/* Load the model */}\n<Gltf asset={asset} key={asset.id}>\n  {/* Select all nodes with a Light component under the Body node */}\n  <Modify.Node path="Body.**[light]">\n    {/* Adjust each matching light */}\n    <Light color="red" intensity={2} />\n  </Modify.Node>\n</Gltf>\n'})}),"\n",(0,i.jsx)(n.p,{children:"To modify nodes in your GLB, you need to find them using path patterns. Here are the most common patterns:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Exact path"}),": ",(0,i.jsx)(n.code,{children:'"Body.Arm.Hand"'})," - Selects a specific node path"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single wildcard"}),": ",(0,i.jsx)(n.code,{children:'"Body.*"'})," - Selects all direct children of Body"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-level wildcard"}),": ",(0,i.jsx)(n.code,{children:'"Body.**"'})," - Selects all descendants of Body at any depth"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"All nodes"}),": ",(0,i.jsx)(n.code,{children:'"**"'})," - Selects every node in the hierarchy"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Component filter"}),": ",(0,i.jsx)(n.code,{children:'"**[light]"'})," - Selects all nodes with a light component"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Combined"}),": ",(0,i.jsx)(n.code,{children:'"Head.*[light]"'})," - Selects all direct children of Head that have a light component"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"You can also use a predicate function to match nodes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"<Modify.Node path={(entity) => entity.name.includes('Weapon')}>\n  <Modify.Render castShadows />\n</Modify.Node>\n"})}),"\n",(0,i.jsx)(n.h2,{id:"adding-components--entities",children:"Adding Components & Entities"}),"\n",(0,i.jsx)(n.p,{children:"You can add new components or entities to specific nodes in your GLB. This is useful for attaching animations, adding physics, or inserting new elements into the hierarchy."}),"\n",(0,i.jsx)(n.h3,{id:"adding-physics",children:"Adding Physics"}),"\n",(0,i.jsx)(n.p,{children:"You can add collision and rigidbody components to specific meshes in your GLB:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'import { Gltf, Modify } from \'@playcanvas/react\';\nimport { Collision, Rigidbody } from \'@playcanvas/react/components\';\n\n<Gltf asset={asset} key={asset.id}>\n  <Modify.Node path="Body.Mesh">\n    <Collision type="box" />\n    <Rigidbody type="dynamic" mass={10} />\n  </Modify.Node>\n</Gltf>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This adds physics components to the mesh found at the path ",(0,i.jsx)(n.code,{children:'"Body.Mesh"'}),". The mesh will now participate in physics simulations."]}),"\n",(0,i.jsx)(n.h3,{id:"adding-animations",children:"Adding Animations"}),"\n",(0,i.jsxs)(n.p,{children:["If you need to attach an animation component to your model's skeleton, find the skeleton root node and add the ",(0,i.jsx)(n.code,{children:"<Anim>"})," component:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { Gltf, Modify } from '@playcanvas/react';\nimport { Anim } from '@playcanvas/react/components';\n\n<Gltf asset={asset} key={asset.id}>\n  <Modify.Node path=\"Root\">\n    <Anim asset={asset} clip=\"Walk\" loop />\n  </Modify.Node>\n</Gltf>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The path ",(0,i.jsx)(n.code,{children:'"Root"'})," selects the root node of your GLB. You may need to adjust this based on your model's structure - common names are ",(0,i.jsx)(n.code,{children:'"Root"'}),", ",(0,i.jsx)(n.code,{children:'"Scene"'}),", or the name of your skeleton root entity."]}),"\n",(0,i.jsx)(n.h3,{id:"adding-a-new-entity",children:"Adding a New Entity"}),"\n",(0,i.jsx)(n.p,{children:"You can also add entirely new entities as children of nodes in your GLB:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'import { Gltf, Modify } from \'@playcanvas/react\';\nimport { Entity, Light } from \'@playcanvas/react/components\';\n\n<Gltf asset={asset} key={asset.id}>\n  <Modify.Node path="Head">\n    <Entity name="HelmetLight" position={[0, 0.5, 0]}>\n      <Light type="omni" color="yellow" intensity={3} />\n    </Entity>\n  </Modify.Node>\n</Gltf>\n'})}),"\n",(0,i.jsx)(n.h2,{id:"modifying-existing-components",children:"Modifying Existing Components"}),"\n",(0,i.jsx)(n.p,{children:"You can modify properties of existing components without removing them. This merges your changes with the existing component properties."}),"\n",(0,i.jsx)(n.h3,{id:"removing-components",children:"Removing Components"}),"\n",(0,i.jsxs)(n.p,{children:["Your GLB might include lights or other components you don't want. You can remove them easily by selecting the nodes and using the ",(0,i.jsx)(n.code,{children:"remove"})," prop."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { Gltf, Modify } from '@playcanvas/react';\n\n<Gltf asset={asset} key={asset.id}>\n  <Modify.Node path=\"**[light]\">\n    <Modify.Light remove />\n  </Modify.Node>\n</Gltf>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:'path="**[light]"'})," pattern finds all nodes with a light component anywhere in the hierarchy. The ",(0,i.jsx)(n.code,{children:"remove"})," prop removes the component from those nodes."]}),"\n",(0,i.jsx)(a.G,{label:"Removing all lights from a GLB",code:y,showDemo:!0,children:(0,i.jsx)(d.l,{children:(0,i.jsx)(a.C,{useLight:!0,useShadow:!0,useGrid:!0,camera:[2,1,2],useControls:!0,exposure:3,children:(0,i.jsx)(r.w,{name:"model",scale:[.1,.1,.1],position:[0,-.5,0],children:(0,i.jsx)(m,{})})})})}),"\n",(0,i.jsx)(n.h3,{id:"changing-light-properties",children:"Changing Light Properties"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'<Gltf asset={asset} key={asset.id}>\n  <Modify.Node path="Headlight">\n    <Modify.Light color="red" intensity={2} />\n  </Modify.Node>\n</Gltf>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This finds the node named ",(0,i.jsx)(n.code,{children:'"Headlight"'})," and updates its light color and intensity, while keeping all other light properties unchanged."]}),"\n",(0,i.jsx)(n.h3,{id:"updating-render-properties",children:"Updating Render Properties"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'<Gltf asset={asset} key={asset.id}>\n  <Modify.Node path="Body[render]">\n    <Modify.Render castShadows receiveShadows />\n  </Modify.Node>\n</Gltf>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"[render]"})," filter selects nodes that have a render component. This enables shadow casting and receiving for the body mesh."]}),"\n",(0,i.jsx)(n.h3,{id:"functional-updates",children:"Functional Updates"}),"\n",(0,i.jsx)(n.p,{children:"You can also use functions to update properties based on their current values:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'<Gltf asset={asset} key={asset.id}>\n  <Modify.Node path="**[light]">\n    <Modify.Light intensity={(val) => (val || 1) * 2} />\n  </Modify.Node>\n</Gltf>\n'})}),"\n",(0,i.jsx)(n.p,{children:"This doubles the intensity of all lights in the GLB, regardless of their current values."}),"\n",(0,i.jsx)(n.h2,{id:"finding-entities-with-useentity",children:"Finding Entities with useEntity"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes you need to find entities within the GLB hierarchy to work with them programmatically. The ",(0,i.jsx)(n.code,{children:"useEntity"})," hook lets you search for entities relative to the current parent context. This is especially useful when you're adding components as children of ",(0,i.jsx)(n.code,{children:"<Modify.Node>"})," and need to find other entities in the same subtree."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { Gltf, Modify, useEntity } from '@playcanvas/react';\nimport { Entity, Light } from '@playcanvas/react/components';\n\nfunction HandGlow() {\n  // Find the 'Hand' entity relative to the current parent\n  const handEntity = useEntity('Hand');\n  \n  if (!handEntity) return null;\n  \n  // Add a glow effect to the hand\n  return (\n    <Entity name=\"HandGlow\" position={[0, 0.1, 0]}>\n      <Light type=\"omni\" color=\"cyan\" intensity={2} />\n    </Entity>\n  );\n}\n\n<Gltf asset={asset} key={asset.id}>\n  <Modify.Node path=\"Arm\">\n    <HandGlow />\n  </Modify.Node>\n</Gltf>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, ",(0,i.jsx)(n.code,{children:"useEntity('Hand')"})," searches for a child named ",(0,i.jsx)(n.code,{children:'"Hand"'})," relative to the ",(0,i.jsx)(n.code,{children:'"Arm"'})," node. The hook returns the entity if found, or ",(0,i.jsx)(n.code,{children:"null"})," if not found."]}),"\n",(0,i.jsx)(n.h3,{id:"using-path-patterns",children:"Using Path Patterns"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"useEntity"})," supports the same path patterns as ",(0,i.jsx)(n.code,{children:"<Modify.Node>"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"function FindMultipleLights() {\n  // Find all direct children with lights\n  const lights = useEntity('*[light]');\n  \n  if (!lights || !Array.isArray(lights)) return null;\n  \n  return (\n    <>\n      {lights.map((light, index) => (\n        <Entity key={index} name={`LightMarker_${index}`}>\n          {/* Add markers to each light */}\n        </Entity>\n      ))}\n    </>\n  );\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When using wildcards, ",(0,i.jsx)(n.code,{children:"useEntity"})," returns an array of matching entities. When using an exact path, it returns a single entity."]}),"\n",(0,i.jsx)(n.h3,{id:"using-predicate-functions",children:"Using Predicate Functions"}),"\n",(0,i.jsx)(n.p,{children:"You can also use a function to find entities based on custom logic:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'function FindWeapons() {\n  // Find all entities whose name includes "Weapon"\n  const weapons = useEntity((entity, metadata) => \n    entity.name.includes(\'Weapon\')\n  );\n  \n  if (!weapons) return null;\n  \n  const weaponArray = Array.isArray(weapons) ? weapons : [weapons];\n  \n  return (\n    <>\n      {weaponArray.map((weapon, index) => (\n        <Entity key={index} name={`WeaponEffect_${index}`}>\n          <Light type="omni" color="red" intensity={1} />\n        </Entity>\n      ))}\n    </>\n  );\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The predicate function receives the entity and its metadata, allowing you to match based on any criteria - component presence, name patterns, or custom properties."}),"\n",(0,i.jsxs)(n.p,{children:["Note: ",(0,i.jsx)(n.code,{children:"useEntity"})," only works inside components that are children of ",(0,i.jsx)(n.code,{children:"<Gltf>"})," or ",(0,i.jsx)(n.code,{children:"<Modify.Node>"}),". It searches relative to the current parent context, making it perfect for finding entities within the subtree you're modifying."]}),"\n",(0,i.jsx)(n.h2,{id:"multiple-modifications",children:"Multiple Modifications"}),"\n",(0,i.jsxs)(n.p,{children:["You can apply multiple modifications to the same GLB. Each ",(0,i.jsx)(n.code,{children:"<Modify.Node>"})," rule is independent and will be applied to matching nodes:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'<Gltf asset={asset} key={asset.id}>\n  {/* Remove all original lights */}\n  <Modify.Node path="**[light]">\n    <Modify.Light remove />\n  </Modify.Node>\n\n  {/* Add shadow casting to all meshes */}\n  <Modify.Node path="**[render]">\n    <Modify.Render castShadows receiveShadows />\n  </Modify.Node>\n\n  {/* Add a new light to the head */}\n  <Modify.Node path="Head">\n    <Entity name="HeadLight">\n      <Light type="omni" color="cyan" intensity={2} />\n    </Entity>\n  </Modify.Node>\n</Gltf>\n'})}),"\n",(0,i.jsx)(n.p,{children:"If multiple rules try to modify the same component on the same node, the most specific path wins. This lets you set general rules and override them with specific ones."}),"\n",(0,i.jsx)(n.h2,{id:"related",children:"Related"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../loading-assets/",children:"Loading Assets"})," - Learn how to load GLB assets"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../../api/anim",children:"Anim Component"})," - Animation component reference"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../../api/collision",children:"Collision Component"})," - Physics collision reference"]}),"\n"]})]})}function w(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(v,{...e})}):v(e)}},49801:(e,n,t)=>{t.d(n,{A:()=>d});var s=t(18676),i=t(83395),o=t(78692),a=t(74848);const d=({...e})=>(0,a.jsx)(s.w,{scale:[1e3,1,1e3],children:(0,a.jsx)(i.e,{script:o.x,...e})})},53558:(e,n,t)=>{t.d(n,{A:()=>x});var s=t(96540),i=t(55937),o=t(8939),a=t(78692),d=t(54256),r=t(25303),l=t(34363),c=t(53512),h=t(49801),p=t(24421),u=t(85593),m=t(83395),y=t(83171),g=t(74848);const f=e=>(0,g.jsx)(m.e,{script:y.d,...e}),x={React:s,...s,...d,...r,...l,...c,Grid:h.A,ShadowCatcher:p.A,GridScript:a.x,ShadowCatcherScript:o.X,StaticPostEffects:u.A,AutoRotate:f,CameraControls:i.a}},85593:(e,n,t)=>{t.d(n,{A:()=>a});var s=t(83395),i=t(15817),o=t(74848);const a=e=>{const n={lighting:{exposure:1.21,skyBoxIntensity:1.02},rendering:{renderFormat:18,renderTargetScale:1,sharpness:0,samples:4,toneMapping:4,fog:"none",fogColor:{r:0,g:0,b:0,a:1},fogRange:[0,100],fogDensity:.01,renderFormatFallback0:12,renderFormatFallback1:14,sceneColorMap:!1,sceneDepthMap:!1,fogStart:0,fogEnd:100},bloom:{enabled:!0,intensity:.1,lastMipLevel:1},grading:{enabled:!0,brightness:.83,contrast:1.1,saturation:1.2,tint:{r:1,g:.9333333333333333,b:.8666666666666667,a:1}},vignette:{enabled:!0,intensity:1,inner:.25,outer:1.52,curvature:.78},fringing:{enabled:!0,intensity:10},...e};return(0,o.jsx)(s.e,{script:i.P,...n})}}}]);