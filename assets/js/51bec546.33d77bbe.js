"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[32804],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var a=t(96540);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}},98261:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"user-manual/graphics/advanced-rendering/hardware-instancing","title":"Hardware Instancing","description":"Hardware instancing is a rendering technique which allows the GPU to render multiple identical meshes in a small number of draw calls. Each instance of the mesh can have a different limited amount of state (for example, position, rotation, scale, or color). It\'s a technique suitable for drawing objects such as trees, bullets, particles, or any repeated geometry.","source":"@site/docs/user-manual/graphics/advanced-rendering/hardware-instancing.md","sourceDirName":"user-manual/graphics/advanced-rendering","slug":"/user-manual/graphics/advanced-rendering/hardware-instancing","permalink":"/user-manual/graphics/advanced-rendering/hardware-instancing","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/graphics/advanced-rendering/hardware-instancing.md","tags":[],"version":"current","frontMatter":{"title":"Hardware Instancing"},"sidebar":"userManualSidebar","previous":{"title":"Batching","permalink":"/user-manual/graphics/advanced-rendering/batching"},"next":{"title":"Multiple Render Targets","permalink":"/user-manual/graphics/advanced-rendering/multiple-render-targets"}}');var i=t(74848),s=t(28453);const r={title:"Hardware Instancing"},c=void 0,l={},o=[{value:"Live Examples",id:"live-examples",level:2},{value:"Basic Instancing with Default Format",id:"basic-instancing-with-default-format",level:2},{value:"Step 1: Prepare Instance Matrices",id:"step-1-prepare-instance-matrices",level:3},{value:"Step 2: Create Vertex Buffer and Enable Instancing",id:"step-2-create-vertex-buffer-and-enable-instancing",level:3},{value:"Dynamic Updates",id:"dynamic-updates",level:3},{value:"Custom Vertex Format",id:"custom-vertex-format",level:2},{value:"Example: Position and Scale Format",id:"example-position-and-scale-format",level:3},{value:"StandardMaterial Shader Chunks",id:"standardmaterial-shader-chunks",level:2},{value:"Step 1: Set Up Material Attributes",id:"step-1-set-up-material-attributes",level:3},{value:"Step 2: Override the Instancing Shader Chunk",id:"step-2-override-the-instancing-shader-chunk",level:3},{value:"Custom Shader with Instancing",id:"custom-shader-with-instancing",level:2},{value:"GLSL Example",id:"glsl-example",level:3},{value:"WGSL Example",id:"wgsl-example",level:3},{value:"Using Default Mat4 Format in Custom Shaders",id:"using-default-mat4-format-in-custom-shaders",level:3},{value:"GLB Instancing",id:"glb-instancing",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Hardware instancing is a rendering technique which allows the GPU to render multiple identical meshes in a small number of draw calls. Each instance of the mesh can have a different limited amount of state (for example, position, rotation, scale, or color). It's a technique suitable for drawing objects such as trees, bullets, particles, or any repeated geometry."}),"\n",(0,i.jsx)(n.p,{children:"Instancing is supported on all devices since PlayCanvas requires WebGL2 minimum, where instancing is a core feature."}),"\n",(0,i.jsx)(n.p,{children:"Note that all instances are submitted for rendering by the GPU with no camera frustum culling taking place."}),"\n",(0,i.jsx)(n.h2,{id:"live-examples",children:"Live Examples"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://playcanvas.vercel.app/#/graphics/instancing-basic",children:"Basic Instancing"})," - Demonstrates default Mat4 instancing format with StandardMaterial"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://playcanvas.vercel.app/#/graphics/instancing-custom",children:"Custom Instancing"})," - Shows custom vertex format with shader chunks override"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://playcanvas.vercel.app/#/graphics/instancing-glb",children:"GLB Instancing"})," - Uses EXT_mesh_gpu_instancing extension in GLB files"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://playcanvas.vercel.app/#/graphics/instancing-gooch",children:"Gooch Instancing"})," - Full custom ShaderMaterial with instancing support"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"basic-instancing-with-default-format",children:"Basic Instancing with Default Format"}),"\n",(0,i.jsx)(n.p,{children:"The simplest way to use instancing is with the default instancing format, which stores a Mat4 world matrix per instance."}),"\n",(0,i.jsx)(n.h3,{id:"step-1-prepare-instance-matrices",children:"Step 1: Prepare Instance Matrices"}),"\n",(0,i.jsx)(n.p,{children:"Store matrices for individual instances into a Float32Array:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// store matrices for individual instances into array\nconst instanceCount = 1000;\nconst matrices = new Float32Array(instanceCount * 16);\nconst matrix = new pc.Mat4();\nconst pos = new pc.Vec3();\nconst rot = new pc.Quat();\nconst scl = new pc.Vec3();\n\nfor (let i = 0; i < instanceCount; i++) {\n    // set up position, rotation, scale for each instance\n    pos.set(Math.random() * 10, Math.random() * 10, Math.random() * 10);\n    rot.setFromEulerAngles(i * 30, i * 50, i * 70);\n    scl.set(0.1, 0.1, 0.1);\n    matrix.setTRS(pos, rot, scl);\n\n    // copy matrix elements into array of floats\n    for (let m = 0; m < 16; m++) {\n        matrices[i * 16 + m] = matrix.data[m];\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-2-create-vertex-buffer-and-enable-instancing",children:"Step 2: Create Vertex Buffer and Enable Instancing"}),"\n",(0,i.jsxs)(n.p,{children:["Create a VertexBuffer using ",(0,i.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/VertexFormat.html#getdefaultinstancingformat",children:(0,i.jsx)(n.code,{children:"pc.VertexFormat.getDefaultInstancingFormat"})})," and enable instancing on a MeshInstance:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const vbFormat = pc.VertexFormat.getDefaultInstancingFormat(app.graphicsDevice);\nconst vertexBuffer = new pc.VertexBuffer(app.graphicsDevice, vbFormat, instanceCount, {\n    data: matrices\n});\n\n// enable instancing on the mesh instance\nconst meshInst = entity.render.meshInstances[0];\nmeshInst.setInstancing(vertexBuffer);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"dynamic-updates",children:"Dynamic Updates"}),"\n",(0,i.jsx)(n.p,{children:"For dynamic instancing where positions change each frame, create a dynamic vertex buffer and update it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// create dynamic vertex buffer (no initial data)\nconst vertexBuffer = new pc.VertexBuffer(app.graphicsDevice, vbFormat, instanceCount, {\n    usage: pc.BUFFER_DYNAMIC\n});\n\n// update per frame\nvertexBuffer.setData(matrices);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"custom-vertex-format",children:"Custom Vertex Format"}),"\n",(0,i.jsx)(n.p,{children:"For more efficient instancing or custom per-instance data, you can define a custom vertex format instead of using the default Mat4 format."}),"\n",(0,i.jsx)(n.h3,{id:"example-position-and-scale-format",children:"Example: Position and Scale Format"}),"\n",(0,i.jsx)(n.p,{children:"This format stores only position (3 floats) and uniform scale (1 float) per instance, reducing memory from 64 bytes to 16 bytes per instance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const vbFormat = new pc.VertexFormat(app.graphicsDevice, [\n    { semantic: pc.SEMANTIC_ATTR12, components: 3, type: pc.TYPE_FLOAT32 }, // position\n    { semantic: pc.SEMANTIC_ATTR13, components: 1, type: pc.TYPE_FLOAT32 }  // scale\n]);\n\n// store data for individual instances, 4 floats each\nconst instanceCount = 3000;\nconst data = new Float32Array(instanceCount * 4);\n\nfor (let i = 0; i < instanceCount; i++) {\n    const offset = i * 4;\n    data[offset + 0] = Math.random() * 10 - 5; // x\n    data[offset + 1] = Math.random() * 10 - 5; // y\n    data[offset + 2] = Math.random() * 10 - 5; // z\n    data[offset + 3] = 0.1 + Math.random() * 0.1; // scale\n}\n\nconst vertexBuffer = new pc.VertexBuffer(app.graphicsDevice, vbFormat, instanceCount, {\n    data: data\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"When using a custom format, you must also provide a custom shader or shader chunk to interpret the data (see sections below)."}),"\n",(0,i.jsx)(n.h2,{id:"standardmaterial-shader-chunks",children:"StandardMaterial Shader Chunks"}),"\n",(0,i.jsx)(n.p,{children:"When using StandardMaterial with a custom instancing format, you can override the instancing shader chunk to define how the model matrix is computed from your custom attributes."}),"\n",(0,i.jsx)(n.h3,{id:"step-1-set-up-material-attributes",children:"Step 1: Set Up Material Attributes"}),"\n",(0,i.jsx)(n.p,{children:"Tell the material which semantics map to which attribute names:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const material = new pc.StandardMaterial();\nmaterial.setAttribute('aInstPosition', pc.SEMANTIC_ATTR12);\nmaterial.setAttribute('aInstScale', pc.SEMANTIC_ATTR13);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-2-override-the-instancing-shader-chunk",children:"Step 2: Override the Instancing Shader Chunk"}),"\n",(0,i.jsx)(n.p,{children:"Provide custom shader code for both GLSL (WebGL) and WGSL (WebGPU):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"material.getShaderChunks(pc.SHADERLANGUAGE_GLSL).set('transformInstancingVS', `\n    attribute vec3 aInstPosition;\n    attribute float aInstScale;\n\n    mat4 getModelMatrix() {\n        return mat4(\n            vec4(aInstScale, 0.0, 0.0, 0.0),\n            vec4(0.0, aInstScale, 0.0, 0.0),\n            vec4(0.0, 0.0, aInstScale, 0.0),\n            vec4(aInstPosition, 1.0)\n        );\n    }\n`);\n\nmaterial.getShaderChunks(pc.SHADERLANGUAGE_WGSL).set('transformInstancingVS', `\n    attribute aInstPosition: vec3f;\n    attribute aInstScale: f32;\n\n    fn getModelMatrix() -> mat4x4f {\n        return mat4x4f(\n            vec4f(aInstScale, 0.0, 0.0, 0.0),\n            vec4f(0.0, aInstScale, 0.0, 0.0),\n            vec4f(0.0, 0.0, aInstScale, 0.0),\n            vec4f(aInstPosition, 1.0)\n        );\n    }\n`);\n\nmaterial.update();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The instancing chunk must implement the ",(0,i.jsx)(n.code,{children:"getModelMatrix()"})," function, which returns the world matrix for each instance."]}),"\n",(0,i.jsx)(n.h2,{id:"custom-shader-with-instancing",children:"Custom Shader with Instancing"}),"\n",(0,i.jsxs)(n.p,{children:["When writing a fully custom shader (using ShaderMaterial) that supports instancing, use the ",(0,i.jsx)(n.code,{children:"INSTANCING"})," preprocessor define to conditionally include instancing code:"]}),"\n",(0,i.jsx)(n.h3,{id:"glsl-example",children:"GLSL Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:'#include "transformCoreVS"\n\n#if INSTANCING\n    attribute vec3 aInstPosition;\n    attribute float aInstScale;\n\n    mat4 getModelMatrix() {\n        return mat4(\n            vec4(aInstScale, 0.0, 0.0, 0.0),\n            vec4(0.0, aInstScale, 0.0, 0.0),\n            vec4(0.0, 0.0, aInstScale, 0.0),\n            vec4(aInstPosition, 1.0)\n        );\n    }\n#endif\n\nvoid main(void) {\n    mat4 modelMatrix = getModelMatrix();\n    vec3 localPos = getLocalPosition(vertex_position.xyz);\n    vec4 worldPos = modelMatrix * vec4(localPos, 1.0);\n    gl_Position = matrix_viewProjection * worldPos;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"wgsl-example",children:"WGSL Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-wgsl",children:'#include "transformCoreVS"\n\n#if INSTANCING\n    attribute aInstPosition: vec3f;\n    attribute aInstScale: f32;\n\n    fn getModelMatrix() -> mat4x4f {\n        return mat4x4f(\n            vec4f(aInstScale, 0.0, 0.0, 0.0),\n            vec4f(0.0, aInstScale, 0.0, 0.0),\n            vec4f(0.0, 0.0, aInstScale, 0.0),\n            vec4f(aInstPosition, 1.0)\n        );\n    }\n#endif\n\n@vertex\nfn vertexMain(input: VertexInput) -> VertexOutput {\n    var output: VertexOutput;\n    let modelMatrix: mat4x4f = getModelMatrix();\n    let localPos: vec3f = getLocalPosition(input.vertex_position.xyz);\n    let worldPos: vec4f = modelMatrix * vec4f(localPos, 1.0);\n    output.position = uniform.matrix_viewProjection * worldPos;\n    return output;\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"#if INSTANCING"})," guard allows the same shader to work for both instanced and non-instanced rendering. When instancing is not enabled, the engine provides a default ",(0,i.jsx)(n.code,{children:"getModelMatrix()"})," implementation."]}),"\n",(0,i.jsx)(n.h3,{id:"using-default-mat4-format-in-custom-shaders",children:"Using Default Mat4 Format in Custom Shaders"}),"\n",(0,i.jsxs)(n.p,{children:["If using the default instancing format (Mat4 per instance), read the matrix from the four ",(0,i.jsx)(n.code,{children:"instance_line"})," attributes:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"attribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n\nmat4 getModelMatrix() {\n    return mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"glb-instancing",children:"GLB Instancing"}),"\n",(0,i.jsxs)(n.p,{children:["GLB/glTF files can include instancing data via the ",(0,i.jsx)(n.a,{href:"https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md",children:(0,i.jsx)(n.code,{children:"EXT_mesh_gpu_instancing"})})," extension. When loading such files, PlayCanvas automatically sets up the instancing:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const entity = assets.glb.resource.instantiateRenderEntity({\n    castShadows: true\n});\napp.root.addChild(entity);\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is useful for scenes authored in tools like Blender that support exporting instanced geometry."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);