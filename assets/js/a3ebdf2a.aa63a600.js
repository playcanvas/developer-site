"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[62135],{28453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>t});var i=s(96540);const a={},r=i.createContext(a);function c(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),i.createElement(r.Provider,{value:n},e.children)}},41379:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"user-manual/graphics/cameras/scene-picker","title":"Scene Picker","description":"The Picker class provides a way to select mesh instances from screen coordinates by clicking or touching the screen. It works by rendering the scene from a camera\'s viewpoint to an offscreen buffer with unique ID colors, allowing efficient identification of clicked objects. The picker supports both regular meshes and Gaussian Splats, and works across WebGL2 and WebGPU backends.","source":"@site/docs/user-manual/graphics/cameras/scene-picker.md","sourceDirName":"user-manual/graphics/cameras","slug":"/user-manual/graphics/cameras/scene-picker","permalink":"/user-manual/graphics/cameras/scene-picker","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/graphics/cameras/scene-picker.md","tags":[],"version":"current","frontMatter":{"title":"Scene Picker"},"sidebar":"userManualSidebar","previous":{"title":"Depth Layer","permalink":"/user-manual/graphics/cameras/depth-layer"},"next":{"title":"Lighting","permalink":"/user-manual/graphics/lighting/"}}');var a=s(74848),r=s(28453);const c={title:"Scene Picker"},t=void 0,o={},l=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"Depth Support",id:"depth-support",level:2},{value:"World Position Picking",id:"world-position-picking",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Gaussian Splatting Support",id:"gaussian-splatting-support",level:2},{value:"Examples",id:"examples",level:2}];function p(e){const n={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"The Picker class provides a way to select mesh instances from screen coordinates by clicking or touching the screen. It works by rendering the scene from a camera's viewpoint to an offscreen buffer with unique ID colors, allowing efficient identification of clicked objects. The picker supports both regular meshes and Gaussian Splats, and works across WebGL2 and WebGPU backends."}),"\n",(0,a.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(n.p,{children:"To create a picker, instantiate it with your application, desired resolution, and optionally enable depth picking:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const picker = new pc.Picker(app, width, height, depth);\n"})}),"\n",(0,a.jsx)(n.p,{children:"The basic workflow involves three steps:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Prepare"})," - Render the pick buffer by calling ",(0,a.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/Picker.html#prepare",children:(0,a.jsx)(n.code,{children:"prepare(camera, scene, layers)"})})," once per frame (or only when the camera or scene changes)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Resize"})," - Adjust picker resolution if needed using ",(0,a.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/Picker.html#resize",children:(0,a.jsx)(n.code,{children:"resize(width, height)"})})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Query"})," - Get picked mesh instances asynchronously using ",(0,a.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/Picker.html#getSelectionAsync",children:(0,a.jsx)(n.code,{children:"getSelectionAsync(x, y, width, height)"})})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The picker uses an asynchronous API to read pixel data without blocking the rendering thread, ensuring smooth frame rates even when picking. When you're done with the picker, call ",(0,a.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/Picker.html#destroy",children:(0,a.jsx)(n.code,{children:"destroy()"})})," to clean up GPU resources."]}),"\n",(0,a.jsxs)(n.p,{children:["For complete API documentation, see the ",(0,a.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/Picker.html",children:"Picker API reference"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"depth-support",children:"Depth Support"}),"\n",(0,a.jsxs)(n.p,{children:["By default, the picker only captures mesh instance IDs. However, you can enable depth picking by passing ",(0,a.jsx)(n.code,{children:"true"})," as the fourth constructor parameter:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const picker = new pc.Picker(app, width, height, true);\n"})}),"\n",(0,a.jsx)(n.p,{children:"When depth picking is enabled, the picker captures depth values along with mesh IDs. This additional information enables calculating the exact 3D world position of clicked points on object surfaces, which is useful for placing objects, measuring distances, or creating editor tools."}),"\n",(0,a.jsx)(n.h2,{id:"world-position-picking",children:"World Position Picking"}),"\n",(0,a.jsxs)(n.p,{children:["When depth picking is enabled, you can use ",(0,a.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/Picker.html#getWorldPointAsync",children:(0,a.jsx)(n.code,{children:"getWorldPointAsync(x, y)"})})," to get the 3D world position at screen coordinates:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"picker.getWorldPointAsync(x, y).then((worldPoint) => {\n    if (worldPoint) {\n        // worldPoint is a Vec3 in world space\n        console.log('Clicked at:', worldPoint);\n    } else {\n        // No object was clicked (background)\n        console.log('Clicked on empty space');\n    }\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The method returns a promise that resolves to a ",(0,a.jsx)(n.code,{children:"Vec3"})," containing the world position, or ",(0,a.jsx)(n.code,{children:"null"})," if no object was clicked. This works correctly with both perspective and orthographic cameras."]}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.p,{children:"The picker's performance can be optimized in several ways:"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Lower Resolution"}),": Rendering the pick buffer at a fraction of the screen resolution significantly improves performance. For example, using 0.25x screen resolution:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const pickerScale = 0.25;\nconst picker = new pc.Picker(\n    app,\n    canvas.width * pickerScale,\n    canvas.height * pickerScale,\n    true\n);\n"})}),"\n",(0,a.jsx)(n.p,{children:"The trade-off is reduced precision - very small objects may be missed at lower resolutions."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Asynchronous Reads"}),": The picker's async API prevents blocking the main thread while reading pixel data from the GPU, maintaining smooth frame rates."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Selective Updates"}),": Call ",(0,a.jsx)(n.code,{children:"prepare()"})," only when needed. If your camera and objects are static, you can reuse the previously rendered pick buffer without calling ",(0,a.jsx)(n.code,{children:"prepare()"})," again."]}),"\n",(0,a.jsx)(n.h2,{id:"gaussian-splatting-support",children:"Gaussian Splatting Support"}),"\n",(0,a.jsx)(n.p,{children:"The picker fully supports Gaussian Splat instances with the same API as regular meshes. You can pick splat instances by their mesh instance ID and, with depth enabled, determine exact 3D positions on splat surfaces."}),"\n",(0,a.jsxs)(n.p,{children:["This enables interactive applications like placing markers on splats, measuring distances, or selecting individual splat entities in complex scenes. See the ",(0,a.jsx)(n.a,{href:"https://playcanvas.github.io/#gaussian-splatting/picking",children:"Gaussian Splatting Picking example"})," for a complete demonstration."]}),"\n",(0,a.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(n.p,{children:"These engine examples demonstrate the picker in action:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://playcanvas.github.io/#/graphics/area-picker",children:(0,a.jsx)(n.strong,{children:"Area Picker"})})," - Shows how to pick mesh instances in rectangular screen regions with visual feedback"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://playcanvas.github.io/#gaussian-splatting/picking",children:(0,a.jsx)(n.strong,{children:"Gaussian Splatting Picking"})})," - Demonstrates picking splat instances and using world position picking to place markers on splat surfaces"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}}}]);