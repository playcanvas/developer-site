"use strict";(self.webpackChunkdeveloper_playcanvas_com=self.webpackChunkdeveloper_playcanvas_com||[]).push([[66050],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var a=t(96540);const r={},s=a.createContext(r);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:n},e.children)}},38619:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"user-manual/gaussian-splatting/rendering/draw-order","title":"Draw Order and Sorting","description":"How Gaussians Are Sorted","source":"@site/docs/user-manual/gaussian-splatting/rendering/draw-order.md","sourceDirName":"user-manual/gaussian-splatting/rendering","slug":"/user-manual/gaussian-splatting/rendering/draw-order","permalink":"/user-manual/gaussian-splatting/rendering/draw-order","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/gaussian-splatting/rendering/draw-order.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Draw Order and Sorting","sidebar_position":1},"sidebar":"userManualSidebar","previous":{"title":"Rendering Splats","permalink":"/user-manual/gaussian-splatting/rendering/"},"next":{"title":"Picking","permalink":"/user-manual/gaussian-splatting/rendering/picking"}}');var r=t(74848),s=t(28453);const o={title:"Draw Order and Sorting",sidebar_position:1},i=void 0,l={},d=[{value:"How Gaussians Are Sorted",id:"how-gaussians-are-sorted",level:2},{value:"Multiple GSplatComponents",id:"multiple-gsplatcomponents",level:2},{value:"Depth Buffer Considerations",id:"depth-buffer-considerations",level:2}];function p(e){const n={admonition:"admonition",h2:"h2",p:"p",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"how-gaussians-are-sorted",children:"How Gaussians Are Sorted"}),"\n",(0,r.jsx)(n.p,{children:"Individual Gaussians within a GSplatComponent are sorted back to front based on camera depth. This sorting happens asynchronously in a Web Worker to avoid blocking the main thread. The calculated sort order is then passed back to the main thread and uploaded to the GPU for rendering."}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"Because the sorting occurs asynchronously, you may notice some visual lag if the camera transform changes significantly over a very short time period, as the Web Worker needs time to recalculate the new sort order."})}),"\n",(0,r.jsx)(n.h2,{id:"multiple-gsplatcomponents",children:"Multiple GSplatComponents"}),"\n",(0,r.jsx)(n.p,{children:"The PlayCanvas Engine does not currently support global sorting across multiple GSplatComponents (where all Gaussians from all components would be sorted together). Instead, GSplatComponents are rendered back to front based on their bounding boxes, and each component's Gaussians are sorted independently within that component."}),"\n",(0,r.jsx)(n.p,{children:"Support for global sorting across all GSplatComponents is currently in development."}),"\n",(0,r.jsx)(n.h2,{id:"depth-buffer-considerations",children:"Depth Buffer Considerations"}),"\n",(0,r.jsx)(n.p,{children:"GSplatComponents do not write to the depth buffer during rendering. This limitation means you cannot use functionality that relies on reading back or leveraging depth buffer data in your application. For example, a Depth of Field post effect, which typically required the depth buffer, would not generally be compatible with splat rendering."}),"\n",(0,r.jsx)(n.p,{children:"As a workaround, you can generate a mesh-based approximation of your splat and render it to the depth buffer in a separate layer (without writing to the framebuffer). This technique allows depth-dependent effects while maintaining the visual quality of the Gaussian splat rendering."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);