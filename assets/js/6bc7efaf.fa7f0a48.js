"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[90185],{28453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>r});var a=s(96540);const t={},i=a.createContext(t);function c(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),a.createElement(i.Provider,{value:n},e.children)}},96679:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>c,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"user-manual/editor/scenes/loading-scenes","title":"Loading Scenes","description":"This page covers how to load scenes programmatically and different approaches for using scenes in your projects.","source":"@site/docs/user-manual/editor/scenes/loading-scenes.md","sourceDirName":"user-manual/editor/scenes","slug":"/user-manual/editor/scenes/loading-scenes","permalink":"/user-manual/editor/scenes/loading-scenes","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/editor/scenes/loading-scenes.md","tags":[],"version":"current","frontMatter":{"title":"Loading Scenes"},"sidebar":"userManualSidebar","previous":{"title":"Sprite","permalink":"/user-manual/editor/scenes/components/sprite"},"next":{"title":"Scripting","permalink":"/user-manual/editor/scripting/"}}');var t=s(74848),i=s(28453);const c={title:"Loading Scenes"},r=void 0,o={},l=[{value:"Changing Scenes Completely",id:"changing-scenes-completely",level:2},{value:"Loading Scenes Additively",id:"loading-scenes-additively",level:2},{value:"Understanding How Scenes Work",id:"understanding-how-scenes-work",level:2},{value:"Destroying all children under application root node first",id:"destroying-all-children-under-application-root-node-first",level:3},{value:"Destroying the old scene root entity after the new scene is loaded",id:"destroying-the-old-scene-root-entity-after-the-new-scene-is-loaded",level:3},{value:"Managing Assets in Scenes",id:"managing-assets-in-scenes",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"This page covers how to load scenes programmatically and different approaches for using scenes in your projects."}),"\n",(0,t.jsx)(n.p,{children:"There are two main approaches: changing scenes completely and loading scenes additively."}),"\n",(0,t.jsx)(n.h2,{id:"changing-scenes-completely",children:"Changing Scenes Completely"}),"\n",(0,t.jsx)(n.p,{children:"This is the most common approach that developers take where each scene is a self-contained part of the game. For example, one scene would be the title screen and then one scene per level."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://playcanvas.com/project/924351/",children:"Here is an example"})," where the user can move to and from the title screen to other levels."]}),"\n",(0,t.jsx)("div",{className:"iframe-container",children:(0,t.jsx)("iframe",{src:"https://playcanv.as/e/p/Q1gKd1ek/",title:"Switching Scenes Completely",allow:"camera; microphone; xr-spatial-tracking; fullscreen",allowfullscreen:!0})}),"\n",(0,t.jsxs)(n.p,{children:["This is done by simply calling ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/SceneRegistry.html#changescene",children:(0,t.jsx)(n.code,{children:"SceneRegistry.changeScene"})})," with the name of the scene."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"this.app.scenes.changeScene('Some Scene Name');\n"})}),"\n",(0,t.jsx)(n.p,{children:"If the scene data is not already loaded, this function will:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Make the asynchronous network request for the new scene data."}),"\n",(0,t.jsx)(n.li,{children:"When the scene data is loaded, it will delete all child entities from the application root node (destroying the existing scene hierarchy)."}),"\n",(0,t.jsxs)(n.li,{children:["Call ",(0,t.jsx)(n.code,{children:"loadSceneSettings"})," which is now synchronous as the scene data is loaded."]}),"\n",(0,t.jsxs)(n.li,{children:["Call ",(0,t.jsx)(n.code,{children:"loadSceneHierarchy"})," which is now synchronous as the scene data is loaded."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If you want to know when the scene is loaded or if there are errors, you will need to provide a callback:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"this.app.scenes.changeScene('Some Scene Name', (err, loadedSceneRootEntity) => {\n    if (err) {\n        console.error(err);\n    } else {\n        // Scene hierarchy has successfully been loaded\n    }\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To avoid the asynchronous network request when calling ",(0,t.jsx)(n.code,{children:"changeScene"}),", you can call ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/SceneRegistry.html#loadscenedata",children:(0,t.jsx)(n.code,{children:"SceneRegistry.loadSceneData"})})," ahead of time. This makes ",(0,t.jsx)(n.code,{children:"changeScene"})," synchronous, immediately calling ",(0,t.jsx)(n.code,{children:"loadSceneSettings"})," and ",(0,t.jsx)(n.code,{children:"loadSceneHierarchy"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Common use cases would include knowing that the user would load level 2 when level 1 is completed. In this case, you can load the scene data for level 2 when the user is in level 1. When they complete level 1, they won't have to wait for data to be loaded and immediately enter level 2."}),"\n",(0,t.jsx)(n.h2,{id:"loading-scenes-additively",children:"Loading Scenes Additively"}),"\n",(0,t.jsx)(n.p,{children:"It is possible to load multiple scene hierarchies in an additive manner rather than completely switching scenes. The common use cases for this are to split up a large world so that it can be loaded over time rather than loading it all at once at the start."}),"\n",(0,t.jsx)(n.p,{children:"A variant of the above would be for each scene to represent a section of the world that is loaded and destroyed as the player moves around. The system would only load the nearest connected sections of the world and related assets while destroying and unloading assets for any section that is not needed. This would help with managing resources such as memory and VRAM."}),"\n",(0,t.jsx)(n.p,{children:"Sometimes developers use this approach to ensure that certain code and entities are created before the actual game loads and have them globally accessible throughout the game session."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://playcanvas.com/project/685077/",children:"Below is a simplified example"})," of additively loading scenes where the UI in the top left is the 'main' scene and different scene hierarchies are loaded/destroyed."]}),"\n",(0,t.jsx)("div",{className:"iframe-container",children:(0,t.jsx)("iframe",{src:"https://playcanv.as/e/p/cjBInud1/",title:"Additively Loading Scenes",allow:"camera; microphone; xr-spatial-tracking; fullscreen",allowfullscreen:!0})}),"\n",(0,t.jsxs)(n.admonition,{type:"warning",children:[(0,t.jsx)(n.p,{children:"Multiple instances of the same scene hierarchy cannot be loaded at once. Entities have unique GUIDs assigned in the Editor, and loading multiple instances causes GUID conflicts."}),(0,t.jsxs)(n.p,{children:["If you need multiple instances of an entity hierarchy, use ",(0,t.jsx)(n.a,{href:"/user-manual/editor/templates/",children:"Templates"})," instead. Templates generate unique GUIDs on instantiation."]})]}),"\n",(0,t.jsx)(n.h2,{id:"understanding-how-scenes-work",children:"Understanding How Scenes Work"}),"\n",(0,t.jsx)(n.p,{children:"To use scenes effectively, it is important to understand how they are loaded when used in a project. This section goes into detail about how scenes are structured and loaded."}),"\n",(0,t.jsxs)(n.p,{children:["Scenes are separate from ",(0,t.jsx)(n.a,{href:"/user-manual/assets/",children:"assets"})," and have their own properties and APIs."]}),"\n",(0,t.jsxs)(n.p,{children:["Scenes are represented by ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/SceneRegistryItem.html",children:"Scene Registry Items"})," stored in the ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/SceneRegistry.html",children:"Scene Registry"}),", accessible via the ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/AppBase.html#scenes",children:"Application"})," object. You can find a Scene Registry Item by the scene's name and use it to load the hierarchy or settings."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/AppBase.html#root",children:"application root node"})," is not the scene hierarchy root entity that is named 'Root' by default that you see in the scene with the Editor. The scene hierarchy root entity will be a child of the application root node."]})}),"\n",(0,t.jsx)(n.p,{children:"There are two APIs to load the scene hierarchy and settings:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/SceneRegistry.html#loadscenehierarchy",children:(0,t.jsx)(n.code,{children:"SceneRegistry.loadSceneHierarchy"})})," - Loads a scene hierarchy"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/SceneRegistry.html#loadscenesettings",children:(0,t.jsx)(n.code,{children:"SceneRegistry.loadSceneSettings"})})," - Loads settings from a scene"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here is a code example to load the scene hierarchy or settings:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Find the Scene Registry Item by the name of the scene\nconst sceneItem = this.app.scenes.find('Some Scene Name');\n\n// Load the scene hierarchy with a callback when it has finished\nthis.app.scenes.loadSceneHierarchy(sceneItem, (err, loadedSceneRootEntity) => {\n    if (err) {\n        console.error(err);\n    } else {\n        // Scene hierarchy has successfully been loaded\n    }\n});\n\n// Load the scene settings with a callback when it has finished\nthis.app.scenes.loadSceneSettings(sceneItem, (err) => {\n    if (err) {\n        console.error(err);\n    } else {\n        // Scene settings have successfully been loaded\n    }\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Both ",(0,t.jsx)(n.code,{children:"loadSceneHierarchy"})," and ",(0,t.jsx)(n.code,{children:"loadSceneSettings"})," have similar behavior in how they get the data needed to load the hierarchy or settings."]}),"\n",(0,t.jsx)(n.p,{children:"When the function is called, it performs an asynchronous network request to the server for the scene data. This means that there will be a delay (depending on network speed, the network connection and size of the scene) between the request to load the scene and the browser completing the network request where the application is still updating."}),"\n",(0,t.jsx)(n.p,{children:"Once the network request has been completed, the engine will do the following:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"loadSceneHierarchy"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Creates the entities and components from the loaded scene and adds the hierarchy to the ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/AppBase.html#root",children:"application root node"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Calls ",(0,t.jsx)(n.code,{children:"initialize"})," and ",(0,t.jsx)(n.code,{children:"postInitialize"})," functions on the ScriptTypes in the loaded scene."]}),"\n",(0,t.jsxs)(n.li,{children:["Calls the callback that was passed into the ",(0,t.jsx)(n.code,{children:"loadSceneHierarchy"})," function."]}),"\n",(0,t.jsxs)(n.li,{children:["(Optional) The ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/engine/types/LoadHierarchyCallback.html",children:"callback"})," receives the loaded scene root entity as a parameter, which can be modified or reparented as needed."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"loadSceneSettings"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Applies the loaded scene settings to the application."}),"\n",(0,t.jsxs)(n.li,{children:["Calls the ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/engine/types/LoadSettingsCallback.html",children:"callback"})," that was passed into the ",(0,t.jsx)(n.code,{children:"loadSceneSettings"})," function."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["By default, ",(0,t.jsx)(n.code,{children:"loadSceneHierarchy"})," will always load additively and it's up to the developer to remove/destroy the existing loaded scene to change scenes completely."]}),"\n",(0,t.jsx)(n.p,{children:"There are several ways to approach this with pros and cons:"}),"\n",(0,t.jsx)(n.h3,{id:"destroying-all-children-under-application-root-node-first",children:"Destroying all children under application root node first"}),"\n",(0,t.jsx)(n.p,{children:"This approach has discrete steps that make it easier to manage where the currently loaded scene is destroyed before loading and creation of the new scene."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Find the Scene Registry Item by the name of the scene\nconst sceneItem = this.app.scenes.find('Some Scene Name');\n\n// Destroy all children under application root to remove the currently loaded scene hierarchy\nconst rootChildren = this.app.root.children;\nwhile(rootChildren.length > 0) {\n    rootChildren[0].destroy();\n}\n\n// Load the scene hierarchy with a callback when it has finished\nthis.app.scenes.loadSceneHierarchy(sceneItem, (err, loadedSceneRootEntity) => {\n    if (err) {\n        console.error(err);\n    } else {\n        // Scene hierarchy has successfully been loaded\n    }\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["However, as mentioned above, there is a delay between calling ",(0,t.jsx)(n.code,{children:"loadSceneHierarchy"})," and the scene data actually being loaded. This means that there will be a few frames where the application will be rendering a blank screen while it's waiting for the network request to complete which brings us to the alternative."]}),"\n",(0,t.jsx)(n.h3,{id:"destroying-the-old-scene-root-entity-after-the-new-scene-is-loaded",children:"Destroying the old scene root entity after the new scene is loaded"}),"\n",(0,t.jsx)(n.p,{children:"This would mean that the old scene hierarchy will be destroyed in the callback after the new scene hierarchy has been added to hierarchy which ensures that the old scene would be present while the scene data is loaded from network."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Find the Scene Registry Item by the name of the scene\nconst sceneItem = this.app.scenes.find('Some Scene Name');\n\n// Assume the old scene hierarchy's root entity is named 'Root' which is the default name\nconst oldSceneRootEntity = this.app.root.findByName('Root');\n\n// Load the scene hierarchy with a callback when it has finished\nthis.app.scenes.loadSceneHierarchy(sceneItem, (err, loadedSceneRootEntity) => {\n    if (err) {\n        console.error(err);\n    } else {\n        // Scene hierarchy has successfully been loaded\n        oldSceneRootEntity.destroy();\n    }\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["However, the old scene will be present in the hierarchy while the new scene's scriptTypes call ",(0,t.jsx)(n.code,{children:"initialize"})," and ",(0,t.jsx)(n.code,{children:"postInitialize"}),". This can cause issues if there is some dependency or assumptions in the scripts that it's the only scene hierarchy that is loaded. Examples would be searching for an entity by name in ",(0,t.jsx)(n.code,{children:"initialize"})," and there is also an entity with the same name in the old scene hierarchy. The script would then have a reference to the old scene hierarchy's entity instead of the new scene's which will cause unexpected behavior once the old scene's hierarchy is destroyed."]}),"\n",(0,t.jsxs)(n.p,{children:["To help mitigate these potential issues, we have an API that allows the separation of loading the scene data from the creation of the scene hierarchy in the scene, ",(0,t.jsx)(n.a,{href:"https://api.playcanvas.com/engine/classes/SceneRegistry.html#loadscenedata",children:(0,t.jsx)(n.code,{children:"SceneRegistry.loadSceneData"})}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"managing-assets-in-scenes",children:"Managing Assets in Scenes"}),"\n",(0,t.jsx)(n.p,{children:"A common question with scenes is if the assets used in the scene will be loaded as part of the scene load. With PlayCanvas, the assets and scenes are separate and will need to be loaded separately which gives the developer a large degree of flexibility."}),"\n",(0,t.jsx)(n.p,{children:"The recommended practice is to tag assets with the scene name they belong to. When loading a scene, load the tagged assets first, then load the scene once all assets are ready."}),"\n",(0,t.jsxs)(n.p,{children:["More information about asset tags and asset loading can be found on ",(0,t.jsx)(n.a,{href:"/user-manual/assets/preloading/",children:"this page"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://playcanvas.com/project/926754/",children:"example project"})," below loads the assets when loading the scene and unloads when returning the main menu."]}),"\n",(0,t.jsx)("div",{className:"iframe-container",children:(0,t.jsx)("iframe",{src:"https://playcanv.as/e/p/SBTfOAeM/",title:"Loading scenes and assets",allow:"camera; microphone; xr-spatial-tracking; fullscreen",allowfullscreen:!0})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}}}]);