"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[66005],{28453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>i});var a=n(96540);const t={},r=a.createContext(t);function o(e){const s=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),a.createElement(r.Provider,{value:s},e.children)}},36209:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"user-manual/graphics/posteffects/cameraframe/compose-shader","title":"Customizing the Compose Shader","description":"The simplest way to add custom post-effects is by customizing the final compose pass, where all effects are combined and rendered to the backbuffer. This approach is ideal when you don\'t need additional render passes and want to modify the final output.","source":"@site/docs/user-manual/graphics/posteffects/cameraframe/compose-shader.md","sourceDirName":"user-manual/graphics/posteffects/cameraframe","slug":"/user-manual/graphics/posteffects/cameraframe/compose-shader","permalink":"/user-manual/graphics/posteffects/cameraframe/compose-shader","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/graphics/posteffects/cameraframe/compose-shader.md","tags":[],"version":"current","frontMatter":{"title":"Customizing the Compose Shader"},"sidebar":"userManualSidebar","previous":{"title":"Modern Post Processing","permalink":"/user-manual/graphics/posteffects/cameraframe/"},"next":{"title":"Extending RenderPassCameraFrame Class","permalink":"/user-manual/graphics/posteffects/cameraframe/extending-class"}}');var t=n(74848),r=n(28453);const o={title:"Customizing the Compose Shader"},i=void 0,c={},l=[{value:"Overview",id:"overview",level:2},{value:"Example: Simple Pixelation Effect",id:"example-simple-pixelation-effect",level:2},{value:"Important Notes",id:"important-notes",level:2},{value:"Resources",id:"resources",level:2},{value:"Use Cases",id:"use-cases",level:2}];function d(e){const s={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"The simplest way to add custom post-effects is by customizing the final compose pass, where all effects are combined and rendered to the backbuffer. This approach is ideal when you don't need additional render passes and want to modify the final output."}),"\n",(0,t.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(s.p,{children:["You can inject custom shader code by overriding shader chunks before creating the ",(0,t.jsx)(s.code,{children:"CameraFrame"}),". The compose pass provides three empty chunks specifically for customization:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"composeDeclarationsPS"})," - Add custom uniform declarations and helper functions"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"composeMainStartPS"})," - Add code at the start of the main function"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"composeMainEndPS"})," - Add code at the end of the main function, just before the final output"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"example-simple-pixelation-effect",children:"Example: Simple Pixelation Effect"}),"\n",(0,t.jsx)(s.p,{children:"Here's a complete example showing how to add a pixelation effect:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-javascript",children:"import * as pc from 'playcanvas';\n\n// Override compose shader chunks before creating CameraFrame\nconst shaderChunks = pc.ShaderChunks.get(graphicsDevice, pc.SHADERLANGUAGE_GLSL);\n\nshaderChunks.set('composeDeclarationsPS', `\n    uniform float pixelSize;\n`);\n\nshaderChunks.set('composeMainEndPS', `\n    // Apply pixelation effect\n    vec2 pixelatedUV = floor(uv0 / pixelSize) * pixelSize;\n    color = getLinear(texture2D(sceneTexture, pixelatedUV));\n`);\n\n// For WebGPU, also set WGSL chunks\nconst wgslChunks = pc.ShaderChunks.get(graphicsDevice, pc.SHADERLANGUAGE_WGSL);\nwgslChunks.set('composeDeclarationsPS', `\n    uniform pixelSize: f32;\n`);\n\nwgslChunks.set('composeMainEndPS', `\n    let pixelatedUV: vec2f = floor(input.uv0 / uniform.pixelSize) * uniform.pixelSize;\n    color = getLinear(textureSample(sceneTexture, sceneTextureSampler, pixelatedUV));\n`);\n\n// Now create the CameraFrame\nconst cameraFrame = new pc.CameraFrame(app, cameraEntity.camera);\ncameraFrame.update();\n\n// Set the custom uniform value\napp.on('update', () => {\n    graphicsDevice.scope.resolve('pixelSize').setValue(0.005);\n});\n"})}),"\n",(0,t.jsx)(s.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Global Application"}),": Changes to shader chunks are applied globally to all ",(0,t.jsx)(s.code,{children:"CameraFrame"})," instances."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"WebGPU Support"}),": Remember to provide both GLSL and WGSL shader chunks for cross-platform compatibility."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Timing"}),": Shader chunks must be set before creating the ",(0,t.jsx)(s.code,{children:"CameraFrame"})," instance."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"resources",children:"Resources"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"https://playcanvas.vercel.app/#/graphics/custom-compose-shader",children:"Custom Compose Shader Example"})," - Complete working demonstration"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,t.jsx)(s.p,{children:"This approach is ideal for:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Adding simple screen-space effects (vignette, color adjustments, distortion)"}),"\n",(0,t.jsx)(s.li,{children:"Post-processing that doesn't require additional textures or render passes"}),"\n",(0,t.jsx)(s.li,{children:"Quick prototyping of visual effects"}),"\n",(0,t.jsx)(s.li,{children:"Effects that operate on the final composed image"}),"\n"]})]})}function p(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);