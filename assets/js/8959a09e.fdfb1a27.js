"use strict";(self.webpackChunkdeveloper_playcanvas_com=self.webpackChunkdeveloper_playcanvas_com||[]).push([[36137],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>l});var a=n(96540);const r={},s=a.createContext(r);function i(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:t},e.children)}},67507:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"tutorials/custom-shaders","title":"Custom Shaders","description":"This tutorial uses the ShaderMaterial API to create a dissolve effect with burning edges that works with both WebGL and WebGPU. The complete project can be found here.","source":"@site/docs/tutorials/custom-shaders.md","sourceDirName":"tutorials","slug":"/tutorials/custom-shaders","permalink":"/tutorials/custom-shaders","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/tutorials/custom-shaders.md","tags":[{"inline":true,"label":"shaders","permalink":"/tags/shaders"},{"inline":true,"label":"materials","permalink":"/tags/materials"}],"version":"current","frontMatter":{"title":"Custom Shaders","tags":["shaders","materials"],"thumb":"https://s3-eu-west-1.amazonaws.com/images.playcanvas.com/projects/12/406044/4J2JX2-image-75.jpg"},"sidebar":"tutorialsSidebar","previous":{"title":"Custom Post Effects","permalink":"/tutorials/custom-posteffect"},"next":{"title":"Detecting a double click","permalink":"/tutorials/detecting-a-double-click"}}');var r=n(74848),s=n(28453);const i={title:"Custom Shaders",tags:["shaders","materials"],thumb:"https://s3-eu-west-1.amazonaws.com/images.playcanvas.com/projects/12/406044/4J2JX2-image-75.jpg"},l=void 0,h={},o=[{value:"ShaderMaterial API",id:"shadermaterial-api",level:2},{value:"Cross-Platform Shader Support",id:"cross-platform-shader-support",level:2},{value:"Vertex Shaders",id:"vertex-shaders",level:2},{value:"GLSL Vertex Shader",id:"glsl-vertex-shader",level:3},{value:"WGSL Vertex Shader",id:"wgsl-vertex-shader",level:3},{value:"Fragment Shaders",id:"fragment-shaders",level:2},{value:"GLSL Fragment Shader",id:"glsl-fragment-shader",level:3},{value:"WGSL Fragment Shader",id:"wgsl-fragment-shader",level:3},{value:"Creating the ShaderMaterial",id:"creating-the-shadermaterial",level:2},{value:"Setting Shader Parameters",id:"setting-shader-parameters",level:2},{value:"Script Attributes for Shader Assets",id:"script-attributes-for-shader-assets",level:2},{value:"Updating Uniforms",id:"updating-uniforms",level:2},{value:"Complete Script",id:"complete-script",level:2},{value:"GLSL vs WGSL Differences",id:"glsl-vs-wgsl-differences",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("div",{className:"iframe-container",children:(0,r.jsx)("iframe",{src:"https://playcanv.as/p/zwvhLoS9/",title:"Custom Shaders",allow:"camera; microphone; xr-spatial-tracking; fullscreen",allowfullscreen:!0})}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsxs)(t.p,{children:["This tutorial uses the ",(0,r.jsx)(t.a,{href:"https://api.playcanvas.com/engine/classes/ShaderMaterial.html",children:"ShaderMaterial"})," API to create a dissolve effect with burning edges that works with both WebGL and WebGPU. The complete project can be found ",(0,r.jsx)(t.a,{href:"https://playcanvas.com/project/406044/overview/tutorial-custom-shaders",children:"here"}),"."]})}),"\n",(0,r.jsxs)(t.p,{children:["When you import your 3D models into PlayCanvas by default they will use our ",(0,r.jsx)(t.a,{href:"/user-manual/graphics/physical-rendering/physical-materials/",children:"Physical Material"}),". This is a versatile material type that can cover a lot of your rendering needs."]}),"\n",(0,r.jsx)(t.p,{children:"However, you will often want to perform special effects or special cases for your materials. To do this you will need to write a custom shader."}),"\n",(0,r.jsx)(t.h2,{id:"shadermaterial-api",children:"ShaderMaterial API"}),"\n",(0,r.jsxs)(t.p,{children:["PlayCanvas provides the ",(0,r.jsx)(t.a,{href:"https://api.playcanvas.com/engine/classes/ShaderMaterial.html",children:"ShaderMaterial"})," API which simplifies the creation of custom shaders and supports both WebGL (GLSL) and WebGPU (WGSL). This API automatically handles the differences between graphics APIs and provides a cleaner interface for shader development."]}),"\n",(0,r.jsx)(t.h2,{id:"cross-platform-shader-support",children:"Cross-Platform Shader Support"}),"\n",(0,r.jsxs)(t.p,{children:["To ensure your custom shaders work across all devices and browsers, you should provide both ",(0,r.jsx)(t.a,{href:"/user-manual/graphics/shaders/glsl-specifics/",children:"GLSL"})," and ",(0,r.jsx)(t.a,{href:"/user-manual/graphics/shaders/wgsl-specifics/",children:"WGSL"})," versions of your shaders:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"GLSL"})," (OpenGL Shading Language): Used by WebGL"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"WGSL"})," (WebGPU Shading Language): Used by WebGPU"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"vertex-shaders",children:"Vertex Shaders"}),"\n",(0,r.jsx)(t.h3,{id:"glsl-vertex-shader",children:"GLSL Vertex Shader"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-glsl",children:"attribute vec3 aPosition;\nattribute vec2 aUv0;\n\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\n\nvarying vec2 vUv0;\n\nvoid main(void)\n{\n    vUv0 = aUv0;\n    gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, 1.0);\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"wgsl-vertex-shader",children:"WGSL Vertex Shader"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-wgsl",children:"attribute aPosition: vec3f;\nattribute aUv0: vec2f;\n\nuniform matrix_viewProjection: mat4x4f;\nuniform matrix_model: mat4x4f;\n\nvarying vUv0: vec2f;\n\n@vertex\nfn vertexMain(input: VertexInput) -> VertexOutput {\n    var output: VertexOutput;\n\n    output.vUv0 = aUv0;\n    output.position = uniform.matrix_viewProjection * uniform.matrix_model * vec4<f32>(aPosition, 1.0);\n\n    return output;\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"fragment-shaders",children:"Fragment Shaders"}),"\n",(0,r.jsx)(t.h3,{id:"glsl-fragment-shader",children:"GLSL Fragment Shader"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-glsl",children:"varying vec2 vUv0;\n\nuniform sampler2D uDiffuseMap;\nuniform sampler2D uHeightMap;\nuniform float uTime;\n\nvoid main(void)\n{\n    float height = texture2D(uHeightMap, vUv0).r;\n    vec4 color = texture2D(uDiffuseMap, vUv0);\n\n    if (height < uTime) {\n        discard;\n    }\n\n    // Burning band width\n    float edgeWidth = 0.05;\n\n    if (height < (uTime + edgeWidth)) {\n        // 0 at inner edge \u2192 1 at outer edge\n        float t = (height - uTime) / edgeWidth;\n\n        // Fire gradient: yellow to dark orange\n        vec3 burnColor = mix(\n            vec3(1.0, 0.7, 0.2),\n            vec3(0.6, 0.1, 0.0),\n            t\n        );\n\n        // Blend the burn color with the original texture\n        color = vec4(mix(burnColor, color.rgb, t), 1.0);\n    }\n\n    gl_FragColor = color;\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"wgsl-fragment-shader",children:"WGSL Fragment Shader"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-wgsl",children:"varying vUv0: vec2f;\n\nuniform uTime: f32;\n\nvar uDiffuseMap: texture_2d<f32>;\nvar uDiffuseMapSampler: sampler;\nvar uHeightMap: texture_2d<f32>;\nvar uHeightMapSampler: sampler;\n\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n    var output: FragmentOutput;\n\n    let height = textureSample(uHeightMap, uHeightMapSampler, vUv0).r;\n    var color = textureSample(uDiffuseMap, uDiffuseMapSampler, vUv0);\n\n    if (height < uniform.uTime) {\n        discard;\n    }\n\n    // Burning band width\n    let edgeWidth = 0.05;\n\n    if (height < (uniform.uTime + edgeWidth)) {\n        // t goes from 0 (just inside edge) to 1 (outer edge)\n        let t = (height - uniform.uTime) / edgeWidth;\n\n        // Fire color: bright yellow fading to dark orange\n        let burnColor = mix(\n            vec3f(1.0, 0.7, 0.2),\n            vec3f(0.6, 0.1, 0.0),\n            t\n        );\n\n        // Blend burn color with original texture (more burn at the outer edge)\n        color = vec4f(mix(burnColor, color.rgb, t), 1.0);\n    }\n\n    output.color = color;\n    return output;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The shaders above create a dissolve effect with a fire-like burning edge. The vertex shaders transform mesh vertices into screen space, while the fragment shaders create the dissolve effect based on a height map texture. When the ",(0,r.jsx)(t.code,{children:"uTime"})," value is greater than the height map value at a pixel, that pixel is discarded (making the model transparent there). Near the dissolve edge, we blend in a fire-colored gradient for a realistic burning effect."]}),"\n",(0,r.jsx)(t.h2,{id:"creating-the-shadermaterial",children:"Creating the ShaderMaterial"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"// Create a new ShaderMaterial with both GLSL and WGSL versions\nthis.material = new ShaderMaterial({\n    uniqueName: 'Dissolve',\n    vertexGLSL: this.vertexGLSL.resource,\n    fragmentGLSL: this.fragmentGLSL.resource,\n    vertexWGSL: this.vertexWGSL.resource,\n    fragmentWGSL: this.fragmentWGSL.resource,\n    attributes: {\n        aPosition: SEMANTIC_POSITION,\n        aUv0: SEMANTIC_TEXCOORD0\n    }\n});\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.a,{href:"https://api.playcanvas.com/engine/classes/ShaderMaterial.html#constructor",children:"ShaderMaterial constructor"})," takes both GLSL and WGSL shader code. PlayCanvas will automatically choose the appropriate version based on the graphics API being used. The ",(0,r.jsx)(t.code,{children:"attributes"})," object specifies the vertex attributes your shaders expect."]}),"\n",(0,r.jsx)(t.h2,{id:"setting-shader-parameters",children:"Setting Shader Parameters"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"// Set the initial time parameter\nthis.material.setParameter('uTime', 0);\n\n// Set the diffuse texture\nconst diffuseTexture = this.diffuseMap.resource;\nthis.material.setParameter('uDiffuseMap', diffuseTexture);\n\n// Set the height map texture\nconst heightTexture = this.heightMap.resource;\nthis.material.setParameter('uHeightMap', heightTexture);\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Uniforms are set using the ",(0,r.jsx)(t.a,{href:"https://api.playcanvas.com/engine/classes/Material.html#setparameter",children:(0,r.jsx)(t.code,{children:"setParameter()"})})," method, which works the same way as with regular materials. The ShaderMaterial automatically handles the differences between GLSL and WGSL uniform syntax."]}),"\n",(0,r.jsx)(t.h2,{id:"script-attributes-for-shader-assets",children:"Script Attributes for Shader Assets"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"/**\n * GLSL vertex shader.\n * \n * @attribute\n * @title GLSL Vertex Shader\n * @type {pc.Asset}\n */\nvertexGLSL;\n\n/**\n * GLSL fragment shader.\n * \n * @attribute\n * @title GLSL Fragment Shader\n * @type {pc.Asset}\n */\nfragmentGLSL;\n\n/**\n * WGSL vertex shader.\n * \n * @attribute\n * @title WGSL Vertex Shader\n * @type {pc.Asset}\n */\nvertexWGSL;\n\n/**\n * WGSL fragment shader.\n * \n * @attribute\n * @title WGSL Fragment Shader\n * @type {pc.Asset}\n */\nfragmentWGSL;\n\n/**\n * Diffuse Map\n * \n * @attribute\n * @title Diffuse Map\n * @type {pc.Asset}\n */\ndiffuseMap;\n\n/**\n * Height Map\n * \n * @attribute\n * @title Height Map\n * @type {pc.Asset}\n */\nheightMap;\n"})}),"\n",(0,r.jsx)(t.p,{children:"You'll need to create four shader assets (two GLSL and two WGSL) and assign them to these script attributes in the PlayCanvas Editor."}),"\n",(0,r.jsx)(t.h2,{id:"updating-uniforms",children:"Updating Uniforms"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"update(dt) {\n    this.time += dt;\n\n    // Create a smooth oscillation using sine wave\n    const t = (Math.sin(this.time) + 1) / 2;\n\n    // Update the time value in the material\n    this.material.setParameter('uTime', t);\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"To achieve the dissolving effect, we use the height map value as a threshold that changes over time. In this version, we use a sine wave to create a smooth oscillation between 0 and 1, providing a more natural dissolve animation."}),"\n",(0,r.jsx)(t.h2,{id:"complete-script",children:"Complete Script"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"import { Script, ShaderMaterial, SEMANTIC_POSITION, SEMANTIC_TEXCOORD0 } from 'playcanvas';\n\n/**\n * Apply a dissolve shader material to an entity's render components.\n */\nexport class CustomShader extends Script {\n    scriptName = 'dissolveShader';\n\n    /**\n     * GLSL vertex shader.\n     * \n     * @attribute\n     * @title GLSL Vertex Shader\n     * @type {pc.Asset}\n     */\n    vertexGLSL;\n\n    /**\n     * GLSL fragment shader.\n     * \n     * @attribute\n     * @title GLSL Fragment Shader\n     * @type {pc.Asset}\n     */\n    fragmentGLSL;\n\n    /**\n     * WGSL vertex shader.\n     * \n     * @attribute\n     * @title WGSL Vertex Shader\n     * @type {pc.Asset}\n     */\n    vertexWGSL;\n\n    /**\n     * WGSL fragment shader.\n     * \n     * @attribute\n     * @title WGSL Fragment Shader\n     * @type {pc.Asset}\n     */\n    fragmentWGSL;\n\n    /**\n     * Diffuse Map\n     * \n     * @attribute\n     * @title Diffuse Map\n     * @type {pc.Asset}\n     */\n    diffuseMap;\n\n    /**\n     * Height Map\n     * \n     * @attribute\n     * @title Height Map\n     * @type {pc.Asset}\n     */\n    heightMap;\n\n    time = 0;\n\n    // initialize code called once per entity\n    initialize() {\n        // Create a new material and set the shader\n        this.material = new ShaderMaterial({\n            uniqueName: 'Dissolve',\n            vertexGLSL: this.vertexGLSL.resource,\n            fragmentGLSL: this.fragmentGLSL.resource,\n            vertexWGSL: this.vertexWGSL.resource,\n            fragmentWGSL: this.fragmentWGSL.resource,\n            attributes: {\n                aPosition: SEMANTIC_POSITION,\n                aUv0: SEMANTIC_TEXCOORD0\n            }\n        });\n\n        // Set the initial time parameter\n        this.material.setParameter('uTime', 0);\n\n        // Set the diffuse texture\n        const diffuseTexture = this.diffuseMap.resource;\n        this.material.setParameter('uDiffuseMap', diffuseTexture);\n\n        // Set the height map texture\n        const heightTexture = this.heightMap.resource;\n        this.material.setParameter('uHeightMap', heightTexture);\n\n        // Replace the material on all render components\n        const renders = this.entity.findComponents('render');\n        for (let i = 0; i < renders.length; ++i) {\n            const meshInstances = renders[i].meshInstances;\n            for (let j = 0; j < meshInstances.length; j++) {\n                meshInstances[j].material = this.material;\n            }\n        }\n    }\n\n    // update code called every frame\n    update(dt) {\n        this.time += dt;\n\n        // Create a smooth oscillation using sine wave\n        const t = (Math.sin(this.time) + 1) / 2;\n\n        // Update the time value in the material\n        this.material.setParameter('uTime', t);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"This script demonstrates how to create cross-platform custom shaders using the ShaderMaterial API. The dissolve effect uses a height map to determine which pixels to discard, creating a burning edge effect as the dissolution progresses."}),"\n",(0,r.jsx)(t.h2,{id:"glsl-vs-wgsl-differences",children:"GLSL vs WGSL Differences"}),"\n",(0,r.jsx)(t.p,{children:"When writing shaders for both APIs, keep these key differences in mind:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Syntax"}),": WGSL uses more explicit typing (",(0,r.jsx)(t.code,{children:"vec3f"}),", ",(0,r.jsx)(t.code,{children:"f32"}),") while GLSL infers types"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Attributes/Varyings"}),": WGSL uses structured input/output while GLSL uses global variables"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Textures"}),": WGSL separates textures and samplers, GLSL combines them"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Entry points"}),": WGSL uses ",(0,r.jsx)(t.code,{children:"@vertex"})," and ",(0,r.jsx)(t.code,{children:"@fragment"})," decorators, GLSL uses ",(0,r.jsx)(t.code,{children:"main()"})]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"The ShaderMaterial API handles these differences automatically, allowing you to focus on the shader logic rather than API-specific details."})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);