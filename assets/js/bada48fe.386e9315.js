"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[66334],{6937:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"user-manual/graphics/shaders/glsl-specifics","title":"GLSL Specifics","description":"GLSL shaders used by the PlayCanvas engine must satisfy certain requirements. These requirements allow the engine to correctly integrate shaders, ensuring they receive the necessary resources such as attributes, uniforms, and varyings. Following these rules also allows us to automatically process the shader for slightly different requirements when transpiling to WGSL for use with WebGPU.","source":"@site/docs/user-manual/graphics/shaders/glsl-specifics.md","sourceDirName":"user-manual/graphics/shaders","slug":"/user-manual/graphics/shaders/glsl-specifics","permalink":"/user-manual/graphics/shaders/glsl-specifics","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/graphics/shaders/glsl-specifics.md","tags":[],"version":"current","frontMatter":{"title":"GLSL Specifics"},"sidebar":"userManualSidebar","previous":{"title":"Shaders","permalink":"/user-manual/graphics/shaders/"},"next":{"title":"WGSL Specifics","permalink":"/user-manual/graphics/shaders/wgsl-specifics"}}');var i=n(74848),t=n(28453);const a={title:"GLSL Specifics"},l=void 0,c={},o=[{value:"Attributes",id:"attributes",level:3},{value:"Uniforms",id:"uniforms",level:3},{value:"Precision Qualifiers",id:"precision-qualifiers",level:3},{value:"Varyings",id:"varyings",level:3}];function d(e){const s={a:"a",admonition:"admonition",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:"GLSL shaders used by the PlayCanvas engine must satisfy certain requirements. These requirements allow the engine to correctly integrate shaders, ensuring they receive the necessary resources such as attributes, uniforms, and varyings. Following these rules also allows us to automatically process the shader for slightly different requirements when transpiling to WGSL for use with WebGPU."}),"\n",(0,i.jsx)(s.p,{children:"The following sections outline key aspects of writing GLSL shaders for PlayCanvas."}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"#version"})," should not be included in the shader source. PlayCanvas automatically adds the appropriate version directive based on whether WebGL2 or WebGPU is targeted."]})}),"\n",(0,i.jsx)(s.h3,{id:"attributes",children:"Attributes"}),"\n",(0,i.jsx)(s.p,{children:"Attributes define per-vertex input data, and can only be used in the vertex shader. They must be declared using the following syntax:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-glsl",children:"attribute vec2 aUv0;\n"})}),"\n",(0,i.jsxs)(s.p,{children:["The attribute names must match the names specified in the ",(0,i.jsx)(s.code,{children:"attributes"})," property when creating the ",(0,i.jsx)(s.a,{href:"/user-manual/graphics/shaders/",children:"ShaderMaterial"}),"."]}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"in"})," keyword (introduced in GLSL 3.3+) is not supported."]})}),"\n",(0,i.jsx)(s.h3,{id:"uniforms",children:"Uniforms"}),"\n",(0,i.jsx)(s.p,{children:"Uniforms are used to pass resources from the engine to the shader. They are declared in the standard way for numerical and texture uniforms:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-glsl",children:"uniform vec3 view_position;\n"})}),"\n",(0,i.jsx)(s.p,{children:"The engine automatically sets appropriate uniform values when rendering."}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["Currently, our uniform system supports only simple types, including ",(0,i.jsx)(s.code,{children:"float"}),", ",(0,i.jsx)(s.code,{children:"int"}),", ",(0,i.jsx)(s.code,{children:"uint"}),", as well as vectors and matrices (e.g., ",(0,i.jsx)(s.code,{children:"vec4"}),", ",(0,i.jsx)(s.code,{children:"mat4"}),"). Structs are not supported at this time, so all uniform values must be declared as individual variables of basic types."]})}),"\n",(0,i.jsx)(s.h3,{id:"precision-qualifiers",children:"Precision Qualifiers"}),"\n",(0,i.jsxs)(s.p,{children:["PlayCanvas automatically sets ",(0,i.jsx)(s.code,{children:"highp"})," precision (when supported by the device) for the following types:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"float"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"int"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"uint"})}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"usampler2D"})," (unsigned integer textures)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"isampler2D"})," (signed integer textures)"]}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"sampler2DShadow"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"samplerCubeShadow"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"sampler2DArray"})}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["The following sampler types do ",(0,i.jsx)(s.strong,{children:"not"})," have default precision set:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"sampler2D"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"sampler3D"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"samplerCube"})}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["If you need ",(0,i.jsx)(s.code,{children:"highp"})," precision for these types, you must specify it manually. This is particularly important when sampling from floating-point textures (e.g., ",(0,i.jsx)(s.code,{children:"RGBA32F"}),") where full 32-bit precision is required. Without ",(0,i.jsx)(s.code,{children:"highp"}),", sampled values may lose precision. Note that ",(0,i.jsx)(s.code,{children:"highp"})," is not applied to standard samplers by default due to potential performance impact on mobile GPUs."]}),"\n",(0,i.jsx)(s.p,{children:"To apply precision to all samplers of a type:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-glsl",children:"precision highp sampler2D;\n\nuniform sampler2D hdrTextureA;\nuniform sampler2D hdrTextureB;\n"})}),"\n",(0,i.jsx)(s.p,{children:"To apply precision to a single uniform:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-glsl",children:"uniform highp sampler2D hdrTexture;\nuniform sampler2D ldrTexture;\n"})}),"\n",(0,i.jsx)(s.h3,{id:"varyings",children:"Varyings"}),"\n",(0,i.jsx)(s.p,{children:"Varyings are used to pass values from the vertex shader to the fragment shader. They must be declared using standard GLSL syntax:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-glsl",children:"varying vec2 uv0;\n"})}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"in"}),"/",(0,i.jsx)(s.code,{children:"out"})," syntax (introduced in GLSL 3.3+) is not supported."]})})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>l});var r=n(96540);const i={},t=r.createContext(i);function a(e){const s=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);