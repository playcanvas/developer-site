"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[82499],{28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var i=s(96540);const r={},d=i.createContext(r);function a(e){const n=i.useContext(d);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(d.Provider,{value:n},e.children)}},73221:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"user-manual/graphics/shaders/preprocessor","title":"Shader Preprocessor","description":"Before shaders are compiled, PlayCanvas applies a C-style preprocessor to the source code. This allows you to manage shader variations, conditionally include code, and inject values. The preprocessor works with GLSL, WGSL, and compute shaders.","source":"@site/docs/user-manual/graphics/shaders/preprocessor.md","sourceDirName":"user-manual/graphics/shaders","slug":"/user-manual/graphics/shaders/preprocessor","permalink":"/ja/user-manual/graphics/shaders/preprocessor","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/graphics/shaders/preprocessor.md","tags":[],"version":"current","frontMatter":{"title":"Shader Preprocessor"},"sidebar":"userManualSidebar","previous":{"title":"\u30b7\u30a7\u30fc\u30c0\u30fc","permalink":"/ja/user-manual/graphics/shaders/"},"next":{"title":"GLSL \u306e\u8a73\u7d30","permalink":"/ja/user-manual/graphics/shaders/glsl-specifics"}}');var r=s(74848),d=s(28453);const a={title:"Shader Preprocessor"},l=void 0,c={},o=[{value:"Preprocessor Directives",id:"preprocessor-directives",level:2},{value:"Define and Undefine",id:"define-and-undefine",level:3},{value:"Conditional Compilation",id:"conditional-compilation",level:3},{value:"If-Else-Elif Chains",id:"if-else-elif-chains",level:3},{value:"Logical Operators",id:"logical-operators",level:3},{value:"Comparison Operators",id:"comparison-operators",level:3},{value:"Include Directive",id:"include-directive",level:3},{value:"Registering Custom Shader Chunks",id:"registering-custom-shader-chunks",level:4},{value:"Looped Includes",id:"looped-includes",level:4},{value:"Injection Defines vs Regular Defines",id:"injection-defines-vs-regular-defines",level:2},{value:"Regular Defines",id:"regular-defines",level:3},{value:"Injection Defines (Curly Brace Syntax)",id:"injection-defines-curly-brace-syntax",level:3},{value:"Supplying Defines to Shaders",id:"supplying-defines-to-shaders",level:2},{value:"ShaderMaterial Defines",id:"shadermaterial-defines",level:3},{value:"Shader Definition Defines",id:"shader-definition-defines",level:3},{value:"Vertex and Fragment Shaders",id:"vertex-and-fragment-shaders",level:4},{value:"Compute Shaders",id:"compute-shaders",level:4},{value:"Includes Map",id:"includes-map",level:3},{value:"Defines Map",id:"defines-map",level:3},{value:"Best Practices",id:"best-practices",level:2}];function t(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Before shaders are compiled, PlayCanvas applies a C-style preprocessor to the source code. This allows you to manage shader variations, conditionally include code, and inject values. The preprocessor works with GLSL, WGSL, and compute shaders."}),"\n",(0,r.jsx)(n.h2,{id:"preprocessor-directives",children:"Preprocessor Directives"}),"\n",(0,r.jsx)(n.p,{children:"The following directives are supported:"}),"\n",(0,r.jsx)(n.h3,{id:"define-and-undefine",children:"Define and Undefine"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:"#define FEATURE_ENABLED\n#define MAX_LIGHTS 4\n#define MULTIPLIER 2.5\n\n#undef FEATURE_ENABLED\n"})}),"\n",(0,r.jsx)(n.p,{children:"Defines can be simple flags (no value) or have associated values."}),"\n",(0,r.jsx)(n.h3,{id:"conditional-compilation",children:"Conditional Compilation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:"#ifdef FEATURE_ENABLED\n    // Code included only if FEATURE_ENABLED is defined\n#endif\n\n#ifndef FEATURE_ENABLED\n    // Code included only if FEATURE_ENABLED is NOT defined\n#endif\n\n#if defined(FEATURE_A) && defined(FEATURE_B)\n    // Code included if both FEATURE_A and FEATURE_B are defined\n#endif\n\n#if MAX_LIGHTS > 2\n    // Code included if MAX_LIGHTS is greater than 2\n#endif\n"})}),"\n",(0,r.jsx)(n.h3,{id:"if-else-elif-chains",children:"If-Else-Elif Chains"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:"#if QUALITY == 0\n    // Low quality path\n#elif QUALITY == 1\n    // Medium quality path\n#else\n    // High quality path\n#endif\n"})}),"\n",(0,r.jsx)(n.h3,{id:"logical-operators",children:"Logical Operators"}),"\n",(0,r.jsxs)(n.p,{children:["The preprocessor supports ",(0,r.jsx)(n.code,{children:"&&"})," (AND), ",(0,r.jsx)(n.code,{children:"||"})," (OR), and ",(0,r.jsx)(n.code,{children:"!"})," (NOT) operators:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:"#if defined(FEATURE_A) && !defined(FEATURE_B)\n    // FEATURE_A is defined but FEATURE_B is not\n#endif\n\n#if defined(FEATURE_A) || defined(FEATURE_B)\n    // At least one of FEATURE_A or FEATURE_B is defined\n#endif\n"})}),"\n",(0,r.jsx)(n.h3,{id:"comparison-operators",children:"Comparison Operators"}),"\n",(0,r.jsxs)(n.p,{children:["Supported operators: ",(0,r.jsx)(n.code,{children:"=="}),", ",(0,r.jsx)(n.code,{children:"!="}),", ",(0,r.jsx)(n.code,{children:"<"}),", ",(0,r.jsx)(n.code,{children:"<="}),", ",(0,r.jsx)(n.code,{children:">"}),", ",(0,r.jsx)(n.code,{children:">="})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:"#if MAX_LIGHTS >= 4\n    // 4 or more lights supported\n#endif\n\n#if QUALITY != 0\n    // Not low quality\n#endif\n"})}),"\n",(0,r.jsx)(n.h3,{id:"include-directive",children:"Include Directive"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"#include"})," directive inserts content from registered shader chunks:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:'#include "chunkName"\n'})}),"\n",(0,r.jsx)(n.p,{children:"For example, to include engine-provided chunks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:'#include "gammaPS"\n#include "tonemappingPS"\n'})}),"\n",(0,r.jsx)(n.h4,{id:"registering-custom-shader-chunks",children:"Registering Custom Shader Chunks"}),"\n",(0,r.jsxs)(n.p,{children:["The recommended way to add custom includes is by registering them with ",(0,r.jsx)(n.code,{children:"ShaderChunks"}),". This allows you to provide both GLSL and WGSL versions, and the engine automatically uses the appropriate one:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Get the shader chunks for each language\nconst chunksGLSL = pc.ShaderChunks.get(device, pc.SHADERLANGUAGE_GLSL);\nconst chunksWGSL = pc.ShaderChunks.get(device, pc.SHADERLANGUAGE_WGSL);\n\n// Register your custom chunk in both languages\nchunksGLSL.set('myUtilsPS', `\n    float myHelper(float x) {\n        return x * 2.0;\n    }\n`);\n\nchunksWGSL.set('myUtilsPS', `\n    fn myHelper(x: f32) -> f32 {\n        return x * 2.0;\n    }\n`);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Once registered, use the chunk in your shaders with ",(0,r.jsx)(n.code,{children:"#include"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:'#include "myUtilsPS"\n\nvoid main() {\n    float result = myHelper(0.5);\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"looped-includes",children:"Looped Includes"}),"\n",(0,r.jsx)(n.p,{children:"You can include a chunk multiple times with a loop counter:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:'#define LIGHT_COUNT 4\n#include "lightPS, LIGHT_COUNT"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This includes ",(0,r.jsx)(n.code,{children:"lightPS"})," four times, with ",(0,r.jsx)(n.code,{children:"{i}"})," in the chunk replaced by ",(0,r.jsx)(n.code,{children:"0"}),", ",(0,r.jsx)(n.code,{children:"1"}),", ",(0,r.jsx)(n.code,{children:"2"}),", ",(0,r.jsx)(n.code,{children:"3"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"injection-defines-vs-regular-defines",children:"Injection Defines vs Regular Defines"}),"\n",(0,r.jsx)(n.p,{children:"The preprocessor supports two types of defines, distinguished by their syntax:"}),"\n",(0,r.jsx)(n.h3,{id:"regular-defines",children:"Regular Defines"}),"\n",(0,r.jsxs)(n.p,{children:["Regular defines work with preprocessor directives like ",(0,r.jsx)(n.code,{children:"#ifdef"})," and ",(0,r.jsx)(n.code,{children:"#if"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:"#define FEATURE_ENABLED\n#define MAX_LIGHTS 4\n\n#ifdef FEATURE_ENABLED\n    // This code is included\n#endif\n\n#if MAX_LIGHTS > 2\n    // This code is included\n#endif\n"})}),"\n",(0,r.jsx)(n.p,{children:"The GLSL language natively supports using defines in array sizes and similar contexts:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:"#define SAMPLE_COUNT 8\nfloat samples[SAMPLE_COUNT];\n"})}),"\n",(0,r.jsxs)(n.p,{children:["However, WGSL does not support this\u2014use injection defines with the ",(0,r.jsx)(n.code,{children:"{NAME}"})," syntax instead."]}),"\n",(0,r.jsx)(n.h3,{id:"injection-defines-curly-brace-syntax",children:"Injection Defines (Curly Brace Syntax)"}),"\n",(0,r.jsxs)(n.p,{children:["Injection defines use curly braces ",(0,r.jsx)(n.code,{children:"{NAME}"})," and perform direct string replacement throughout the shader source (excluding preprocessor directive lines):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:"#define {WORKGROUP_SIZE} 64\n\n@compute @workgroup_size({WORKGROUP_SIZE}, 1, 1)\nfn main() {\n    var<workgroup> data: array<f32, {WORKGROUP_SIZE}>;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"After preprocessing, this becomes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-glsl",children:"@compute @workgroup_size(64, 1, 1)\nfn main() {\n    var<workgroup> data: array<f32, 64>;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Injection defines are particularly useful for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"WGSL workgroup sizes (which must be compile-time constants)"}),"\n",(0,r.jsx)(n.li,{children:"Values that need to appear in non-preprocessor contexts"}),"\n",(0,r.jsxs)(n.li,{children:["Parameterizing shader code that doesn't support ",(0,r.jsx)(n.code,{children:"#if"})," substitution"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"supplying-defines-to-shaders",children:"Supplying Defines to Shaders"}),"\n",(0,r.jsx)(n.h3,{id:"shadermaterial-defines",children:"ShaderMaterial Defines"}),"\n",(0,r.jsxs)(n.p,{children:["For ",(0,r.jsx)(n.code,{children:"ShaderMaterial"}),", use ",(0,r.jsx)(n.code,{children:"setDefine()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"material.setDefine('USE_TEXTURE', true);\nmaterial.setDefine('MAX_LIGHTS', '4');\n"})}),"\n",(0,r.jsx)(n.h3,{id:"shader-definition-defines",children:"Shader Definition Defines"}),"\n",(0,r.jsxs)(n.p,{children:["When creating shaders programmatically (rather than using ",(0,r.jsx)(n.code,{children:"ShaderMaterial"}),"), you can supply defines."]}),"\n",(0,r.jsx)(n.h4,{id:"vertex-and-fragment-shaders",children:"Vertex and Fragment Shaders"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"ShaderUtils.createShader()"})," to create vertex/fragment shaders with defines:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const shader = pc.ShaderUtils.createShader(device, {\n    uniqueName: 'MyShader',\n    vertexGLSL: vertexCodeGLSL,\n    vertexWGSL: vertexCodeWGSL,\n    fragmentGLSL: fragmentCodeGLSL,\n    fragmentWGSL: fragmentCodeWGSL,\n    vertexDefines: definesMap,\n    fragmentDefines: definesMap\n});\n"})}),"\n",(0,r.jsx)(n.h4,{id:"compute-shaders",children:"Compute Shaders"}),"\n",(0,r.jsxs)(n.p,{children:["Compute shaders are created directly using the ",(0,r.jsx)(n.code,{children:"Shader"})," class:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const shader = new pc.Shader(device, {\n    name: 'MyComputeShader',\n    shaderLanguage: pc.SHADERLANGUAGE_WGSL,\n    cshader: computeCode,\n    cincludes: includesMap,  // Custom includes for compute shader\n    cdefines: definesMap     // Defines for compute shader\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"includes-map",children:"Includes Map"}),"\n",(0,r.jsxs)(n.p,{children:["The includes map provides content for ",(0,r.jsx)(n.code,{children:"#include"})," directives:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const includesMap = new Map([\n    ['myChunk', 'float helper() { return 1.0; }'],\n    ['anotherChunk', '// More shader code...']\n]);\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can also use engine-provided chunks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"cincludes: pc.ShaderChunks.get(device, pc.SHADERLANGUAGE_WGSL)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"defines-map",children:"Defines Map"}),"\n",(0,r.jsx)(n.p,{children:"The defines map uses the key as the define name (including curly braces for injection defines):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Regular defines (for #ifdef, #if)\nconst definesMap = new Map([\n    ['FEATURE_ENABLED', ''],      // Flag define (no value)\n    ['MAX_LIGHTS', '4']           // Value define\n]);\n\n// Injection defines (for direct replacement)\nconst definesMap = new Map([\n    ['{WORKGROUP_SIZE}', '64'],\n    ['{TILE_SIZE}', '16']\n]);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use regular defines"})," for conditional compilation with ",(0,r.jsx)(n.code,{children:"#ifdef"})," and ",(0,r.jsx)(n.code,{children:"#if"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use injection defines"})," ",(0,r.jsx)(n.code,{children:"{NAME}"})," when you need direct string replacement in non-preprocessor contexts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prefer engine chunks"})," when available to ensure compatibility across platforms"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}}}]);