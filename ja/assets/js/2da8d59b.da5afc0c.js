"use strict";(globalThis.webpackChunkdeveloper_playcanvas_com=globalThis.webpackChunkdeveloper_playcanvas_com||[]).push([[97262],{10413:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"user-manual/graphics/shaders/compute-shaders","title":"Compute Shaders","description":"Compute shaders are programs that run general-purpose computations on the GPU, independent of the rendering pipeline. Unlike vertex and fragment shaders, compute shaders are not tied to geometry or pixels\u2014they operate on arbitrary data, making them ideal for tasks such as particle simulation, image processing, physics calculations, and procedural content generation.","source":"@site/docs/user-manual/graphics/shaders/compute-shaders.md","sourceDirName":"user-manual/graphics/shaders","slug":"/user-manual/graphics/shaders/compute-shaders","permalink":"/ja/user-manual/graphics/shaders/compute-shaders","draft":false,"unlisted":false,"editUrl":"https://github.com/playcanvas/developer.playcanvas.com/tree/dev/docs/user-manual/graphics/shaders/compute-shaders.md","tags":[],"version":"current","frontMatter":{"title":"Compute Shaders"},"sidebar":"userManualSidebar","previous":{"title":"WGSL \u306e\u8a73\u7d30","permalink":"/ja/user-manual/graphics/shaders/wgsl-specifics"},"next":{"title":"Shader Chunk Migrations","permalink":"/ja/user-manual/graphics/shaders/migrations"}}');var a=r(74848),s=r(28453);const i={title:"Compute Shaders"},c=void 0,o={},d=[{value:"Checking for Support",id:"checking-for-support",level:2},{value:"Creating a Compute Shader",id:"creating-a-compute-shader",level:2},{value:"Basic Shader Definition",id:"basic-shader-definition",level:3},{value:"Bind Group Format",id:"bind-group-format",level:3},{value:"Storage Buffers",id:"storage-buffers",level:4},{value:"Storage Textures",id:"storage-textures",level:4},{value:"Input Textures",id:"input-textures",level:4},{value:"Uniform Buffers",id:"uniform-buffers",level:4},{value:"Creating a Compute Instance",id:"creating-a-compute-instance",level:2},{value:"Setting Parameters",id:"setting-parameters",level:2},{value:"Creating Storage Buffers",id:"creating-storage-buffers",level:2},{value:"Creating Storage Textures",id:"creating-storage-textures",level:2},{value:"Dispatching Compute Shaders",id:"dispatching-compute-shaders",level:2},{value:"Workgroup Size",id:"workgroup-size",level:3},{value:"Indirect Dispatch",id:"indirect-dispatch",level:2},{value:"Reserving Dispatch Slots",id:"reserving-dispatch-slots",level:3},{value:"Writing Dispatch Parameters",id:"writing-dispatch-parameters",level:3},{value:"Using Indirect Dispatch",id:"using-indirect-dispatch",level:3},{value:"Custom Indirect Buffers",id:"custom-indirect-buffers",level:3},{value:"Reading Data Back to CPU",id:"reading-data-back-to-cpu",level:2},{value:"Preprocessor",id:"preprocessor",level:2},{value:"Defines and Includes",id:"defines-and-includes",level:3},{value:"Examples",id:"examples",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Compute shaders are programs that run general-purpose computations on the GPU, independent of the rendering pipeline. Unlike vertex and fragment shaders, compute shaders are not tied to geometry or pixels\u2014they operate on arbitrary data, making them ideal for tasks such as particle simulation, image processing, physics calculations, and procedural content generation."}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["Compute shaders are only supported on the ",(0,a.jsx)(n.strong,{children:"WebGPU"})," platform. They are not available when using WebGL."]})}),"\n",(0,a.jsx)(n.h2,{id:"checking-for-support",children:"Checking for Support"}),"\n",(0,a.jsx)(n.p,{children:"Before using compute shaders, verify that the device supports them:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"if (device.supportsCompute) {\n    // Compute shaders are available\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"creating-a-compute-shader",children:"Creating a Compute Shader"}),"\n",(0,a.jsxs)(n.p,{children:["A compute shader is created using the ",(0,a.jsx)(n.code,{children:"Shader"})," class with WGSL code. The shader definition includes the compute shader source (",(0,a.jsx)(n.code,{children:"cshader"}),"), bind group format, and optionally uniform buffer formats."]}),"\n",(0,a.jsx)(n.h3,{id:"basic-shader-definition",children:"Basic Shader Definition"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const shader = new pc.Shader(device, {\n    name: 'MyComputeShader',\n    shaderLanguage: pc.SHADERLANGUAGE_WGSL,\n    cshader: `\n        @compute @workgroup_size(1, 1, 1)\n        fn main(@builtin(global_invocation_id) global_id: vec3u) {\n            // Compute shader logic here\n        }\n    `,\n    computeBindGroupFormat: new pc.BindGroupFormat(device, [\n        // Resource bindings go here\n    ])\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["By default, the engine expects the entry point function to be named ",(0,a.jsx)(n.code,{children:"main"}),". You can use ",(0,a.jsx)(n.code,{children:"computeEntryPoint"})," to specify a different function name, which also allows a single shader source to contain multiple entry points:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const shaderSource = `\n    @compute @workgroup_size(64, 1, 1)\n    fn initParticles(@builtin(global_invocation_id) global_id: vec3u) {\n        // Initialize particles\n    }\n\n    @compute @workgroup_size(64, 1, 1)\n    fn updateParticles(@builtin(global_invocation_id) global_id: vec3u) {\n        // Update particles\n    }\n`;\n\n// Create separate shaders from the same source, each using a different entry point\nconst initShader = new pc.Shader(device, {\n    name: 'InitParticles',\n    shaderLanguage: pc.SHADERLANGUAGE_WGSL,\n    cshader: shaderSource,\n    computeEntryPoint: 'initParticles',\n    // ...\n});\n\nconst updateShader = new pc.Shader(device, {\n    name: 'UpdateParticles',\n    shaderLanguage: pc.SHADERLANGUAGE_WGSL,\n    cshader: shaderSource,\n    computeEntryPoint: 'updateParticles',\n    // ...\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"bind-group-format",children:"Bind Group Format"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"computeBindGroupFormat"})," defines what resources are available to the compute shader. You can bind various types of resources:"]}),"\n",(0,a.jsx)(n.h4,{id:"storage-buffers",children:"Storage Buffers"}),"\n",(0,a.jsx)(n.p,{children:"Storage buffers allow read/write access to large amounts of data:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Read-write storage buffer\nnew pc.BindStorageBufferFormat('particles', pc.SHADERSTAGE_COMPUTE)\n\n// Read-only storage buffer\nnew pc.BindStorageBufferFormat('spheres', pc.SHADERSTAGE_COMPUTE, true)\n"})}),"\n",(0,a.jsx)(n.p,{children:"In WGSL, access storage buffers like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"@group(0) @binding(0) var<storage, read_write> particles: array<f32>;\n@group(0) @binding(1) var<storage, read> spheres: array<vec4f>;\n"})}),"\n",(0,a.jsx)(n.h4,{id:"storage-textures",children:"Storage Textures"}),"\n",(0,a.jsx)(n.p,{children:"Storage textures allow the compute shader to write directly to a texture:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"new pc.BindStorageTextureFormat('outTexture', pc.PIXELFORMAT_RGBA8, pc.TEXTUREDIMENSION_2D)\n"})}),"\n",(0,a.jsx)(n.p,{children:"In WGSL:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"@group(0) @binding(0) var outputTexture: texture_storage_2d<rgba8unorm, write>;\n\n// Writing to the texture\ntextureStore(outputTexture, vec2i(global_id.xy), color);\n"})}),"\n",(0,a.jsx)(n.h4,{id:"input-textures",children:"Input Textures"}),"\n",(0,a.jsx)(n.p,{children:"Input textures provide read-only texture data. The last parameter controls whether a sampler is included:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Texture without sampler (for textureLoad)\nnew pc.BindTextureFormat('inputTexture', pc.SHADERSTAGE_COMPUTE, undefined, undefined, false)\n\n// Texture with sampler (for textureSampleLevel)\nnew pc.BindTextureFormat('inputTexture', pc.SHADERSTAGE_COMPUTE, undefined, undefined, true)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In WGSL, when a sampler is included, it uses the texture name with a ",(0,a.jsx)(n.code,{children:"_sampler"})," suffix:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"// Without sampler - use textureLoad for direct texel access\n@group(0) @binding(0) var inputTexture: texture_2d<f32>;\nlet color = textureLoad(inputTexture, position, 0);\n\n// With sampler - use textureSampleLevel for filtered sampling\n@group(0) @binding(0) var inputTexture: texture_2d<f32>;\n@group(0) @binding(1) var inputTexture_sampler: sampler;\nlet color = textureSampleLevel(inputTexture, inputTexture_sampler, uv, 0.0);\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["In compute shaders, use ",(0,a.jsx)(n.code,{children:"textureSampleLevel"})," instead of ",(0,a.jsx)(n.code,{children:"textureSample"})," because you must explicitly specify the mip level (LOD)."]})}),"\n",(0,a.jsx)(n.h4,{id:"uniform-buffers",children:"Uniform Buffers"}),"\n",(0,a.jsx)(n.p,{children:"For passing uniform data to compute shaders, first define the uniform buffer format:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const uniformBufferFormat = new pc.UniformBufferFormat(device, [\n    new pc.UniformFormat('tint', pc.UNIFORMTYPE_VEC4),\n    new pc.UniformFormat('time', pc.UNIFORMTYPE_FLOAT),\n    new pc.UniformFormat('count', pc.UNIFORMTYPE_UINT)\n]);\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then include it in the shader definition along with the bind group:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const shader = new pc.Shader(device, {\n    name: 'ComputeShader',\n    shaderLanguage: pc.SHADERLANGUAGE_WGSL,\n    cshader: shaderCode,\n\n    // Assign the uniform buffer format\n    computeUniformBufferFormats: {\n        ub: uniformBufferFormat\n    },\n\n    // Include uniform buffer in bind group\n    computeBindGroupFormat: new pc.BindGroupFormat(device, [\n        new pc.BindUniformBufferFormat('ub', pc.SHADERSTAGE_COMPUTE),\n        // ... other bindings\n    ])\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"In WGSL:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"struct ub_compute {\n    tint: vec4f,\n    time: f32,\n    count: u32\n}\n\n@group(0) @binding(0) var<uniform> ubCompute: ub_compute;\n\n@compute @workgroup_size(1, 1, 1)\nfn main(@builtin(global_invocation_id) global_id: vec3u) {\n    let t = ubCompute.time;\n    let c = ubCompute.count;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"creating-a-compute-instance",children:"Creating a Compute Instance"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Compute"})," class represents an executable instance of a compute shader with its associated parameters:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const compute = new pc.Compute(device, shader, 'MyComputeInstance');\n"})}),"\n",(0,a.jsx)(n.h2,{id:"setting-parameters",children:"Setting Parameters"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"setParameter"})," to bind resources and set uniform values:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Bind a storage buffer\ncompute.setParameter('particles', storageBuffer);\n\n// Bind a texture\ncompute.setParameter('inputTexture', texture);\n\n// Set uniform values\ncompute.setParameter('time', 1.5);\ncompute.setParameter('count', 1024);\ncompute.setParameter('tint', [1.0, 0.5, 0.0, 1.0]);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"creating-storage-buffers",children:"Creating Storage Buffers"}),"\n",(0,a.jsx)(n.p,{children:"Storage buffers hold data that compute shaders can read from and write to:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const storageBuffer = new pc.StorageBuffer(\n    device,\n    bufferSizeInBytes,\n    pc.BUFFERUSAGE_COPY_SRC |  // Enable reading back to CPU\n    pc.BUFFERUSAGE_COPY_DST    // Enable writing from CPU\n);\n\n// Write initial data\nconst data = new Float32Array([...]);\nstorageBuffer.write(0, data);\n\n// Clear the buffer\nstorageBuffer.clear();\n"})}),"\n",(0,a.jsx)(n.h2,{id:"creating-storage-textures",children:"Creating Storage Textures"}),"\n",(0,a.jsxs)(n.p,{children:["Storage textures are created with the ",(0,a.jsx)(n.code,{children:"storage: true"})," option:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const storageTexture = new pc.Texture(device, {\n    name: 'StorageTexture',\n    width: 512,\n    height: 512,\n    format: pc.PIXELFORMAT_RGBA8,\n    mipmaps: false,\n    minFilter: pc.FILTER_LINEAR,\n    magFilter: pc.FILTER_LINEAR,\n    storage: true  // Enable as storage texture\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"dispatching-compute-shaders",children:"Dispatching Compute Shaders"}),"\n",(0,a.jsx)(n.p,{children:"To execute a compute shader, first set up the dispatch dimensions, then dispatch:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Set up dispatch dimensions (number of workgroups in X, Y, Z)\ncompute.setupDispatch(width, height, 1);\n\n// Dispatch the compute shader\ndevice.computeDispatch([compute], 'MyDispatch');\n"})}),"\n",(0,a.jsx)(n.p,{children:"Multiple compute shaders can be dispatched together in a single compute pass:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"compute1.setupDispatch(64, 64);\ncompute2.setupDispatch(128, 128);\ndevice.computeDispatch([compute1, compute2], 'BatchedDispatch');\n"})}),"\n",(0,a.jsx)(n.h3,{id:"workgroup-size",children:"Workgroup Size"}),"\n",(0,a.jsxs)(n.p,{children:["The total number of invocations is ",(0,a.jsx)(n.code,{children:"dispatchSize \xd7 workgroupSize"}),". For example, if you dispatch with ",(0,a.jsx)(n.code,{children:"(width, height)"})," and your shader has ",(0,a.jsx)(n.code,{children:"@workgroup_size(1, 1, 1)"}),", you get ",(0,a.jsx)(n.code,{children:"width \xd7 height"})," invocations."]}),"\n",(0,a.jsx)(n.p,{children:"For better performance with large datasets, use larger workgroup sizes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"@compute @workgroup_size(64, 1, 1)\nfn main(@builtin(global_invocation_id) global_id: vec3u) {\n    // Process element at global_id.x\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then dispatch accordingly:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const numElements = 1024 * 1024;\nconst workgroupSize = 64;\ncompute.setupDispatch(numElements / workgroupSize);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"indirect-dispatch",children:"Indirect Dispatch"}),"\n",(0,a.jsx)(n.p,{children:"Indirect dispatch allows one compute shader to generate dispatch parameters for another compute shader, enabling fully GPU-driven workloads without CPU readback. This is useful for:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Variable workload sizes determined on the GPU"}),"\n",(0,a.jsx)(n.li,{children:"Tile-based processing where tile counts are computed dynamically"}),"\n",(0,a.jsx)(n.li,{children:"GPU culling followed by processing only visible elements"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"reserving-dispatch-slots",children:"Reserving Dispatch Slots"}),"\n",(0,a.jsx)(n.p,{children:"The device provides a built-in buffer for indirect dispatch parameters. Reserve slots each frame:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const slot = device.getIndirectDispatchSlot();\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Each slot holds three 32-bit unsigned integers representing the x, y, and z workgroup counts. The maximum number of slots is controlled by ",(0,a.jsx)(n.code,{children:"device.maxIndirectDispatchCount"})," (default: 256)."]}),"\n",(0,a.jsx)(n.h3,{id:"writing-dispatch-parameters",children:"Writing Dispatch Parameters"}),"\n",(0,a.jsx)(n.p,{children:"Pass the indirect buffer to your compute shader so it can write dispatch parameters. In your bind group format:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"new pc.BindStorageBufferFormat('indirectBuffer', pc.SHADERSTAGE_COMPUTE)\n"})}),"\n",(0,a.jsx)(n.p,{children:"In WGSL, define a struct matching the indirect dispatch layout and write the parameters:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-wgsl",children:"struct DispatchIndirectArgs {\n    x: u32,\n    y: u32,\n    z: u32\n};\n\n@group(0) @binding(0) var<storage, read_write> indirectBuffer: array<DispatchIndirectArgs>;\n@group(0) @binding(1) var<uniform> uniforms: Uniforms; // Contains slot index\n\n@compute @workgroup_size(1)\nfn main() {\n    // Compute workload size dynamically\n    let workloadSize = calculateWorkload();\n    \n    // Write dispatch parameters to the slot\n    indirectBuffer[uniforms.slot].x = workloadSize;\n    indirectBuffer[uniforms.slot].y = 1u;\n    indirectBuffer[uniforms.slot].z = 1u;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"using-indirect-dispatch",children:"Using Indirect Dispatch"}),"\n",(0,a.jsxs)(n.p,{children:["Configure the second compute shader to read dispatch parameters from the buffer using ",(0,a.jsx)(n.code,{children:"setupIndirectDispatch"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Reserve a slot for this frame\nconst slot = device.getIndirectDispatchSlot();\n\n// First pass: compute shader writes dispatch parameters\nprepareCompute.setParameter('indirectBuffer', device.indirectDispatchBuffer);\nprepareCompute.setParameter('slot', slot);\nprepareCompute.setupDispatch(1, 1, 1);\ndevice.computeDispatch([prepareCompute]);\n\n// Second pass: dispatch using parameters from the buffer\nprocessCompute.setupIndirectDispatch(slot);\ndevice.computeDispatch([processCompute]);\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["When using the device's built-in indirect buffer, ",(0,a.jsx)(n.code,{children:"setupIndirectDispatch"})," must be called each frame because slots are only valid for the current frame."]})}),"\n",(0,a.jsx)(n.h3,{id:"custom-indirect-buffers",children:"Custom Indirect Buffers"}),"\n",(0,a.jsx)(n.p,{children:"For advanced use cases like complex scheduling outside of rendering frames, you can provide your own storage buffer:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Create a custom buffer for indirect dispatch\nconst customBuffer = new pc.StorageBuffer(device, 3 * 4, pc.BUFFERUSAGE_INDIRECT);\n\n// Use custom buffer for indirect dispatch\ncompute.setupIndirectDispatch(0, customBuffer);\n"})}),"\n",(0,a.jsx)(n.p,{children:"When using a custom buffer, you manage its lifetime and contents\u2014no frame validation is performed."}),"\n",(0,a.jsx)(n.h2,{id:"reading-data-back-to-cpu",children:"Reading Data Back to CPU"}),"\n",(0,a.jsx)(n.p,{children:"To read results from a storage buffer back to the CPU:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const resultData = new Float32Array(numElements);\nstorageBuffer.read(0, undefined, resultData).then((data) => {\n    // Process the data\n    console.log('First value:', data[0]);\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note that ",(0,a.jsx)(n.code,{children:"read()"})," returns a Promise because GPU operations are asynchronous. The data will be available after the GPU finishes executing the compute shader, which may be several frames later."]}),"\n",(0,a.jsxs)(n.p,{children:["For time-critical reads, you can pass ",(0,a.jsx)(n.code,{children:"immediate: true"})," as the fourth parameter:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"storageBuffer.read(0, undefined, resultData, true).then((data) => {\n    // Data available sooner, but with performance cost\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["By default (",(0,a.jsx)(n.code,{children:"immediate: false"}),"), the read is deferred to the next event handling cycle when the GPU command buffer is naturally submitted. With ",(0,a.jsx)(n.code,{children:"immediate: true"}),", the command buffer is submitted immediately and the read executes right away."]}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["Using ",(0,a.jsx)(n.code,{children:"immediate: true"})," has a performance impact as it forces an early command buffer submission. Only use it when low-latency reads are essential."]})}),"\n",(0,a.jsx)(n.h2,{id:"preprocessor",children:"Preprocessor"}),"\n",(0,a.jsxs)(n.p,{children:["Compute shaders support the same ",(0,a.jsx)(n.a,{href:"/user-manual/graphics/shaders/preprocessor",children:"shader preprocessor"})," as vertex and fragment shaders, including ",(0,a.jsx)(n.code,{children:"#define"}),", ",(0,a.jsx)(n.code,{children:"#ifdef"}),", ",(0,a.jsx)(n.code,{children:"#if"}),", ",(0,a.jsx)(n.code,{children:"#include"}),", and more."]}),"\n",(0,a.jsx)(n.h3,{id:"defines-and-includes",children:"Defines and Includes"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"cdefines"})," to pass defines and ",(0,a.jsx)(n.code,{children:"cincludes"})," to provide include content:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const shader = new pc.Shader(device, {\n    name: 'ComputeShader',\n    shaderLanguage: pc.SHADERLANGUAGE_WGSL,\n    cshader: `\n        #include \"myHelper\"\n\n        @compute @workgroup_size({WORKGROUP_SIZE}, 1, 1)\n        fn main(@builtin(global_invocation_id) global_id: vec3u) {\n            var<workgroup> sharedData: array<f32, {WORKGROUP_SIZE}>;\n            // ...\n        }\n    `,\n    cdefines: new Map([\n        ['{WORKGROUP_SIZE}', '64']\n    ]),\n    cincludes: pc.ShaderChunks.get(device, pc.SHADERLANGUAGE_WGSL),\n    // ...\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"{WORKGROUP_SIZE}"})," placeholders are replaced with ",(0,a.jsx)(n.code,{children:"64"})," before compilation. See the ",(0,a.jsx)(n.a,{href:"/user-manual/graphics/shaders/preprocessor",children:"preprocessor documentation"})," for details on regular defines vs injection defines."]}),"\n",(0,a.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(n.p,{children:"Explore these live examples demonstrating various compute shader use cases:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://playcanvas.github.io/#/compute/histogram",children:"Histogram"})," - Compute image histogram using atomic operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://playcanvas.github.io/#/compute/texture-gen",children:"Texture Generation"})," - Generate and modify textures with compute shaders"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://playcanvas.github.io/#/compute/particles",children:"Particles"})," - GPU-based particle simulation with collision detection"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://playcanvas.github.io/#/compute/vertex-update",children:"Vertex Update"})," - Modify mesh vertex buffers in real-time"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://playcanvas.github.io/#/compute/edge-detect",children:"Edge Detect"})," - Image processing with edge detection"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://playcanvas.github.io/#/compute/indirect-draw",children:"Indirect Draw"})," - GPU-driven rendering with indirect draw calls"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://playcanvas.github.io/#/compute/indirect-dispatch",children:"Indirect Dispatch"})," - GPU-driven compute dispatch with depth-based tile classification"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>c});var t=r(96540);const a={},s=t.createContext(a);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);