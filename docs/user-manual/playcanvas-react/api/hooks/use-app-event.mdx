---
title: useAppEvent
description: Subscribe to PlayCanvas application events
---

# useAppEvent

The `useAppEvent` hook allows you to subscribe to PlayCanvas application events with proper TypeScript typing and automatic cleanup. It supports both built-in events and custom events.

## Basic Usage

```jsx copy
import { useAppEvent } from '@playcanvas/react/hooks'

function MyComponent() {
  useAppEvent('update', (dt) => {
    console.log('Frame time:', dt)
  })
  
  useAppEvent('prerender', () => {
    console.log('Pre-rendering')
  })
  
  return null
}
```

## Parameters

- **event** (`TEventName`) - The event name to subscribe to
- **callback** (`TEventMap[TEventName]`) - The callback function to execute when the event fires

## Built-in Events

### Update Event

```jsx copy
import { useAppEvent } from '@playcanvas/react/hooks'

function UpdateHandler() {
  useAppEvent('update', (dt) => {
    // dt is the delta time since the last frame
    console.log('Delta time:', dt)
    
    // Your update logic here
    // This runs every frame
  })
  
  return null
}
```

### Render Events

```jsx copy
import { useAppEvent } from '@playcanvas/react/hooks'

function RenderHandler() {
  useAppEvent('prerender', () => {
    console.log('About to render frame')
    // Pre-render logic
  })
  
  useAppEvent('postrender', () => {
    console.log('Finished rendering frame')
    // Post-render logic
  })
  
  return null
}
```

## Custom Events

You can define custom event types with TypeScript:

```jsx copy
import { useAppEvent } from '@playcanvas/react/hooks'

// Define your custom event map
interface MyEventMap {
  levelComplete: (level: number, score: number) => void
  playerDeath: (position: [number, number, number]) => void
  itemCollected: (itemId: string, quantity: number) => void
}

function GameEventHandler() {
  useAppEvent<MyEventMap>('levelComplete', (level, score) => {
    console.log(`Level ${level} completed with score ${score}`)
  })
  
  useAppEvent<MyEventMap>('playerDeath', (position) => {
    console.log('Player died at position:', position)
  })
  
  useAppEvent<MyEventMap>('itemCollected', (itemId, quantity) => {
    console.log(`Collected ${quantity} of item ${itemId}`)
  })
  
  return null
}
```

## Event Firing

To fire custom events, you need access to the app instance:

```jsx copy
import { useAppEvent, useApp } from '@playcanvas/react/hooks'

function EventFirer() {
  const app = useApp()
  
  useAppEvent('update', (dt) => {
    // Fire custom events
    app.fire('levelComplete', 1, 1000)
    app.fire('playerDeath', [0, 0, 0])
    app.fire('itemCollected', 'coin', 1)
  })
  
  return null
}
```

## Game State Management

```jsx copy
import { useAppEvent } from '@playcanvas/react/hooks'
import { useState, useEffect } from 'react'

interface GameEvents {
  gameStart: () => void
  gamePause: () => void
  gameResume: () => void
  gameEnd: (finalScore: number) => void
}

function GameStateManager() {
  const [gameState, setGameState] = useState('menu')
  const [score, setScore] = useState(0)
  
  useAppEvent<GameEvents>('gameStart', () => {
    setGameState('playing')
    setScore(0)
  })
  
  useAppEvent<GameEvents>('gamePause', () => {
    setGameState('paused')
  })
  
  useAppEvent<GameEvents>('gameResume', () => {
    setGameState('playing')
  })
  
  useAppEvent<GameEvents>('gameEnd', (finalScore) => {
    setGameState('ended')
    setScore(finalScore)
  })
  
  return (
    <div>
      <p>Game State: {gameState}</p>
      <p>Score: {score}</p>
    </div>
  )
}
```

## Input Handling

```jsx copy
import { useAppEvent } from '@playcanvas/react/hooks'

interface InputEvents {
  keyDown: (key: string) => void
  keyUp: (key: string) => void
  mouseClick: (x: number, y: number) => void
  mouseMove: (x: number, y: number) => void
}

function InputHandler() {
  useAppEvent<InputEvents>('keyDown', (key) => {
    console.log('Key pressed:', key)
  })
  
  useAppEvent<InputEvents>('keyUp', (key) => {
    console.log('Key released:', key)
  })
  
  useAppEvent<InputEvents>('mouseClick', (x, y) => {
    console.log('Mouse clicked at:', x, y)
  })
  
  useAppEvent<InputEvents>('mouseMove', (x, y) => {
    console.log('Mouse moved to:', x, y)
  })
  
  return null
}
```

## Physics Events

```jsx copy
import { useAppEvent } from '@playcanvas/react/hooks'

interface PhysicsEvents {
  collisionStart: (entityA: string, entityB: string) => void
  collisionEnd: (entityA: string, entityB: string) => void
  triggerEnter: (entity: string, trigger: string) => void
  triggerExit: (entity: string, trigger: string) => void
}

function PhysicsEventHandler() {
  useAppEvent<PhysicsEvents>('collisionStart', (entityA, entityB) => {
    console.log(`Collision between ${entityA} and ${entityB}`)
  })
  
  useAppEvent<PhysicsEvents>('collisionEnd', (entityA, entityB) => {
    console.log(`Collision ended between ${entityA} and ${entityB}`)
  })
  
  useAppEvent<PhysicsEvents>('triggerEnter', (entity, trigger) => {
    console.log(`${entity} entered trigger ${trigger}`)
  })
  
  useAppEvent<PhysicsEvents>('triggerExit', (entity, trigger) => {
    console.log(`${entity} exited trigger ${trigger}`)
  })
  
  return null
}
```

## Performance Monitoring

```jsx copy
import { useAppEvent } from '@playcanvas/react/hooks'
import { useState, useEffect } from 'react'

function PerformanceMonitor() {
  const [fps, setFps] = useState(0)
  const [frameTime, setFrameTime] = useState(0)
  
  useAppEvent('update', (dt) => {
    setFrameTime(dt)
    setFps(1 / dt)
  })
  
  return (
    <div>
      <p>FPS: {fps.toFixed(1)}</p>
      <p>Frame Time: {(frameTime * 1000).toFixed(2)}ms</p>
    </div>
  )
}
```

## Event Cleanup

The hook automatically handles event cleanup when the component unmounts:

```jsx copy
import { useAppEvent } from '@playcanvas/react/hooks'
import { useState } from 'react'

function ConditionalEventHandler() {
  const [isActive, setIsActive] = useState(true)
  
  if (!isActive) {
    return (
      <button onClick={() => setIsActive(true)}>
        Activate Event Handler
      </button>
    )
  }
  
  return (
    <div>
      <EventComponent />
      <button onClick={() => setIsActive(false)}>
        Deactivate Event Handler
      </button>
    </div>
  )
}

function EventComponent() {
  // Event listeners are automatically cleaned up when this unmounts
  useAppEvent('update', (dt) => {
    console.log('Event handler active, dt:', dt)
  })
  
  return <div>Event handler is active</div>
}
```

## TypeScript

The hook is fully typed with TypeScript:

```tsx
import { useAppEvent } from '@playcanvas/react/hooks'

// Built-in events are fully typed
useAppEvent('update', (dt: number) => {
  // dt is automatically typed as number
  console.log(dt)
})

// Custom events with custom types
interface CustomEvents {
  customEvent: (data: { id: string; value: number }) => void
}

useAppEvent<CustomEvents>('customEvent', (data) => {
  // data is automatically typed as { id: string; value: number }
  console.log(data.id, data.value)
})
```

## useFrame (Deprecated)

The `useFrame` hook is deprecated in favor of `useAppEvent`:

```jsx copy
import { useFrame } from '@playcanvas/react/hooks'

// ❌ Deprecated - use useAppEvent instead
function DeprecatedExample() {
  useFrame((dt) => {
    console.log('Frame time:', dt)
  })
  
  return null
}

// ✅ Recommended - use useAppEvent
function RecommendedExample() {
  useAppEvent('update', (dt) => {
    console.log('Frame time:', dt)
  })
  
  return null
}
```

## Best Practices

1. **Use TypeScript** - Define custom event maps for better type safety
2. **Handle cleanup** - Event listeners are automatically cleaned up
3. **Choose appropriate events** - Use the right event for your use case
4. **Avoid heavy computations** - Keep event handlers lightweight
5. **Use custom events** - Create domain-specific events for your game

## Related

- [useApp](./use-app) - Access the Application instance
- [useFrame](#useframe) - Deprecated frame update hook
- [Application Events](https://api.playcanvas.com/engine/classes/Application.html#events) - PlayCanvas application events documentation
