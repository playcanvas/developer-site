---
title: useParent
description: Access the parent Entity from React context
---

# useParent

The `useParent` hook provides access to the parent [Entity](https://api.playcanvas.com/engine/classes/Entity.html) from within your React components. It's essential for components that need to interact with their parent entity.

## Basic Usage

```jsx copy
import { useParent } from '@playcanvas/react/hooks'

function MyComponent() {
  const parent = useParent()
  
  // Access parent entity properties
  console.log('Parent name:', parent.name)
  console.log('Parent position:', parent.position)
  
  return null
}
```

## Returns

- **parent** (`Entity`) - The parent Entity instance

## Requirements

This hook must be used within an `<Entity>` component. If used outside of this context, it will throw an error.

```jsx
// ✅ Correct usage
<Entity>
  <MyComponent /> {/* useParent works here */}
</Entity>

// ❌ Incorrect usage
<MyComponent /> {/* useParent will throw an error */}
```

## Common Use Cases

### Accessing Entity Properties

```jsx copy
import { useParent } from '@playcanvas/react/hooks'

function EntityInfo() {
  const parent = useParent()
  
  return (
    <div>
      <p>Entity Name: {parent.name}</p>
      <p>Position: {parent.position.toString()}</p>
      <p>Rotation: {parent.rotation.toString()}</p>
      <p>Scale: {parent.scale.toString()}</p>
    </div>
  )
}
```

### Modifying Entity Transform

```jsx copy
import { useParent } from '@playcanvas/react/hooks'
import { useEffect } from 'react'

function AnimatedEntity() {
  const parent = useParent()
  
  useEffect(() => {
    // Animate the entity
    const interval = setInterval(() => {
      parent.rotate(0, 1, 0) // Rotate around Y axis
    }, 16) // ~60fps
    
    return () => clearInterval(interval)
  }, [parent])
  
  return null
}
```

### Adding Components Programmatically

```jsx copy
import { useParent } from '@playcanvas/react/hooks'
import { useEffect } from 'react'

function DynamicComponent() {
  const parent = useParent()
  
  useEffect(() => {
    // Add a component to the parent entity
    const renderComponent = parent.addComponent('render', {
      type: 'box',
      material: 'red'
    })
    
    return () => {
      // Clean up when component unmounts
      if (parent.c.render) {
        parent.removeComponent('render')
      }
    }
  }, [parent])
  
  return null
}
```

### Accessing Entity Components

```jsx copy
import { useParent } from '@playcanvas/react/hooks'

function ComponentAccessor() {
  const parent = useParent()
  
  // Check if entity has specific components
  const hasRender = !!parent.c.render
  const hasCollision = !!parent.c.collision
  const hasRigidbody = !!parent.c.rigidbody
  
  return (
    <div>
      <p>Has Render: {hasRender ? 'Yes' : 'No'}</p>
      <p>Has Collision: {hasCollision ? 'Yes' : 'No'}</p>
      <p>Has Rigidbody: {hasRigidbody ? 'Yes' : 'No'}</p>
    </div>
  )
}
```

### Working with Entity Hierarchy

```jsx copy
import { useParent } from '@playcanvas/react/hooks'

function HierarchyInfo() {
  const parent = useParent()
  
  return (
    <div>
      <p>Parent: {parent.parent?.name || 'Root'}</p>
      <p>Children: {parent.children.length}</p>
      <p>Depth: {getEntityDepth(parent)}</p>
    </div>
  )
}

function getEntityDepth(entity) {
  let depth = 0
  let current = entity.parent
  while (current) {
    depth++
    current = current.parent
  }
  return depth
}
```

### Event Handling on Entity

```jsx copy
import { useParent } from '@playcanvas/react/hooks'
import { useEffect } from 'react'

function EntityEventHandler() {
  const parent = useParent()
  
  useEffect(() => {
    const handleClick = (event) => {
      console.log('Entity clicked:', parent.name)
    }
    
    const handleHover = (event) => {
      console.log('Entity hovered:', parent.name)
    }
    
    // Add event listeners
    parent.on('click', handleClick)
    parent.on('hover', handleHover)
    
    return () => {
      // Clean up event listeners
      parent.off('click', handleClick)
      parent.off('hover', handleHover)
    }
  }, [parent])
  
  return null
}
```

### Entity State Management

```jsx copy
import { useParent } from '@playcanvas/react/hooks'
import { useState, useEffect } from 'react'

function EntityStateManager() {
  const parent = useParent()
  const [isVisible, setIsVisible] = useState(true)
  
  useEffect(() => {
    // Update entity visibility
    parent.enabled = isVisible
  }, [parent, isVisible])
  
  return (
    <button onClick={() => setIsVisible(!isVisible)}>
      {isVisible ? 'Hide' : 'Show'} Entity
    </button>
  )
}
```

### Working with Entity Tags

```jsx copy
import { useParent } from '@playcanvas/react/hooks'
import { useEffect } from 'react'

function TagManager() {
  const parent = useParent()
  
  useEffect(() => {
    // Add tags to the entity
    parent.tags.add('player')
    parent.tags.add('movable')
    
    return () => {
      // Clean up tags
      parent.tags.remove('player')
      parent.tags.remove('movable')
    }
  }, [parent])
  
  return null
}
```

## TypeScript

The hook is fully typed and returns the PlayCanvas `Entity` type:

```tsx
import { useParent } from '@playcanvas/react/hooks'
import { Entity } from 'playcanvas'

function TypedExample() {
  const parent: Entity = useParent()
  
  // parent is fully typed with all Entity methods and properties
  parent.position.set(1, 2, 3)
  parent.rotate(0, 1, 0)
  parent.addComponent('render')
}
```

## Error Handling

If the hook is used outside of an Entity context, it will throw a descriptive error:

```jsx
// This will throw: "`useParent` must be used within an App or Entity via a ParentContext.Provider"
function InvalidComponent() {
  const parent = useParent() // Error!
  return null
}
```

## Performance Considerations

1. **Entity Access** - The hook returns the same entity instance, so it's safe to use in dependencies
2. **Component Updates** - Accessing entity properties doesn't trigger React re-renders
3. **Event Listeners** - Remember to clean up event listeners in useEffect cleanup
4. **Component Lifecycle** - The entity persists across React component re-renders

## Best Practices

1. **Use within Entity components** - Always ensure the hook is used within an Entity context
2. **Clean up resources** - Remove event listeners and components in useEffect cleanup
3. **Avoid direct mutations** - Prefer React state for UI updates, use entity for 3D world updates
4. **Handle errors gracefully** - Check for component existence before accessing
5. **Use TypeScript** - Get full type safety for entity operations

## Related

- [Entity Component](./entity) - The component that provides the entity context
- [useApp](./use-app) - Access the Application instance
- [useComponent](./use-component) - Create components on the parent entity
- [Entity API](https://api.playcanvas.com/engine/classes/Entity.html) - PlayCanvas Entity documentation
